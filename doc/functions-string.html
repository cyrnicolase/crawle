<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>字符串函数和操作符</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="函数和操作符"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="数学函数和操作符"
HREF="functions-math.html"><LINK
REL="NEXT"
TITLE="二进制串函数和操作符"
HREF="functions-binarystring.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/func.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="数学函数和操作符"
HREF="functions-math.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 9. 函数和操作符</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="二进制串函数和操作符"
HREF="functions-binarystring.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-STRING"
>9.4. 字符串函数和操作符</A
></H1
><P
>    本节描述了用于检查和操作字符串值的函数和操作符。在这个环境中的串包括所有类型<TT
CLASS="TYPE"
>character</TT
>、<TT
CLASS="TYPE"
>character varying</TT
>和<TT
CLASS="TYPE"
>text</TT
>的值。除非另外说明，所有下面列出的函数都可以处理这些类型，不过要小心的是，在使用<TT
CLASS="TYPE"
>character</TT
>类型的时候， 它有自动填充空白的潜在影响。有些函数还可以处理位串类型。
   </P
><P
>    <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>定义了一些字符串函数，它们使用关键字，而不是逗号来分隔参数。详情请见<A
HREF="functions-string.html#FUNCTIONS-STRING-SQL"
>&#34920; 9-8</A
>，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>也提供了这些函数使用正常函数调用语法的版本（见<A
HREF="functions-string.html#FUNCTIONS-STRING-OTHER"
>&#34920; 9-9</A
>）。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>     由于存在从那些数据类型到<TT
CLASS="TYPE"
>text</TT
>的隐式强制措施，在<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.3之前，这些函数也可以接受多种非字符串数据类型。这些强制措施在目前的版本中已经被删除，因为它们常常导致令人惊讶的行为。不过，字符串串接操作符（<TT
CLASS="LITERAL"
>||</TT
>）仍然接受非字符串输入，只要至少一个输入是一种字符串类型，如<A
HREF="functions-string.html#FUNCTIONS-STRING-SQL"
>&#34920; 9-8</A
>所示。对于其他情况，如果你需要复制之前的行为，可以为<TT
CLASS="TYPE"
>text</TT
>插入一个显式强制措施。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-STRING-SQL"
></A
><P
><B
>&#34920; 9-8. <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>字符串函数和操作符</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>函数</TH
><TH
>返回类型</TH
><TH
>描述</TH
><TH
>例子</TH
><TH
>结果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="LITERAL"
>||</TT
>
        <TT
CLASS="PARAMETER"
>string</TT
></TT
></TD
><TD
> <TT
CLASS="TYPE"
>text</TT
> </TD
><TD
>        串接
        
       </TD
><TD
><TT
CLASS="LITERAL"
>'Post' || 'greSQL'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>PostgreSQL</TT
></TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="LITERAL"
>||</TT
>
        <TT
CLASS="PARAMETER"
>non-string</TT
></TT
>
        or
        <TT
CLASS="LITERAL"
><TT
CLASS="PARAMETER"
>non-string</TT
> <TT
CLASS="LITERAL"
>||</TT
>
        <TT
CLASS="PARAMETER"
>string</TT
></TT
>
       </TD
><TD
> <TT
CLASS="TYPE"
>text</TT
> </TD
><TD
>        使用一个非字符串输入的串接
       </TD
><TD
><TT
CLASS="LITERAL"
>'Value: ' || 42</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Value: 42</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>bit_length(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>串中的位数</TD
><TD
><TT
CLASS="LITERAL"
>bit_length('jose')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>32</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>char_length(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
> or <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>character_length(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>        串中字符数
        
        
       </TD
><TD
><TT
CLASS="LITERAL"
>char_length('jose')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>4</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>lower(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>将字符串转换为小写形式</TD
><TD
><TT
CLASS="LITERAL"
>lower('TOM')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>tom</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>octet_length(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>串中的字节数</TD
><TD
><TT
CLASS="LITERAL"
>octet_length('jose')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>4</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>overlay(<TT
CLASS="PARAMETER"
>string</TT
> placing <TT
CLASS="PARAMETER"
>string</TT
> from <TT
CLASS="TYPE"
>int</TT
> [<SPAN
CLASS="OPTIONAL"
>for <TT
CLASS="TYPE"
>int</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        替换子串
       </TD
><TD
><TT
CLASS="LITERAL"
>overlay('Txxxxas' placing 'hom' from 2 for 4)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Thomas</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>position(<TT
CLASS="PARAMETER"
>substring</TT
> in <TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>定位指定子串</TD
><TD
><TT
CLASS="LITERAL"
>position('om' in 'Thomas')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>substring(<TT
CLASS="PARAMETER"
>string</TT
> [<SPAN
CLASS="OPTIONAL"
>from <TT
CLASS="TYPE"
>int</TT
></SPAN
>] [<SPAN
CLASS="OPTIONAL"
>for <TT
CLASS="TYPE"
>int</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        提取子串
       </TD
><TD
><TT
CLASS="LITERAL"
>substring('Thomas' from 2 for 3)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>hom</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>substring(<TT
CLASS="PARAMETER"
>string</TT
> from <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        提取匹配POSIX正则表达式的子串。模式匹配详情见<A
HREF="functions-matching.html"
>第 9.7 &#33410;</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>substring('Thomas' from '...$')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>mas</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>substring(<TT
CLASS="PARAMETER"
>string</TT
> from <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> for <TT
CLASS="REPLACEABLE"
><I
>escape</I
></TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        提取匹配<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>正则表达式的子串。模式匹配详情见<A
HREF="functions-matching.html"
>第 9.7 &#33410;</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>substring('Thomas' from '%#"o_a#"_' for '#')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>oma</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>trim([<SPAN
CLASS="OPTIONAL"
>leading | trailing | both</SPAN
>]
        [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="PARAMETER"
>characters</TT
></SPAN
>] from
        <TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        从<TT
CLASS="PARAMETER"
>string</TT
>的开头/结尾/两端删除最长的只包含<TT
CLASS="PARAMETER"
>characters</TT
>（默认是一个空格）的串
       </TD
><TD
><TT
CLASS="LITERAL"
>trim(both 'x' from 'xTomxx')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Tom</TT
></TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>trim([<SPAN
CLASS="OPTIONAL"
>leading | trailing
        | both</SPAN
>] [<SPAN
CLASS="OPTIONAL"
>from</SPAN
>]
        <TT
CLASS="PARAMETER"
>string</TT
>
        [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="PARAMETER"
>, characters</TT
></SPAN
>]
        )</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        <CODE
CLASS="FUNCTION"
>trim()</CODE
>的非标准版本
       </TD
><TD
><TT
CLASS="LITERAL"
>trim(both from 'xTomxx', 'x')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Tom</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>upper(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>将字符串转换成大写形式</TD
><TD
><TT
CLASS="LITERAL"
>upper('tom')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>TOM</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>    还有额外的串操作函数可以用，它们在<A
HREF="functions-string.html#FUNCTIONS-STRING-OTHER"
>&#34920; 9-9</A
>中列出。它们有些在内部用于实现<A
HREF="functions-string.html#FUNCTIONS-STRING-SQL"
>&#34920; 9-8</A
>列出的<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>标准字符串函数。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-STRING-OTHER"
></A
><P
><B
>&#34920; 9-9. 其他字符串函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>函数</TH
><TH
>返回类型</TH
><TH
>描述</TH
><TH
>例子</TH
><TH
>结果</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>ascii(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>        参数第一个字符的<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>代码。对于<ACRONYM
CLASS="ACRONYM"
>UTF8</ACRONYM
>返回该字符的Unicode代码点。对于其他多字节编码，该参数必须是一个<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>字符。
       </TD
><TD
><TT
CLASS="LITERAL"
>ascii('x')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>120</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>btrim(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>
        [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>characters</TT
> <TT
CLASS="TYPE"
>text</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        从<TT
CLASS="PARAMETER"
>string</TT
>的开头或结尾删除最长的只包含<TT
CLASS="PARAMETER"
>characters</TT
>（默认是一个空格）的串
       </TD
><TD
><TT
CLASS="LITERAL"
>btrim('xyxtrimyyx', 'xy')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>trim</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>chr(<TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        给定代码的字符。对于<ACRONYM
CLASS="ACRONYM"
>UTF8</ACRONYM
>该参数被视作一个Unicode代码点。对于其他多字节编码该参数必须指定一个<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>字符。NULL (0) 字符不被允许，因为文本数据类型不能存储这种字节。
       </TD
><TD
><TT
CLASS="LITERAL"
>chr(65)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>A</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>concat(<TT
CLASS="PARAMETER"
>str</TT
> <TT
CLASS="TYPE"
>"any"</TT
>
         [, <TT
CLASS="PARAMETER"
>str</TT
> <TT
CLASS="TYPE"
>"any"</TT
> [, ...] ])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        串接所有参数的文本表示。NULL 参数被忽略。
       </TD
><TD
><TT
CLASS="LITERAL"
>concat('abcde', 2, NULL, 22)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>abcde222</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>concat_ws(<TT
CLASS="PARAMETER"
>sep</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>str</TT
> <TT
CLASS="TYPE"
>"any"</TT
>
        [, <TT
CLASS="PARAMETER"
>str</TT
> <TT
CLASS="TYPE"
>"any"</TT
> [, ...] ])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将除了第一个参数外的其他参数用分隔符串接在一起。第一个参数被用作分隔符字符串。NULL 参数被忽略。
       </TD
><TD
><TT
CLASS="LITERAL"
>concat_ws(',', 'abcde', 2, NULL, 22)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>abcde,2,22</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>convert(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>bytea</TT
>,
        <TT
CLASS="PARAMETER"
>src_encoding</TT
> <TT
CLASS="TYPE"
>name</TT
>,
        <TT
CLASS="PARAMETER"
>dest_encoding</TT
> <TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
>        将字符串转换为<TT
CLASS="PARAMETER"
>dest_encoding</TT
>。原始编码由<TT
CLASS="PARAMETER"
>src_encoding</TT
>指定。<TT
CLASS="PARAMETER"
>string</TT
>在这个编码中必须可用。转换可以使用<TT
CLASS="COMMAND"
>CREATE CONVERSION</TT
>定义。也有一些预定义的转换。可用的转换请见<A
HREF="functions-string.html#CONVERSION-NAMES"
>&#34920; 9-10</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>convert('text_in_utf8', 'UTF8', 'LATIN1')</TT
></TD
><TD
>用Latin-1编码(ISO 8859-1) 表示的<TT
CLASS="LITERAL"
>text_in_utf8</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>convert_from(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>bytea</TT
>,
        <TT
CLASS="PARAMETER"
>src_encoding</TT
> <TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将字符串转换为数据库编码。原始编码由<TT
CLASS="PARAMETER"
>src_encoding</TT
>指定。<TT
CLASS="PARAMETER"
>string</TT
>在这个编码中必须可用。
       </TD
><TD
><TT
CLASS="LITERAL"
>convert_from('text_in_utf8', 'UTF8')</TT
></TD
><TD
>用当前数据库编码表示的<TT
CLASS="LITERAL"
>text_in_utf8</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>convert_to(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>dest_encoding</TT
> <TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
>        将字符串转换为<TT
CLASS="PARAMETER"
>dest_encoding</TT
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>convert_to('some text', 'UTF8')</TT
></TD
><TD
>用UTF8编码表达的<TT
CLASS="LITERAL"
>some text</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>decode(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>format</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
>        从<TT
CLASS="PARAMETER"
>string</TT
>中的文本表达解码二进制数据。<TT
CLASS="PARAMETER"
>format</TT
>的选项和<CODE
CLASS="FUNCTION"
>encode</CODE
>中的一样。
       </TD
><TD
><TT
CLASS="LITERAL"
>decode('MTIzAAE=', 'base64')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>\x3132330001</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>encode(<TT
CLASS="PARAMETER"
>data</TT
> <TT
CLASS="TYPE"
>bytea</TT
>,
        <TT
CLASS="PARAMETER"
>format</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将二进制数据编码成一个文本表达。支持的格式有：<TT
CLASS="LITERAL"
>base64</TT
>、<TT
CLASS="LITERAL"
>hex</TT
>、<TT
CLASS="LITERAL"
>escape</TT
>。<TT
CLASS="LITERAL"
>escape</TT
>将零字节和高位组字节转换为八进制序列（<TT
CLASS="LITERAL"
>\</TT
><TT
CLASS="REPLACEABLE"
><I
>nnn</I
></TT
>）和双写的反斜线。
       </TD
><TD
><TT
CLASS="LITERAL"
>encode(E'123\\000\\001', 'base64')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MTIzAAE=</TT
></TD
></TR
><TR
><A
NAME="FORMAT"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>format</CODE
>(<TT
CLASS="PARAMETER"
>formatstr</TT
> <TT
CLASS="TYPE"
>text</TT
>
        [, <TT
CLASS="PARAMETER"
>formatarg</TT
> <TT
CLASS="TYPE"
>"any"</TT
> [, ...] ])</TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>         根据一个格式字符串格式化参数。该函数和C函数<CODE
CLASS="FUNCTION"
>sprintf</CODE
>相似。见<A
HREF="functions-string.html#FUNCTIONS-STRING-FORMAT"
>第 9.4.1 &#33410;</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>format('Hello %s, %1$s', 'World')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Hello World, World</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>initcap(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将每一个词的第一个字母转换为大写形式并把剩下的字母转换为小写形式。词是由非字母数字字符分隔的字母数字字符的序列。
       </TD
><TD
><TT
CLASS="LITERAL"
>initcap('hi THOMAS')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Hi Thomas</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>left(<TT
CLASS="PARAMETER"
>str</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>n</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        返回字符串中的前<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>个字符。当<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>为负时，将返回除了最后|<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>|个字符之外的所有字符。
        </TD
><TD
><TT
CLASS="LITERAL"
>left('abcde', 2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ab</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>length(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>        <TT
CLASS="PARAMETER"
>string</TT
>中的字符数
       </TD
><TD
><TT
CLASS="LITERAL"
>length('jose')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>4</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>length(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>bytea</TT
>,
        <TT
CLASS="PARAMETER"
>encoding</TT
> <TT
CLASS="TYPE"
>name</TT
> )</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>        <TT
CLASS="PARAMETER"
>string</TT
>在给定<TT
CLASS="PARAMETER"
>编码</TT
>中的字符数。<TT
CLASS="PARAMETER"
>string</TT
>必须在这个编码中有效。
       </TD
><TD
><TT
CLASS="LITERAL"
>length('jose', 'UTF8')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>4</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>lpad(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>length</TT
> <TT
CLASS="TYPE"
>int</TT
>
        [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>fill</TT
> <TT
CLASS="TYPE"
>text</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将<TT
CLASS="PARAMETER"
>string</TT
>通过前置字符<TT
CLASS="PARAMETER"
>fill</TT
>（默认是一个空格）填充到长度<TT
CLASS="PARAMETER"
>length</TT
>。如果<TT
CLASS="PARAMETER"
>string</TT
>已经长于<TT
CLASS="PARAMETER"
>length</TT
>，则它被（从右边）截断。
       </TD
><TD
><TT
CLASS="LITERAL"
>lpad('hi', 5, 'xy')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>xyxhi</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>ltrim(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>
        [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>characters</TT
> <TT
CLASS="TYPE"
>text</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        从<TT
CLASS="PARAMETER"
>string</TT
>的开头删除最长的只包含<TT
CLASS="PARAMETER"
>characters</TT
>（默认是一个空格）的串
       </TD
><TD
><TT
CLASS="LITERAL"
>ltrim('zzzytrim', 'xyz')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>trim</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>md5(<TT
CLASS="PARAMETER"
>string</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        计算<TT
CLASS="PARAMETER"
>string</TT
>的 MD5 哈希，返回十六进制的结果
       </TD
><TD
><TT
CLASS="LITERAL"
>md5('abc')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>900150983cd24fb0 d6963f7d28e17f72</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>parse_ident(<TT
CLASS="PARAMETER"
>qualified_identifier</TT
> <TT
CLASS="TYPE"
>text</TT
>
           [, <TT
CLASS="PARAMETER"
>strictmode</TT
> <TT
CLASS="TYPE"
>boolean</TT
> DEFAULT true ] )</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>        把<TT
CLASS="PARAMETER"
>qualified_identifier</TT
>分成一个标识符数组，
        移除单个标识符上的任何引号。默认情况下，
        最后一个标识符后面的多余字符会被当做错误。但是如果第二个参数为<TT
CLASS="LITERAL"
>false</TT
>，
        那么这一类多余的字符会被忽略（这种行为对于解析函数之类的对象名称有用）。
        注意这个函数不会截断超长标识符。如果想要进行截断，可以把结果转换成<TT
CLASS="TYPE"
>name[]</TT
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>parse_ident('"SomeSchema".someTable')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{SomeSchema,sometable}</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_client_encoding()</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>        当前的客户端编码名字
       </TD
><TD
><TT
CLASS="LITERAL"
>pg_client_encoding()</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SQL_ASCII</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>quote_ident(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将给定字符串返回成合适的引用形式，使它可以在一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>语句字符串中被用作一个标识符。只有需要时才会加上引号（即，如果字符串包含非标识符字符或可能是大小写折叠的）。嵌入的引号会被正确地双写。参见<A
HREF="plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE"
>&#20363; 41-1</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>quote_ident('Foo bar')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>"Foo bar"</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>quote_literal(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将给定字符串返回成合适的引用形式，使它可以在一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>语句字符串中被用作一个字符串文字。嵌入的引号会被正确地双写。注意<CODE
CLASS="FUNCTION"
>quote_literal</CODE
>对空输入返回空；如果参数可能为空，<CODE
CLASS="FUNCTION"
>quote_nullable</CODE
>通常更合适。参见<A
HREF="plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE"
>&#20363; 41-1</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>quote_literal(E'O\'Reilly')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>'O''Reilly'</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>quote_literal(<TT
CLASS="PARAMETER"
>value</TT
> <TT
CLASS="TYPE"
>anyelement</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        强迫给定值为文本并且接着将它用引号包围作为一个文本。嵌入的单引号和反斜线被正确的双写。
       </TD
><TD
><TT
CLASS="LITERAL"
>quote_literal(42.5)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>'42.5'</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>quote_nullable(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将给定字符串返回成合适的引用形式，使它可以在一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>语句字符串中被用作一个字符串文字；或者，如果参数为空，返回<TT
CLASS="LITERAL"
>NULL</TT
>。嵌入的引号会被正确地双写。请参见<A
HREF="plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE"
>&#20363; 41-1</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>quote_nullable(NULL)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>NULL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>quote_nullable(<TT
CLASS="PARAMETER"
>value</TT
> <TT
CLASS="TYPE"
>anyelement</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        强迫给定值为文本并且接着将它用引号包围作为一个文本；或者，如果参数为空，返回<TT
CLASS="LITERAL"
>NULL</TT
>。嵌入的单引号和反斜线被正确的双写。
       </TD
><TD
><TT
CLASS="LITERAL"
>quote_nullable(42.5)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>'42.5'</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>regexp_matches(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>pattern</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>flags</TT
> <TT
CLASS="TYPE"
>text</TT
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>setof text[]</TT
></TD
><TD
>        返回对<TT
CLASS="PARAMETER"
>string</TT
>匹配一个POSIX正则表达式得到的所有子串。详见<A
HREF="functions-matching.html#FUNCTIONS-POSIX-REGEXP"
>第 9.7.3 &#33410;</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>regexp_matches('foobarbequebaz', '(bar)(beque)')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{bar,beque}</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>regexp_replace(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>pattern</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>replacement</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>flags</TT
> <TT
CLASS="TYPE"
>text</TT
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        替换匹配一个POSIX正则表达式的子串。详见<A
HREF="functions-matching.html#FUNCTIONS-POSIX-REGEXP"
>第 9.7.3 &#33410;</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>regexp_replace('Thomas', '.[mN]a.', 'M')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ThM</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>regexp_split_to_array(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>pattern</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>flags</TT
> <TT
CLASS="TYPE"
>text</TT
> ])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>        使用一个POSIX正则表达式作为分隔符划分<TT
CLASS="PARAMETER"
>string</TT
>。详见<A
HREF="functions-matching.html#FUNCTIONS-POSIX-REGEXP"
>第 9.7.3 &#33410;</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>regexp_split_to_array('hello world', E'\\s+')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{hello,world}</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>regexp_split_to_table(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>pattern</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>flags</TT
> <TT
CLASS="TYPE"
>text</TT
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>setof text</TT
></TD
><TD
>        使用一个POSIX正则表达式作为分隔符划分<TT
CLASS="PARAMETER"
>string</TT
>。详见<A
HREF="functions-matching.html#FUNCTIONS-POSIX-REGEXP"
>第 9.7.3 &#33410;</A
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>regexp_split_to_table('hello world', E'\\s+')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>hello</TT
><P
><TT
CLASS="LITERAL"
>world</TT
></P
> (2 rows)</TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>repeat(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>number</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>重复<TT
CLASS="PARAMETER"
>string</TT
>指定的<TT
CLASS="PARAMETER"
>number</TT
>次</TD
><TD
><TT
CLASS="LITERAL"
>repeat('Pg', 4)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>PgPgPgPg</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>replace(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>from</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>to</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>将<TT
CLASS="PARAMETER"
>string</TT
>中出现的所有子串<TT
CLASS="PARAMETER"
>from</TT
>替换为子串<TT
CLASS="PARAMETER"
>to</TT
>
       </TD
><TD
><TT
CLASS="LITERAL"
>replace('abcdefabcdef', 'cd', 'XX')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>abXXefabXXef</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>reverse(<TT
CLASS="PARAMETER"
>str</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        返回反转的字符串。
       </TD
><TD
><TT
CLASS="LITERAL"
>reverse('abcde')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>edcba</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>right(<TT
CLASS="PARAMETER"
>str</TT
> <TT
CLASS="TYPE"
>text</TT
>,
         <TT
CLASS="PARAMETER"
>n</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        返回字符串中的最后<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>个字符。如果<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>为负，返回除最前面的|<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>|个字符外的所有字符。
       </TD
><TD
><TT
CLASS="LITERAL"
>right('abcde', 2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>de</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>rpad(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>length</TT
> <TT
CLASS="TYPE"
>int</TT
>
        [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>fill</TT
> <TT
CLASS="TYPE"
>text</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        将<TT
CLASS="PARAMETER"
>string</TT
>通过增加字符<TT
CLASS="PARAMETER"
>fill</TT
>（默认为一个空格）填充到长度<TT
CLASS="PARAMETER"
>length</TT
>。如果<TT
CLASS="PARAMETER"
>string</TT
>已经长于<TT
CLASS="PARAMETER"
>length</TT
>则它会被截断。
       </TD
><TD
><TT
CLASS="LITERAL"
>rpad('hi', 5, 'xy')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>hixyx</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>rtrim(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>
         [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>characters</TT
> <TT
CLASS="TYPE"
>text</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        从<TT
CLASS="PARAMETER"
>string</TT
>的结尾删除最长的只包含<TT
CLASS="PARAMETER"
>characters</TT
>（默认是一个空格）的串
       </TD
><TD
><TT
CLASS="LITERAL"
>rtrim('trimxxxx', 'x')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>trim</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>split_part(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>delimiter</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>field</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>按<TT
CLASS="PARAMETER"
>delimiter</TT
>划分<TT
CLASS="PARAMETER"
>string</TT
>并返回给定域（从1开始计算）
       </TD
><TD
><TT
CLASS="LITERAL"
>split_part('abc~@~def~@~ghi', '~@~', 2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>def</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>strpos(<TT
CLASS="PARAMETER"
>string</TT
>, <TT
CLASS="PARAMETER"
>substring</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>        指定子串的位置（和<TT
CLASS="LITERAL"
>position(<TT
CLASS="PARAMETER"
>substring</TT
> in
         <TT
CLASS="PARAMETER"
>string</TT
>)</TT
>相同，但是注意相反的参数顺序）
       </TD
><TD
><TT
CLASS="LITERAL"
>strpos('high', 'ig')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>substr(<TT
CLASS="PARAMETER"
>string</TT
>, <TT
CLASS="PARAMETER"
>from</TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>count</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        提取子串（与<TT
CLASS="LITERAL"
>substring(<TT
CLASS="PARAMETER"
>string</TT
> from <TT
CLASS="PARAMETER"
>from</TT
> for <TT
CLASS="PARAMETER"
>count</TT
>)</TT
>相同）
       </TD
><TD
><TT
CLASS="LITERAL"
>substr('alphabet', 3, 2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ph</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_ascii(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>
        [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>encoding</TT
> <TT
CLASS="TYPE"
>text</TT
></SPAN
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>       将<TT
CLASS="PARAMETER"
>string</TT
>从另一个编码转换到<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>（只支持从<TT
CLASS="LITERAL"
>LATIN1</TT
>、<TT
CLASS="LITERAL"
>LATIN2</TT
>、<TT
CLASS="LITERAL"
>LATIN9</TT
>和<TT
CLASS="LITERAL"
>WIN1250</TT
>编码的转换）
       </TD
><TD
><TT
CLASS="LITERAL"
>to_ascii('Karel')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Karel</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>to_hex(<TT
CLASS="PARAMETER"
>number</TT
> <TT
CLASS="TYPE"
>int</TT
>
        or <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>将<TT
CLASS="PARAMETER"
>number</TT
>转换到它等效的十六进制表示
       </TD
><TD
><TT
CLASS="LITERAL"
>to_hex(2147483647)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>7fffffff</TT
></TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>translate(<TT
CLASS="PARAMETER"
>string</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>from</TT
> <TT
CLASS="TYPE"
>text</TT
>,
        <TT
CLASS="PARAMETER"
>to</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        <TT
CLASS="PARAMETER"
>string</TT
>中任何匹配<TT
CLASS="PARAMETER"
>from</TT
>集合中一个字符的字符会被替换成<TT
CLASS="PARAMETER"
>to</TT
>集合中的相应字符。如果<TT
CLASS="PARAMETER"
>from</TT
>比<TT
CLASS="PARAMETER"
>to</TT
>长，<TT
CLASS="PARAMETER"
>from</TT
>中的额外字符会被删除。
       </TD
><TD
><TT
CLASS="LITERAL"
>translate('12345', '143', 'ax')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>a2x5</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>    <CODE
CLASS="FUNCTION"
>concat</CODE
>、<CODE
CLASS="FUNCTION"
>concat_ws</CODE
>和<CODE
CLASS="FUNCTION"
>format</CODE
>函数是可变的，因此可以把要串接或格式化的值作为一个标记了<TT
CLASS="LITERAL"
>VARIADIC</TT
>关键字的数组进行传递（见<A
HREF="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS"
>第 36.4.5 &#33410;</A
>）。数组的元素被当作函数的独立普通参数一样处理。如果可变数组参数为 NULL，<CODE
CLASS="FUNCTION"
>concat</CODE
>和<CODE
CLASS="FUNCTION"
>concat_ws</CODE
>返回 NULL，但<CODE
CLASS="FUNCTION"
>format</CODE
>把 NULL 当作一个零元素数组。
   </P
><P
>   还可以参阅<A
HREF="functions-aggregate.html"
>第 9.20 &#33410;</A
>中的<CODE
CLASS="FUNCTION"
>string_agg</CODE
>。
   </P
><DIV
CLASS="TABLE"
><A
NAME="CONVERSION-NAMES"
></A
><P
><B
>&#34920; 9-10. 内建转换</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>转换名
        <A
NAME="AEN10936"
HREF="#FTN.AEN10936"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
       </TH
><TH
>源编码</TH
><TH
>目标编码</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>ascii_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SQL_ASCII</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ascii_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SQL_ASCII</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>big5_to_euc_tw</TT
></TD
><TD
><TT
CLASS="LITERAL"
>BIG5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_TW</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>big5_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>BIG5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>big5_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>BIG5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_cn_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_CN</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_cn_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_CN</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_jp_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JP</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_jp_to_sjis</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JP</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SJIS</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_jp_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JP</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_kr_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_KR</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_kr_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_KR</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_tw_to_big5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_TW</TT
></TD
><TD
><TT
CLASS="LITERAL"
>BIG5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_tw_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_TW</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_tw_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_TW</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>gb18030_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>GB18030</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>gbk_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>GBK</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_10_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN6</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_13_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN7</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_14_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_15_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN9</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_16_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN10</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_1_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN1</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_1_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN1</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_2_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_2_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_2_to_windows_1250</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1250</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_3_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN3</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_3_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN3</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_4_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN4</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_4_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN4</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_5_to_koi8_r</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_5_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_5_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_5_to_windows_1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_5_to_windows_866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_6_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_6</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_7_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_7</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_8_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8859_9_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>johab_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>JOHAB</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>koi8_r_to_iso_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>koi8_r_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>koi8_r_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>koi8_r_to_windows_1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>koi8_r_to_windows_866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>koi8_u_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8U</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_ascii</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SQL_ASCII</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_big5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>BIG5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_euc_cn</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_CN</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_euc_jp</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JP</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_euc_kr</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_KR</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_euc_tw</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_TW</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_iso_8859_1</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN1</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_iso_8859_2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN2</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_iso_8859_3</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_iso_8859_4</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN4</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_iso_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_koi8_r</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_sjis</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SJIS</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_windows_1250</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1250</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_windows_1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mic_to_windows_866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>sjis_to_euc_jp</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SJIS</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JP</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>sjis_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SJIS</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>sjis_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SJIS</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>tcvn_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1258</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>uhc_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UHC</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_ascii</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SQL_ASCII</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_big5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>BIG5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_euc_cn</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_CN</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_euc_jp</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JP</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_euc_kr</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_KR</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_euc_tw</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_TW</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_gb18030</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>GB18030</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_gbk</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>GBK</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_1</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN1</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_10</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN6</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_13</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN7</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_14</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_15</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN9</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_16</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN10</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN2</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_3</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_4</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN4</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_6</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_6</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_7</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_7</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_iso_8859_9</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_johab</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>JOHAB</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_koi8_r</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_koi8_u</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8U</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_sjis</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SJIS</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_tcvn</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1258</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_uhc</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UHC</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1250</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1250</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1252</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1252</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1253</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1253</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1254</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1254</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1255</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1255</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1256</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1256</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_1257</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1257</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_windows_874</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN874</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1250_to_iso_8859_2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1250</TT
></TD
><TD
><TT
CLASS="LITERAL"
>LATIN2</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1250_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1250</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1250_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1250</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1251_to_iso_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1251_to_koi8_r</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1251_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1251_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1251_to_windows_866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1252_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1252</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_1256_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN1256</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_866_to_iso_8859_5</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO_8859_5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_866_to_koi8_r</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>KOI8R</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_866_to_mic</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MULE_INTERNAL</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_866_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_866_to_windows_1251</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN866</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>windows_874_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>WIN874</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_jis_2004_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JIS_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_euc_jis_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JIS_2004</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>shift_jis_2004_to_utf8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SHIFT_JIS_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>utf8_to_shift_jis_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>UTF8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SHIFT_JIS_2004</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>euc_jis_2004_to_shift_jis_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JIS_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SHIFT_JIS_2004</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>shift_jis_2004_to_euc_jis_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>SHIFT_JIS_2004</TT
></TD
><TD
><TT
CLASS="LITERAL"
>EUC_JIS_2004</TT
></TD
></TR
></TBODY
><TR
><TD
COLSPAN="3"
>&#34920;&#27880;:<BR><A
NAME="FTN.AEN10936"
>a. </A
>          转换名遵循一种标准命名模式：将全部非字母数字字符替换为下划线的源编码的官方名称，后面跟上<TT
CLASS="LITERAL"
>_to_</TT
>，最后是按照相似方式处理过的目标编码名称。因此，名称可能会不同于习惯的编码名称。
         <BR></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-STRING-FORMAT"
>9.4.1. <CODE
CLASS="FUNCTION"
>format</CODE
></A
></H2
><P
>     函数<CODE
CLASS="FUNCTION"
>format</CODE
>根据一个格式字符串产生格式化的输出，其形式类似于 C 函数<CODE
CLASS="FUNCTION"
>sprintf</CODE
>。
    </P
><P
></P><PRE
CLASS="SYNOPSIS"
><CODE
CLASS="FUNCTION"
>format</CODE
>(<TT
CLASS="PARAMETER"
>formatstr</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>formatarg</TT
> <TT
CLASS="TYPE"
>"any"</TT
> [, ...] ])</PRE
><P>
     <TT
CLASS="REPLACEABLE"
><I
>formatstr</I
></TT
>是一个格式字符串，它指定了结果应该如何被格式化。格式字符串中的文本被直接复制到结果中，除了使用<I
CLASS="FIRSTTERM"
>格式说明符</I
>的地方。格式说明符在字符串中扮演着占位符的角色，它定义后续的函数参数如何被格式化及插入到结果中。每一个<TT
CLASS="REPLACEABLE"
><I
>formatarg</I
></TT
>参数会被根据其数据类型的常规输出规则转换为文本，并接着根据格式说明符被格式化和插入到结果字符串中。
    </P
><P
>     格式说明符由一个<TT
CLASS="LITERAL"
>%</TT
>字符开始并且有这样的形式
</P><PRE
CLASS="SYNOPSIS"
>%[<TT
CLASS="REPLACEABLE"
><I
>position</I
></TT
>][<TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
>][<TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
>]<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
></PRE
><P>
     其中的各组件域是：

     <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>position</I
></TT
>（可选）</DT
><DD
><P
>         一个形式为<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>$</TT
>的字符串，其中<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>是要打印的参数的索引。索引 1 表示<TT
CLASS="REPLACEABLE"
><I
>formatstr</I
></TT
>之后的第一个参数。如果<TT
CLASS="REPLACEABLE"
><I
>position</I
></TT
>被忽略，默认会使用序列中的下一个参数。
        </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
>（可选）</DT
><DD
><P
>         控制格式说明符的输出如何被格式化的附加选项。当前唯一支持的标志是一个负号（<TT
CLASS="LITERAL"
>-</TT
>），它将导致格式说明符的输出会被左对齐（left-justified）。除非<TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
>域也被指定，否者这个域不会产生任何效果。
        </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
>（可选）</DT
><DD
><P
>         指定用于显示格式说明符输出的<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>最小</I
></SPAN
>字符数。输出将被在左部或右部（取决于<TT
CLASS="LITERAL"
>-</TT
>标志）用空格填充以保证充满该宽度。太小的宽度设置不会导致输出被截断，但是会被简单地忽略。宽度可以使用下列形式之一指定：一个正整数；一个星号（<TT
CLASS="LITERAL"
>*</TT
>）表示使用下一个函数参数作为宽度；或者一个形式为<TT
CLASS="LITERAL"
>*<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>$</TT
>的字符串表示使用第<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>个函数参数作为宽度。
        </P
><P
>         如果宽度来自于一个函数参数，则参数在被格式说明符的值使用之前就被消耗掉了。如果宽度参数是负值，结果会在长度为<CODE
CLASS="FUNCTION"
>abs</CODE
>(<TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
>)的域中被左对齐（如果<TT
CLASS="LITERAL"
>-</TT
>标志被指定）。
        </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>（必需）</DT
><DD
><P
>         格式转换的类型，用于产生格式说明符的输出。支持下面的类型：
         <P
></P
></P><UL
><LI
><P
>            <TT
CLASS="LITERAL"
>s</TT
>将参数值格式化为一个简单字符串。一个控制被视为一个空字符串。
           </P
></LI
><LI
><P
>            <TT
CLASS="LITERAL"
>I</TT
>将参数值视作 SQL 标识符，并在必要时用双写引号包围它。如果参数为空，将会是一个错误（等同于<CODE
CLASS="FUNCTION"
>quote_ident</CODE
>）。
           </P
></LI
><LI
><P
>            <TT
CLASS="LITERAL"
>L</TT
>将参数值引用为 SQL 文字。一个空值将被显示为不带引号的字符串<TT
CLASS="LITERAL"
>NULL</TT
>（等同于<CODE
CLASS="FUNCTION"
>quote_nullable</CODE
>）。
           </P
></LI
></UL
><P>
        </P
></DD
></DL
></DIV
><P>
    </P
><P
>     除了以上所述的格式说明符之外，要输出一个文字形式的<TT
CLASS="LITERAL"
>%</TT
>字符，可以使用特殊序列<TT
CLASS="LITERAL"
>%%</TT
>。
    </P
><P
>     下面有一些基本的格式转换的例子：

</P><PRE
CLASS="SCREEN"
>SELECT format('Hello %s', 'World');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>Hello World</SAMP
>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>Testing one, two, three, %</SAMP
>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>INSERT INTO "Foo bar" VALUES('O''Reilly')</SAMP
>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\Program Files');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>INSERT INTO locations VALUES(E'C:\\Program Files')</SAMP
></PRE
><P>
    </P
><P
>     下面是使用<TT
CLASS="REPLACEABLE"
><I
>width</I
></TT
>域和<TT
CLASS="LITERAL"
>-</TT
>标志的例子：

</P><PRE
CLASS="SCREEN"
>SELECT format('|%10s|', 'foo');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|       foo|</SAMP
>

SELECT format('|%-10s|', 'foo');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|foo       |</SAMP
>

SELECT format('|%*s|', 10, 'foo');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|       foo|</SAMP
>

SELECT format('|%*s|', -10, 'foo');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|foo       |</SAMP
>

SELECT format('|%-*s|', 10, 'foo');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|foo       |</SAMP
>

SELECT format('|%-*s|', -10, 'foo');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|foo       |</SAMP
></PRE
><P>
    </P
><P
>     这些例子展示了<TT
CLASS="REPLACEABLE"
><I
>position</I
></TT
>域的例子：

</P><PRE
CLASS="SCREEN"
>SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>Testing three, two, one</SAMP
>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|       bar|</SAMP
>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>|       foo|</SAMP
></PRE
><P>
    </P
><P
>     不同于标准的 C 函数<CODE
CLASS="FUNCTION"
>sprintf</CODE
>，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的<CODE
CLASS="FUNCTION"
>format</CODE
>函数允许将带有或者不带有<TT
CLASS="REPLACEABLE"
><I
>position</I
></TT
>域的格式说明符被混在同一个格式字符串中。一个不带有<TT
CLASS="REPLACEABLE"
><I
>position</I
></TT
>域的格式说明符总是使用最后一个被消耗的参数的下一个参数。另外，<CODE
CLASS="FUNCTION"
>format</CODE
>函数不要求所有函数参数都被用在格式字符串中。例如：

</P><PRE
CLASS="SCREEN"
>SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<I
CLASS="LINEANNOTATION"
>结果：</I
><SAMP
CLASS="COMPUTEROUTPUT"
>Testing three, two, three</SAMP
></PRE
><P>
    </P
><P
>     对于安全地构造动态 SQL 语句，<TT
CLASS="LITERAL"
>%I</TT
>和<TT
CLASS="LITERAL"
>%L</TT
>格式说明符特别有用。参见<A
HREF="plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE"
>&#20363; 41-1</A
>。
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-math.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-binarystring.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>数学函数和操作符</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>二进制串函数和操作符</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
