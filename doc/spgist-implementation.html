<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>实现</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="SP-GiST索引"
HREF="spgist.html"><LINK
REL="PREVIOUS"
TITLE="可扩展性"
HREF="spgist-extensibility.html"><LINK
REL="NEXT"
TITLE="例子"
HREF="spgist-examples.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/spgist.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="可扩展性"
HREF="spgist-extensibility.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="spgist.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 62. SP-GiST索引</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="例子"
HREF="spgist-examples.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SPGIST-IMPLEMENTATION"
>62.4. 实现</A
></H1
><P
>   这一节覆盖了实现细节以及<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>操作符类的实现者需要知道的有用的技巧。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPGIST-LIMITS"
>62.4.1. SP-GiST 限制</A
></H2
><P
>   单独的叶子节点和内部节点必须能适合一个单一的索引页面（默认为 8kB）。因此，当索引值是一种变长数据类型时（长值只能由如 radix 树的方法所支持），树的每一层包含的前缀都足够短以适合一个页面，并且最终的叶子层包括的后缀也足够短以适合一个页面。如果操作符类准备好做这种事情，它应该将<TT
CLASS="STRUCTFIELD"
>longValuesOK</TT
>设置为 TRUE。否则，<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>核心将拒绝任何要索引超过一个所以页面长度的值的请求。
  </P
><P
>   同样，操作符类应该负责不要让内部元组增长到无法放在一个索引页面中。这限制了能在一个内部元组中使用的子节点的数目，以及一个前缀值的最大尺寸。
  </P
><P
>   另一个限制是，当一个内部元组的节点指向一组叶子元组时，这些元组必须都在同一个索引页面中（这种设计是为了减少在这类元组构成链中进行定位的时间并且节省空间）。如果叶子元组集合增长到无法放在一个页面中，将执行一次分裂并且插入一个中间的内部元组。为此，新的内部元组<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>必须</I
></SPAN
>把叶子值的集合划分成多于一个节点分组。如果操作符类的<CODE
CLASS="FUNCTION"
>picksplit</CODE
>函数无法做到这一点，<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>核心只能求助于<A
HREF="spgist-implementation.html#SPGIST-ALL-THE-SAME"
>第 62.4.3 &#33410;</A
>中所介绍的额外措施。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPGIST-NULL-LABELS"
>62.4.2. 无节点标签的 SP-GiST</A
></H2
><P
>   某些树算法对每个内部元组都使用一种固定的节点集合。例如，在一个四叉树中总是正好有四个节点对应于围绕内部节点中心点的四个象限。在这种情况下，代码总是通过编号来处理节点，而不需要显式的节点标签。为了压缩节点标签（并且因此节省一些空间），<CODE
CLASS="FUNCTION"
>picksplit</CODE
>函数可以为<TT
CLASS="STRUCTFIELD"
>nodeLabels</TT
>数组返回 NULL。这将会导致后续对<CODE
CLASS="FUNCTION"
>choose</CODE
>和<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>调用时<TT
CLASS="STRUCTFIELD"
>nodeLabels</TT
>也为 NULL。原则上，可以为同一个索引中的某些内部元组使用节点标签而对其他内部节点省略节点标签。
  </P
><P
>   在处理具有无标签节点的内部元组时，让<CODE
CLASS="FUNCTION"
>choose</CODE
>返回<TT
CLASS="LITERAL"
>spgAddNode</TT
>是一种错误，因为该节点集合在这种情况下被假定为固定的集合。还有，没有规定要在<TT
CLASS="LITERAL"
>spgSplitTuple</TT
>动作中生成一个无标签节点，因为那样也将需要一个<TT
CLASS="LITERAL"
>spgAddNode</TT
>动作。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPGIST-ALL-THE-SAME"
>62.4.3. <SPAN
CLASS="QUOTE"
>"All-the-same"</SPAN
>内部元组</A
></H2
><P
>   当<CODE
CLASS="FUNCTION"
>picksplit</CODE
>无法把提供的叶子值划分成至少两个节点分类，<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>核心能推翻操作符类的<CODE
CLASS="FUNCTION"
>picksplit</CODE
>函数的结果。在发生这种情况时，会创建一个新的内部元组，其中有多个节点，每一个节点都有相同的标签（如果有标签），标签是由<CODE
CLASS="FUNCTION"
>picksplit</CODE
>之前给一个节点用的，并且叶子值会被随机地划分给这些等效的节点中。该内部元组上会设置<TT
CLASS="LITERAL"
>allTheSame</TT
>标志以警告<CODE
CLASS="FUNCTION"
>choose</CODE
>和<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>函数该元组不具有它们所期望的节点集合。
  </P
><P
>   在处理<TT
CLASS="LITERAL"
>allTheSame</TT
>元组时，<CODE
CLASS="FUNCTION"
>choose</CODE
>函数的结果<TT
CLASS="LITERAL"
>spgMatchNode</TT
>会被解释为新值可以被赋值给任一等价的节点。核心代码将忽略提供的<TT
CLASS="STRUCTFIELD"
>nodeN</TT
>值并且随机地下降到其中一个节点中（以便保持树平衡）。对<CODE
CLASS="FUNCTION"
>choose</CODE
>来说，返回<TT
CLASS="LITERAL"
>spgAddNode</TT
>是一种错误，因为那会让节点不全部等效。如果要被插入的值不匹配现有的节点，则必须使用<TT
CLASS="LITERAL"
>spgSplitTuple</TT
>动作。
  </P
><P
>   在处理<TT
CLASS="LITERAL"
>allTheSame</TT
>元组时，为了继续索引搜索，<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>函数应该返回全部节点或者不返回节点作为目标，因为这些节点都是等效的。根据<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>函数对这些节点含义的假定程度，这可能会也可能不会要求任何处理特殊情况的代码。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="spgist-extensibility.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="spgist-examples.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>可扩展性</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="spgist.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>例子</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
