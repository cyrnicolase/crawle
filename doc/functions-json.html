<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>JSON 函数和操作符</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="函数和操作符"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="XML 函数"
HREF="functions-xml.html"><LINK
REL="NEXT"
TITLE="序列操作函数"
HREF="functions-sequence.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/func.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="XML 函数"
HREF="functions-xml.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 9. 函数和操作符</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="序列操作函数"
HREF="functions-sequence.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-JSON"
>9.15. JSON 函数和操作符</A
></H1
><P
>   <A
HREF="functions-json.html#FUNCTIONS-JSON-OP-TABLE"
>&#34920; 9-42</A
>展示了可以用于两种 JSON 
   数据类型（见<A
HREF="datatype-json.html"
>第 8.14 &#33410;</A
>）的操作符。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSON-OP-TABLE"
></A
><P
><B
>&#34920; 9-42. <TT
CLASS="TYPE"
>json</TT
>和<TT
CLASS="TYPE"
>jsonb</TT
> 操作符</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>操作符</TH
><TH
>右操作数类型</TH
><TH
>描述</TH
><TH
>例子</TH
><TH
>例子结果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>获得 JSON 数组元素（索引从 0 开始，负整数结束）</TD
><TD
><TT
CLASS="LITERAL"
>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"c":"baz"}</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>通过键获得 JSON 对象域</TD
><TD
><TT
CLASS="LITERAL"
>'{"a": {"b":"foo"}}'::json-&gt;'a'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"b":"foo"}</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>以<TT
CLASS="TYPE"
>文本</TT
>形式获得 JSON 数组元素</TD
><TD
><TT
CLASS="LITERAL"
>'[1,2,3]'::json-&gt;&gt;2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>以<TT
CLASS="TYPE"
>文本</TT
>形式获得 JSON 对象域</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1,"b":2}'::json-&gt;&gt;'b'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>#&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>获取在指定路径的 JSON 对象</TD
><TD
><TT
CLASS="LITERAL"
>'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"c": "foo"}</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>#&gt;&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>以<TT
CLASS="TYPE"
>文本</TT
>形式获取在指定路径的 JSON 对象</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    对<TT
CLASS="TYPE"
>json</TT
>和<TT
CLASS="TYPE"
>jsonb</TT
>类型，这些操作符都有其并行变体。
    域/元素/路径抽取操作符返回与其左手输入（<TT
CLASS="TYPE"
>json</TT
>或<TT
CLASS="TYPE"
>jsonb</TT
>）
    相同的类型，不过那些被指定为返回<TT
CLASS="TYPE"
>text</TT
>的除外，它们的返回值会被强制
    为文本。如果该 JSON 输入没有匹配请求的正确结构（例如那样的元素不存在），这些域/元素/路径抽取操作符会返回 NULL 而不是失败。
    接受整数JSON数组下标的域/元素/路径提取操作符支持数组末尾的负下标。
   </P
></BLOCKQUOTE
></DIV
><P
>   <A
HREF="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE"
>&#34920; 9-1</A
>中展示的标准比较操作符只对
   <TT
CLASS="TYPE"
>jsonb</TT
>有效，而不适合<TT
CLASS="TYPE"
>json</TT
>。它们遵循在<A
HREF="datatype-json.html#JSON-INDEXING"
>第 8.14.4 &#33410;</A
>中给出的 B 树操作规则。
  </P
><P
>   如<A
HREF="functions-json.html#FUNCTIONS-JSONB-OP-TABLE"
>&#34920; 9-43</A
>中所示，还存在一些只适合
   <TT
CLASS="TYPE"
>jsonb</TT
>的操作符。这些操作符中的很多可以用<TT
CLASS="TYPE"
>jsonb</TT
>
   操作符类索引。<TT
CLASS="TYPE"
>jsonb</TT
>包含和存在语义的完整描述可参见<A
HREF="datatype-json.html#JSON-CONTAINMENT"
>第 8.14.3 &#33410;</A
>。<A
HREF="datatype-json.html#JSON-INDEXING"
>第 8.14.4 &#33410;</A
>描述了如何
   用这些操作符来有效地索引<TT
CLASS="TYPE"
>jsonb</TT
>数据。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSONB-OP-TABLE"
></A
><P
><B
>&#34920; 9-43. 额外的<TT
CLASS="TYPE"
>jsonb</TT
>操作符</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>操作符</TH
><TH
>右操作数类型</TH
><TH
>描述</TH
><TH
>例子</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>@&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>jsonb</TT
></TD
><TD
>左边的 JSON 值是否包含顶层右边JSON路径/值项?</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>&lt;@</TT
></TD
><TD
><TT
CLASS="TYPE"
>jsonb</TT
></TD
><TD
>左边的JSON路径/值是否包含在顶层右边JSON值中？</TD
><TD
><TT
CLASS="LITERAL"
>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>?</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>字符串</I
></SPAN
>是否作为顶层键值存在于JSON值中？</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1, "b":2}'::jsonb ? 'b'</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>?|</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>这些数组<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>字符串</I
></SPAN
>中的任何一个是否作为顶层键值存在？</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>?&amp;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>这些数组<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>字符串</I
></SPAN
>是否作为顶层键值存在？</TD
><TD
><TT
CLASS="LITERAL"
>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>||</TT
></TD
><TD
><TT
CLASS="TYPE"
>jsonb</TT
></TD
><TD
>连接两个<TT
CLASS="TYPE"
>jsonb</TT
>值到新的<TT
CLASS="TYPE"
>jsonb</TT
>值</TD
><TD
><TT
CLASS="LITERAL"
>'["a", "b"]'::jsonb || '["c", "d"]'::jsonb</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>从左操作数中删除键/值对或<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>字符串</I
></SPAN
>元素。基于键值匹配键/值对。</TD
><TD
><TT
CLASS="LITERAL"
>'{"a": "b"}'::jsonb - 'a' </TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>删除指定索引的数组元素（负整数结尾）。如果顶层容器不是一个数组，那么抛出错误。</TD
><TD
><TT
CLASS="LITERAL"
>'["a", "b"]'::jsonb - 1 </TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>#-</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>删除指定路径的域或元素（JSON数组，负整数结尾）</TD
><TD
><TT
CLASS="LITERAL"
>'["a", {"b":1}]'::jsonb #- '{1,b}'</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    <TT
CLASS="LITERAL"
>||</TT
>操作符连接每个操作数顶层的元素。
    它不递归操作。比如，如果两个操作数都是具有共同键字段名称的对象，
    则结果中字段值只会是从右边操作数的值。
   </P
></BLOCKQUOTE
></DIV
><P
>   <A
HREF="functions-json.html#FUNCTIONS-JSON-CREATION-TABLE"
>&#34920; 9-44</A
>展示了能用来创建
   <TT
CLASS="TYPE"
>json</TT
>和<TT
CLASS="TYPE"
>jsonb</TT
>值的函数
   （当前，没有用于<TT
CLASS="TYPE"
>jsonb</TT
>，
   <TT
CLASS="LITERAL"
>row_to_json</TT
>以及<TT
CLASS="LITERAL"
>array_to_json</TT
>的等效函数，
   然而，<TT
CLASS="LITERAL"
>to_jsonb</TT
>函数提供了许多诸如这些函数的相同功能）。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSON-CREATION-TABLE"
></A
><P
><B
>&#34920; 9-44. JSON 创建函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>函数</TH
><TH
>描述</TH
><TH
>例子</TH
><TH
>例子结果</TH
></TR
></THEAD
><TBODY
><TR
><TD
>         <P
><TT
CLASS="LITERAL"
>to_json(anyelement)</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>to_jsonb(anyelement)</TT
>
       </P
></TD
><TD
>         把值返回为<TT
CLASS="TYPE"
>json</TT
>或者<TT
CLASS="TYPE"
>jsonb</TT
>。数组和组合被（递归地）转换成数组和对象；否则，
         如果有从该类型到<TT
CLASS="TYPE"
>json</TT
>的投影，将使用该投影函数来执行转换；
         否则将产生一个标量值。对任何一个数值、布尔量或空值的标量类型，
         将使用其文本表达，以这样一种方式使其成为有效的<TT
CLASS="TYPE"
>json</TT
>或者<TT
CLASS="TYPE"
>jsonb</TT
>值。
       </TD
><TD
><TT
CLASS="LITERAL"
>to_json('Fred said "Hi."'::text)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>"Fred said \"Hi.\""</TT
></TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
>array_to_json(anyarray [, pretty_bool])</TT
>
       </TD
><TD
>         把数组作为一个 JSON 数组返回。一个 PostgreSQL 多维数组会成为一个数组
         的 JSON 数组。如果<TT
CLASS="PARAMETER"
>pretty_bool</TT
>为真，将在
         第 1 维度的元素之间增加换行。
       </TD
><TD
><TT
CLASS="LITERAL"
>array_to_json('{{1,5},{99,100}}'::int[])</TT
></TD
><TD
><TT
CLASS="LITERAL"
>[[1,5],[99,100]]</TT
></TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
>row_to_json(record [, pretty_bool])</TT
>
       </TD
><TD
>         把行作为一个 JSON 对象返回。如果<TT
CLASS="PARAMETER"
>pretty_bool</TT
>为真，将在第1层元素之间增加换行。
       </TD
><TD
><TT
CLASS="LITERAL"
>row_to_json(row(1,'foo'))</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"f1":1,"f2":"foo"}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_build_array(VARIADIC "any")</TT
>
       </P
><P
><TT
CLASS="LITERAL"
>jsonb_build_array(VARIADIC "any")</TT
>
       </P
></TD
><TD
>         从一个可变参数列表构造一个可能包含异质类型的 JSON 数组。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_build_array(1,2,'3',4,5)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>[1, 2, "3", 4, 5]</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_build_object(VARIADIC "any")</TT
>
       </P
><P
><TT
CLASS="LITERAL"
>jsonb_build_object(VARIADIC "any")</TT
>
       </P
>
       </TD
><TD
>         从一个可变参数列表构造一个 JSON 对象。通过转换，该参数列表由交替
         出现的键和值构成。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_build_object('foo',1,'bar',2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"foo": 1, "bar": 2}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_object(text[])</TT
>
       </P
><P
><TT
CLASS="LITERAL"
>jsonb_object(text[])</TT
>
       </P
></TD
><TD
>         从一个文本数组构造一个 JSON 对象。该数组必须可以是具有偶数个成员的
         一维数组（成员被当做交替出现的键/值对），或者是一个二维数组（每一个
         内部数组刚好有 2 个元素，可以被看做是键/值对）。
       </TD
><TD
><P
><TT
CLASS="LITERAL"
>json_object('{a, 1, b, "def", c, 3.5}')</TT
></P
>
        <P
><TT
CLASS="LITERAL"
>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</TT
></P
></TD
><TD
><TT
CLASS="LITERAL"
>{"a": "1", "b": "def", "c": "3.5"}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_object(keys text[], values text[])</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>jsonb_object(keys text[], values text[])</TT
>
       </P
></TD
><TD
>         <CODE
CLASS="FUNCTION"
>json_object</CODE
>的这种形式从两个独立的数组得到键/值对。在其
         他方面和一个参数的形式相同。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_object('{a, b}', '{1,2}')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"a": "1", "b": "2"}</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>     <CODE
CLASS="FUNCTION"
>array_to_json</CODE
>和<CODE
CLASS="FUNCTION"
>row_to_json</CODE
>与<CODE
CLASS="FUNCTION"
>to_json</CODE
>
     具有相同的行为，不过它们提供了更好的打印选项。针对<CODE
CLASS="FUNCTION"
>to_json</CODE
>所描述
     的行为同样也适用于由其他 JSON 创建函数转换的每个值。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>     <A
HREF="hstore.html"
>hstore</A
>扩展有一个从<TT
CLASS="TYPE"
>hstore</TT
>到<TT
CLASS="TYPE"
>json</TT
>
     的造型，因此通过 JSON 创建函数转换的<TT
CLASS="TYPE"
>hstore</TT
>值将被表示为 JSON
     对象，而不是原始字符串值。
    </P
></BLOCKQUOTE
></DIV
><P
>   <A
HREF="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE"
>&#34920; 9-45</A
>展示了可用来处理<TT
CLASS="TYPE"
>json</TT
>
   和<TT
CLASS="TYPE"
>jsonb</TT
>值的函数。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSON-PROCESSING-TABLE"
></A
><P
><B
>&#34920; 9-45. JSON 处理函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>函数</TH
><TH
>返回值</TH
><TH
>描述</TH
><TH
>例子</TH
><TH
>例子结果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_array_length(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_array_length(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>         返回最外层 JSON 数组中的元素数量。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>5</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_each(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_each(jsonb)</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="LITERAL"
>setof key text, value json</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>setof key text, value jsonb</TT
>
       </P
></TD
><TD
>         扩展最外层的 JSON 对象成为一组键/值对。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_each('{"a":"foo", "b":"bar"}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> key | value
-----+-------
 a   | "foo"
 b   | "bar"
 </PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_each_text(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_each_text(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof key text, value text</TT
></TD
><TD
>         扩展最外层的 JSON 对象成为一组键/值对。返回值将是<TT
CLASS="TYPE"
>文本</TT
>类型。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_each_text('{"a":"foo", "b":"bar"}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> key | value
-----+-------
 a   | foo
 b   | bar
 </PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_extract_path(from_json json, VARIADIC path_elems text[])</TT
>
        </P
><P
><TT
CLASS="LITERAL"
>jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>json</TT
></P
><P
><TT
CLASS="TYPE"
>jsonb</TT
>
       </P
></TD
><TD
>         返回由<TT
CLASS="REPLACEABLE"
><I
>path_elems</I
></TT
>指向的 JSON 值（等效于<TT
CLASS="LITERAL"
>#&gt;</TT
>操作符）。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"f5":99,"f6":"foo"}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_extract_path_text(from_json json, VARIADIC path_elems text[])</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>         以<TT
CLASS="TYPE"
>文本</TT
>返回由<TT
CLASS="PARAMETER"
>path_elems</TT
>指向的 JSON 值（等效于<TT
CLASS="LITERAL"
>#&gt;&gt;</TT
>操作符）。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>foo</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_object_keys(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_object_keys(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof text</TT
></TD
><TD
>          返回最外层 JSON 对象中的键集合。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> json_object_keys
------------------
 f1
 f2</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_populate_record(base anyelement, from_json json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_populate_record(base anyelement, from_json jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>anyelement</TT
></TD
><TD
>         扩展<TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>中的对象成一个行，它的列匹配由<TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
>定义的记录类型（见下文的注释）。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a | b
---+---
 1 | 2</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_populate_recordset(base anyelement, from_json json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_populate_recordset(base anyelement, from_json jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof anyelement</TT
></TD
><TD
>         扩展<TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>中最外的对象数组为一个集合，该集合的列匹配由<TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
>定义的记录类型。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a | b
---+---
 1 | 2
 3 | 4
 </PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_array_elements(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_array_elements(jsonb)</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>setof json</TT
>
         </P
><P
><TT
CLASS="TYPE"
>setof jsonb</TT
>
       </P
></TD
><TD
>         把一个 JSON 数组扩展成一个 JSON 值的集合。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_array_elements('[1,true, [2,false]]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
>   value
-----------
 1
 true
 [2,false]</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_array_elements_text(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_array_elements_text(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof text</TT
></TD
><TD
>         把一个 JSON 数组扩展成一个<TT
CLASS="TYPE"
>text</TT
>值集合。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_array_elements_text('["foo", "bar"]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
>   value
-----------
 foo
 bar</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_typeof(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_typeof(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>         把最外层的 JSON 值的类型作为一个文本字符串返回。可能的类型是：
         <TT
CLASS="LITERAL"
>object</TT
>、<TT
CLASS="LITERAL"
>array</TT
>、<TT
CLASS="LITERAL"
>string</TT
>、<TT
CLASS="LITERAL"
>number</TT
>、
         <TT
CLASS="LITERAL"
>boolean</TT
>以及<TT
CLASS="LITERAL"
>null</TT
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_typeof('-123.4')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>number</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_to_record(json)</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>jsonb_to_record(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>record</TT
></TD
><TD
>         从一个 JSON 对象（见下文的注解）构建一个任意的记录。正如所有返回<TT
CLASS="TYPE"
>record</TT
>
         的函数一样，调用者必须用一个<TT
CLASS="LITERAL"
>AS</TT
>子句显式地定义记录的结构。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text) </TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a |    b    | d
---+---------+---
 1 | [1,2,3] |</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_to_recordset(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_to_recordset(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof record</TT
></TD
><TD
>         从一个 JSON 对象数组（见下文的注解）构建一个任意的记录集合。正如所有返回<TT
CLASS="TYPE"
>record</TT
>
         的函数一样，调用者必须用一个<TT
CLASS="LITERAL"
>AS</TT
>子句显式地定义记录的结构。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a |  b
---+-----
 1 | foo
 2 |</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_strip_nulls(from_json json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_strip_nulls(from_json jsonb)</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>json</TT
></P
><P
><TT
CLASS="TYPE"
>jsonb</TT
></P
></TD
><TD
>         返回具有空值对象域的<TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>。其它空值不变。  
       </TD
><TD
><TT
CLASS="LITERAL"
>json_strip_nulls('[{"f1":1,"f2":null},2,null,3]')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>[{"f1":1},2,null,3]</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>jsonb_set(target jsonb, path text[], new_value jsonb[<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>create_missing</TT
> <TT
CLASS="TYPE"
>boolean</TT
></SPAN
>])</TT
>
         </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>jsonb</TT
></P
></TD
><TD
>         如果<TT
CLASS="REPLACEABLE"
><I
>create_missing</I
></TT
>是真的
         （缺省是<TT
CLASS="LITERAL"
>true</TT
>）并且通过<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>
         指定部分不存在，那么返回<TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>，
         它具有<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>指定部分，
         <TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
>替换部分，
         或者<TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
>添加部分。
         正如路径导向的操作符，负整数出现在JSON数组结尾的<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>&#62;计数中。
       </TD
><TD
><P
><TT
CLASS="LITERAL"
>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}','[2,3,4]')</TT
>
         </P
></TD
><TD
><P
><TT
CLASS="LITERAL"
>[{"f1":[2,3,4],"f2":null},2,null,3]</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</TT
>
        </P
></TD
></TR
><TR
><TD
>           <P
><TT
CLASS="LITERAL"
>           jsonb_insert(target jsonb, path text[], new_value jsonb, [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="PARAMETER"
>insert_after</TT
> <TT
CLASS="TYPE"
>boolean</TT
></SPAN
>])
           </TT
></P
>
       </TD
><TD
><P
><TT
CLASS="TYPE"
>jsonb</TT
></P
></TD
><TD
>         返回被插入了<TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
>的<TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>。
         如果<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>指定的<TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>
         节在一个 JSONB 数组中，<TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
> 将被插入到目标之前
         （<TT
CLASS="REPLACEABLE"
><I
>insert_after</I
></TT
>为<TT
CLASS="LITERAL"
>false</TT
>，默认情况）
         或者之后（<TT
CLASS="REPLACEABLE"
><I
>insert_after</I
></TT
>为真）。
         如果<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>指定的<TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>
         节在一个 JSONB 对象内，则只有当<TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>
         不存在时才插入<TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
>。对于面向路径的操作符来说，
         出现在<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>中的负整数表示从 JSON 数组的末尾开始计数。
       </TD
><TD
>           <P
><TT
CLASS="LITERAL"
>               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')
           </TT
></P
>
           <P
><TT
CLASS="LITERAL"
>               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)
           </TT
></P
>
       </TD
><TD
><P
><TT
CLASS="LITERAL"
>{"a": [0, "new_value", 1, 2]}</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>{"a": [0, 1, "new_value", 2]}</TT
>
        </P
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>jsonb_pretty(from_json jsonb)</TT
>
         </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>text</TT
></P
></TD
><TD
>         作为缩进JSON文本返回<TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>jsonb_pretty('[{"f1":1,"f2":null},2,null,3]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
>[
    {
        "f1": 1,
        "f2": null
    },
    2,
    null,
    3
]</PRE
>
        </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      很多这些函数和操作符将把 JSON 字符串中的 Unicode 转义转换成合适的单一字符。如果
      输入类型是<TT
CLASS="TYPE"
>jsonb</TT
>，这就没有问题，因为该转换已经完成了。但是对于<TT
CLASS="TYPE"
>json</TT
>
      输入，这可能会导致抛出一个错误（如<A
HREF="datatype-json.html"
>第 8.14 &#33410;</A
>所述）。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      在<CODE
CLASS="FUNCTION"
>json_populate_record</CODE
>、<CODE
CLASS="FUNCTION"
>json_populate_recordset</CODE
>、
      <CODE
CLASS="FUNCTION"
>json_to_record</CODE
>和<CODE
CLASS="FUNCTION"
>json_to_recordset</CODE
>中，来自 JSON 的
      类型强制是<SPAN
CLASS="QUOTE"
>"尽力而为"</SPAN
>并且对于某些类型可能得不到想要的值。JSON 键会被
      匹配目标行类型中相同的列名。没有出现在目标行类型中的 JSON 域将会被从输出中忽略，
      并且不匹配任何 JSON 域的目标列将被简单地作为 NULL。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      所有<TT
CLASS="LITERAL"
>jsonb_set</TT
>的<TT
CLASS="LITERAL"
>path</TT
>参数项必须存在于<TT
CLASS="LITERAL"
>target</TT
>中，
      除非<TT
CLASS="LITERAL"
>create_missing</TT
>是真的，在这种情况下，除了最后一项都存在。
      如果这些条件未满足<TT
CLASS="LITERAL"
>target</TT
>返回不变。
    </P
><P
>      如果最后路径项是对象键，如果它不存在并且给予新值，则被创建。
      如果最后路径项是一个数组索引，如果通过从左边计数发现设置项是正数，
      如果从右边- <TT
CLASS="LITERAL"
>-1</TT
>计数负数指定右边的元素，等等。
      如果项超出-array_length .. array_length -1范围，并且create_missing是真，
      如果项是负数，则在数组开头添加新值，如果是正数，则添加到数组末尾。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      不要把<TT
CLASS="LITERAL"
>json_typeof</TT
>函数的<TT
CLASS="LITERAL"
>null</TT
>返回值与 SQL 的 NULL 弄混。
      虽然调用<TT
CLASS="LITERAL"
>json_typeof('null'::json)</TT
>将会返回<TT
CLASS="LITERAL"
>null</TT
>，但调用
      <TT
CLASS="LITERAL"
>json_typeof(NULL::json)</TT
>将会返回一个 SQL 的 NULL。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      如果参数到<TT
CLASS="LITERAL"
>json_strip_nulls</TT
>包含任何对象的复制字段名，
      其结果可能是语义上不同，依赖于它们所产生的顺序。
      这不是<TT
CLASS="LITERAL"
>jsonb_strip_nulls</TT
>的问题，
      因为<TT
CLASS="TYPE"
>jsonb</TT
>值从不复制对象字段名。
    </P
></BLOCKQUOTE
></DIV
><P
>    也可参见<A
HREF="functions-aggregate.html"
>第 9.20 &#33410;</A
>了解聚集函数<CODE
CLASS="FUNCTION"
>json_agg</CODE
>，它可以把记录值聚集成 JSON。还有聚集函数<CODE
CLASS="FUNCTION"
>json_object_agg</CODE
>，它可以把值对
    聚集成一个 JSON 对象，以及<TT
CLASS="TYPE"
>jsonb</TT
>等价物，
    <CODE
CLASS="FUNCTION"
>jsonb_agg</CODE
>和<CODE
CLASS="FUNCTION"
>jsonb_object_agg</CODE
>。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-xml.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-sequence.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>XML 函数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>序列操作函数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
