<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>对象标识符类型</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="数据类型"
HREF="datatype.html"><LINK
REL="PREVIOUS"
TITLE="范围类型"
HREF="rangetypes.html"><LINK
REL="NEXT"
TITLE="pg_lsn Type"
HREF="datatype-pg-lsn.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/datatype.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="范围类型"
HREF="rangetypes.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 8. 数据类型</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="pg_lsn Type"
HREF="datatype-pg-lsn.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DATATYPE-OID"
>8.18. 对象标识符类型</A
></H1
><P
>    对象标识符（OID）被<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>用来在内部作为多个系统表的主键。OID不会被添加到用户创建的表中，除非在创建表时指定了<TT
CLASS="LITERAL"
>WITH OIDS</TT
>或者<A
HREF="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS"
>default_with_oids</A
>配置变量被启用。类型<TT
CLASS="TYPE"
>oid</TT
>表示一个对象标识符。也有多个<TT
CLASS="TYPE"
>oid</TT
>的别名类型：<TT
CLASS="TYPE"
>regproc</TT
>、<TT
CLASS="TYPE"
>regprocedure</TT
>、<TT
CLASS="TYPE"
>regoper</TT
>、<TT
CLASS="TYPE"
>regoperator</TT
>、<TT
CLASS="TYPE"
>regclass</TT
>、<TT
CLASS="TYPE"
>regtype</TT
>、<TT
CLASS="TYPE"
>regrole</TT
>、<TT
CLASS="TYPE"
>regnamespace</TT
>、<TT
CLASS="TYPE"
>regconfig</TT
>和<TT
CLASS="TYPE"
>regdictionary</TT
>。<A
HREF="datatype-oid.html#DATATYPE-OID-TABLE"
>&#34920; 8-24</A
>显示了一个概览。
   </P
><P
>    <TT
CLASS="TYPE"
>oid</TT
>类型目前被实现为一个无符号4字节整数。因此，在大型数据库中它并不足以提供数据库范围内的唯一性，甚至在一些大型的表中也无法提供表范围内的唯一性。于是，我们不鼓励使用一个用户定义表的OID列作为主键。OID最好只被用于引用系统表。
   </P
><P
>    <TT
CLASS="TYPE"
>oid</TT
>类型本身除了比较之外只有很少的操作。不过，它可以被造型成整数，并且接着可以使用标准的整数操作符进行操纵（这样做时要注意有符号和无符号之间可能出现的混乱）。
   </P
><P
>    OID的别名类型除了特定的输入和输出例程之外没有别的操作。这些例程可以接受并显示系统对象的符号名，而不是类型<TT
CLASS="TYPE"
>oid</TT
>使用的原始数字值。别名类型使查找对象的OID值变得简单。例如，要检查与一个表<TT
CLASS="LITERAL"
>mytable</TT
>有关的<TT
CLASS="STRUCTNAME"
>pg_attribute</TT
>行，你可以写：
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;</PRE
><P>
    而不是：
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');</PRE
><P>
    虽然从它本身看起来并没有那么糟，它仍然被过度简化了。如果有多个名为<TT
CLASS="LITERAL"
>mytable</TT
>的表存在于不同的模式中，就可能需要一个更复杂的子选择来选择右边的OID。<TT
CLASS="TYPE"
>regclass</TT
>输入转换器会根据模式路径设置处理表查找，并且因此它会自动地完成这种<SPAN
CLASS="QUOTE"
>"右边的事情"</SPAN
>。类似地，对于一个数字OID的符号化显示可以很方便地通过将表OID造型成<TT
CLASS="TYPE"
>regclass</TT
>来实现。
   </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-OID-TABLE"
></A
><P
><B
>&#34920; 8-24. 对象标识符类型</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>名字</TH
><TH
>引用</TH
><TH
>描述</TH
><TH
>值示例</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>任意</TD
><TD
>数字形式的对象标识符</TD
><TD
><TT
CLASS="LITERAL"
>564182</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></TD
><TD
>函数名字</TD
><TD
><TT
CLASS="LITERAL"
>sum</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regprocedure</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></TD
><TD
>带参数类型的函数</TD
><TD
><TT
CLASS="LITERAL"
>sum(int4)</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regoper</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_operator</TT
></TD
><TD
>操作符名字</TD
><TD
><TT
CLASS="LITERAL"
>+</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regoperator</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_operator</TT
></TD
><TD
>带参数类型的操作符</TD
><TD
><TT
CLASS="LITERAL"
>*(integer,integer)</TT
> or <TT
CLASS="LITERAL"
>-(NONE,integer)</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regclass</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_class</TT
></TD
><TD
>关系名字</TD
><TD
><TT
CLASS="LITERAL"
>pg_type</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regtype</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_type</TT
></TD
><TD
>数据类型名字</TD
><TD
><TT
CLASS="LITERAL"
>integer</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regrole</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_authid</TT
></TD
><TD
>角色名</TD
><TD
><TT
CLASS="LITERAL"
>smithee</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regnamespace</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_namespace</TT
></TD
><TD
>名字空间名称</TD
><TD
><TT
CLASS="LITERAL"
>pg_catalog</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regconfig</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_ts_config</TT
></TD
><TD
>文本搜索配置</TD
><TD
><TT
CLASS="LITERAL"
>english</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regdictionary</TT
></TD
><TD
><TT
CLASS="STRUCTNAME"
>pg_ts_dict</TT
></TD
><TD
>文本搜索字典</TD
><TD
><TT
CLASS="LITERAL"
>simple</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>    所有用于由名字空间组织的对象的 OID 别名类型都接受模式限定的名字，如果没有被限定的对象在当前搜索路径中无法找到时，将会在输出时显示模式限定的名字。<TT
CLASS="TYPE"
>regproc</TT
>和<TT
CLASS="TYPE"
>regoper</TT
>别名类型将只接受唯一的（非重载的）输入名字，因此它们的使用是受限的；对于大多数使用，<TT
CLASS="TYPE"
>regprocedure</TT
>或<TT
CLASS="TYPE"
>regoperator</TT
>更合适。对于<TT
CLASS="TYPE"
>regoperator</TT
>，通过使用<TT
CLASS="LITERAL"
>NONE</TT
>来替代未使用的操作数可以标识一元操作符。
   </P
><P
>    大部分 OID 别名类型的一个附加性质是依赖性的创建。如果这些类型之一的一个常量出现在一个存储的表达式（如一个列默认值表达式或视图）中，它会在被引用的对象上创建一个依赖。例如，如果一个列有一个默认值表达式<TT
CLASS="LITERAL"
>nextval('my_seq'::regclass)</TT
>，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>会理解该默认值表达式是依赖于序列<TT
CLASS="LITERAL"
>my_seq</TT
>的，在删除该默认值表达式之前系统将不允许删除该序列。<TT
CLASS="TYPE"
>regrole</TT
>是这个性质的唯一例外。这种类型的常量不允许出现在这类表达式中。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    OID 别名类型不完全遵循事务隔离规则。规划器也把它们当做简单常量，
    这可能会导致次优的规划。
   </P
></BLOCKQUOTE
></DIV
><P
>    另一种系统中使用的标识符类型是<TT
CLASS="TYPE"
>xid</TT
>，或者称为事务（简写为<ABBR
CLASS="ABBREV"
>xact</ABBR
>）标识符。这是系统列<TT
CLASS="STRUCTFIELD"
>xmin</TT
>和<TT
CLASS="STRUCTFIELD"
>xmax</TT
>使用的数据类型。事务标识符是32位量。
   </P
><P
>    系统使用的第三种标识符类型是<TT
CLASS="TYPE"
>cid</TT
>，或者称为命令标识符。这是系统列<TT
CLASS="STRUCTFIELD"
>cmin</TT
>和<TT
CLASS="STRUCTFIELD"
>cmax</TT
>使用的数据类型。命令标识符也是32位量。
   </P
><P
>    系统使用的最后一种标识符类型是<TT
CLASS="TYPE"
>tid</TT
>，或者称为元组标识符（行标识符）。这是系统列<TT
CLASS="STRUCTFIELD"
>ctid</TT
>使用的数据类型。一个元组ID是一个（块号，块内元组索引）对，它标识了行在它的表中的物理位置。
   </P
><P
>    （这些系统列在<A
HREF="ddl-system-columns.html"
>第 5.4 &#33410;</A
>中有进一步的解释）。
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="rangetypes.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="datatype-pg-lsn.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>范围类型</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><ACRONYM
CLASS="ACRONYM"
>pg_lsn Type</ACRONYM
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
