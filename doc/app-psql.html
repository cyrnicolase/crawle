<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>psql</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="PostgreSQL 客户端应用"
HREF="reference-client.html"><LINK
REL="PREVIOUS"
TITLE="pg_restore"
HREF="app-pgrestore.html"><LINK
REL="NEXT"
TITLE="reindexdb"
HREF="app-reindexdb.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="REFENTRY"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/ref/psql-ref.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="pg_restore"
HREF="app-pgrestore.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="reference-client.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="reindexdb"
HREF="app-reindexdb.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="APP-PSQL"
></A
><SPAN
CLASS="APPLICATION"
>psql</SPAN
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN98162"
></A
><H2
>&#21517;&#31216;</H2
><SPAN
CLASS="APPLICATION"
>psql</SPAN
>&nbsp;--&nbsp;      <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的交互式终端
    </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN98167"
></A
><H2
>&#22823;&#32434;</H2
><P
><TT
CLASS="COMMAND"
>psql</TT
> [<TT
CLASS="REPLACEABLE"
><I
>option</I
></TT
>...] [<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
>
    [<TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
>]]</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN98176"
></A
><H2
>描述</H2
><P
>     <SPAN
CLASS="APPLICATION"
>psql</SPAN
>是一个<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的基于终端的前端。它让你能交互式地键入查询，把它们发送给<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>，并且查看查询结果。或者，输入可以来自于一个文件或者命令行参数。此外，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>还提供一些元命令和多种类似 shell 的特性来为编写脚本和自动化多种任务提供便利。
    </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-APP-PSQL-3"
></A
><H2
>选项</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-a</TT
><BR><TT
CLASS="OPTION"
>--echo-all</TT
></DT
><DD
><P
>      把所有非空输入行按照它们被读入的形式打印到标准输出（不适用于交互式行读取）。这等效于把变量<TT
CLASS="VARNAME"
>ECHO</TT
>设置为
      <TT
CLASS="LITERAL"
>all</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-A</TT
><BR><TT
CLASS="OPTION"
>--no-align</TT
></DT
><DD
><P
>      切换到非对齐输出模式（默认输出模式是对齐的）。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-b</TT
><BR><TT
CLASS="OPTION"
>--echo-errors</TT
></DT
><DD
><P
>      把失败的 SQL 命令打印到标准错误输出。这等效于把变量<TT
CLASS="VARNAME"
>ECHO</TT
>设置为<TT
CLASS="LITERAL"
>errors</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-c <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--command=<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
></TT
></DT
><DD
><P
>      指定<SPAN
CLASS="APPLICATION"
>psql</SPAN
>执行一个给定的命令字符串<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>。这个选项可以重复多次并且以任何顺序与<TT
CLASS="OPTION"
>-f</TT
>选项组合在一起。当<TT
CLASS="OPTION"
>-c</TT
>或者<TT
CLASS="OPTION"
>-f</TT
>被指定时，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>不会从标准输入读取命令，直到它处理完序列中所有的<TT
CLASS="OPTION"
>-c</TT
>和<TT
CLASS="OPTION"
>-f</TT
>选项之后终止。
      </P
><P
>       <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>必须是一个服务器完全可解析的命令字符串（即不包含<SPAN
CLASS="APPLICATION"
>psql</SPAN
>相关的特性）或者单个反斜线命令。因此不能在一个<TT
CLASS="OPTION"
>-c</TT
>选项中混合<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>和<SPAN
CLASS="APPLICATION"
>psql</SPAN
>元命令。要那样做，可以使用多个<TT
CLASS="OPTION"
>-c</TT
>选项或者把字符串用管道输送到<SPAN
CLASS="APPLICATION"
>psql</SPAN
>中，例如：
</P><PRE
CLASS="PROGRAMLISTING"
>psql -c '\x' -c 'SELECT * FROM foo;'</PRE
><P>
       或者
</P><PRE
CLASS="PROGRAMLISTING"
>echo '\x \\ SELECT * FROM foo;' | psql</PRE
><P>
       （<TT
CLASS="LITERAL"
>\\</TT
>是分隔符元命令）。
      </P
><P
>       每一个被传递给<TT
CLASS="OPTION"
>-c</TT
>的<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令字符串会被当做一个单独的查询发送给服务器。因此，即便该字符串包括多个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令，服务器也会把它当做一个事务来执行，除非在该字符串中有显式的<TT
CLASS="COMMAND"
>BEGIN</TT
>/<TT
CLASS="COMMAND"
>COMMIT</TT
>命令把它划分成多个事务。此外，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>只会打印出该字符串中最后一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令的结果。这和从文件中读取同一字符串或者把同一字符串传给<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的标准输出时的行为不同，因为那两种情况下<SPAN
CLASS="APPLICATION"
>psql</SPAN
>会独立地发送每一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令。
      </P
><P
>       由于这种行为，把多于一个命令放在<TT
CLASS="OPTION"
>-c</TT
>字符串中通常会得到意料之外的结果。最好使用多个<TT
CLASS="OPTION"
>-c</TT
>命令或者把多个命令输送给<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的标准输入，按照上文所说的使用<SPAN
CLASS="APPLICATION"
>echo</SPAN
>或者通过一个 shell，例如：
</P><PRE
CLASS="PROGRAMLISTING"
>psql &lt;&lt;EOF
\x
SELECT * FROM foo;
EOF</PRE
><P>
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-d <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--dbname=<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></TT
></DT
><DD
><P
>       指定要连接的数据库的名称。这等效于指定<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
>为命令行上的第一个非选项参数。
      </P
><P
>       如果这个参数包含一个<TT
CLASS="SYMBOL"
>=</TT
>符号或者以一个合法的<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>前缀（<TT
CLASS="LITERAL"
>postgresql://</TT
>或者<TT
CLASS="LITERAL"
>postgres://</TT
>）开始，它会被当作一个<TT
CLASS="PARAMETER"
>conninfo</TT
>字符串。详见<A
HREF="libpq-connect.html#LIBPQ-CONNSTRING"
>第 32.1.1 &#33410;</A
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-e</TT
><BR><TT
CLASS="OPTION"
>--echo-queries</TT
></DT
><DD
><P
>      也把发送到服务器的所有 SQL 命令复制到标准输出。这等效于把变量<TT
CLASS="VARNAME"
>ECHO</TT
>设置为<TT
CLASS="LITERAL"
>queries</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-E</TT
><BR><TT
CLASS="OPTION"
>--echo-hidden</TT
></DT
><DD
><P
>      回显<TT
CLASS="COMMAND"
>\d</TT
>以及其他反斜线命令生成的实际查询。可以用它来学习<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的内部操作。这等效于把变量<TT
CLASS="VARNAME"
>ECHO_HIDDEN</TT
>设置为<TT
CLASS="LITERAL"
>on</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-f <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--file=<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
></DT
><DD
><P
>       从文件<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>而不是标准输入中读取命令。这个选项可以被重复多次，也可以以任意顺序与<TT
CLASS="OPTION"
>-c</TT
>选项组合。当<TT
CLASS="OPTION"
>-c</TT
>或者<TT
CLASS="OPTION"
>-f</TT
>被指定时，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>不会从标准输入读取命令，直到它处理完序列中所有的<TT
CLASS="OPTION"
>-c</TT
>和<TT
CLASS="OPTION"
>-f</TT
>选项之后终止。除此以外，这个选项很大程度上等价于元命令<TT
CLASS="COMMAND"
>\i</TT
>。
      </P
><P
>       如果<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>是<TT
CLASS="LITERAL"
>-</TT
>（连字符），那么会读取标准输入直到遇见一个 EOF 指示或者<TT
CLASS="COMMAND"
>\q</TT
>元命令。这种方式可以用把自多个文件的输入组合成一种交互式输入。不过注意在这种情况下不会使用 Readline（很像指定了<TT
CLASS="OPTION"
>-n</TT
>的情况）。
      </P
><P
>      使用这个选项与<TT
CLASS="LITERAL"
>psql &lt; <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
>有细微的不同。通常，两种形式都可以做到我们所期望的，但是使用<TT
CLASS="LITERAL"
>-f</TT
>启用了一些好的特性，例如带有行号的错误消息。使用这个选项还有一丝机会可以降低启动开销。在另一方面，使用 shell输入重定向的变体（理论上）保证会得到与手工输入时相同的输出。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-F <TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--field-separator=<TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
></TT
></DT
><DD
><P
>      使用<TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
>作为非对齐输出的域分隔符。这等效于<TT
CLASS="COMMAND"
>\pset fieldsep</TT
>或者<TT
CLASS="COMMAND"
>\f</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-h <TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--host=<TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
></TT
></DT
><DD
><P
>      指定运行服务器的机器的主机名。如果这个值由一个斜线开始，它会被用作 Unix 域套接字的目录。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-H</TT
><BR><TT
CLASS="OPTION"
>--html</TT
></DT
><DD
><P
>      打开<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>表格输出。这等效于<TT
CLASS="LITERAL"
>\pset format html</TT
>或者<TT
CLASS="COMMAND"
>\H</TT
>命令。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-l</TT
><BR><TT
CLASS="OPTION"
>--list</TT
></DT
><DD
><P
>      列出所有可用的数据库，然后退出。其他非连接选项会被忽略。这与元命令<TT
CLASS="COMMAND"
>\list</TT
>类似。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-L <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--log-file=<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
></DT
><DD
><P
>       除了把所有查询输出写到普通输出目标之外，还写到文件<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>中。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-n</TT
><BR><TT
CLASS="OPTION"
>--no-readline</TT
></DT
><DD
><P
>       不使用<SPAN
CLASS="APPLICATION"
>Readline</SPAN
>做行编辑并且不使用命令历史。在剪切和粘贴时，关掉 Tab 展开会有所帮助。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-o <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--output=<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
></DT
><DD
><P
>      把所有查询输出放到文件<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>中。这等效于命令<TT
CLASS="COMMAND"
>\o</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-p <TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--port=<TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
></TT
></DT
><DD
><P
>      指定服务器用于监听连接的 TCP 端口或者本地 Unix 域套接字文件扩展。默认是<TT
CLASS="ENVAR"
>PGPORT</TT
>环境变量的值，如果没有设置，则默认为编译时指定的端口号（通常是5432）。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-P <TT
CLASS="REPLACEABLE"
><I
>assignment</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--pset=<TT
CLASS="REPLACEABLE"
><I
>assignment</I
></TT
></TT
></DT
><DD
><P
>      以<TT
CLASS="COMMAND"
>\pset</TT
>的形式指定打印选项。注意，这里你必须用一个等号而不是空格来分隔名称和值。例如，要设置输出格式为<SPAN
CLASS="APPLICATION"
>LaTeX</SPAN
>，应该写成<TT
CLASS="LITERAL"
>-P format=latex</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-q</TT
><BR><TT
CLASS="OPTION"
>--quiet</TT
></DT
><DD
><P
>      指定<SPAN
CLASS="APPLICATION"
>psql</SPAN
>应该安静地工作。默认情况下，它会打印出欢迎消息以及多种输出。如果使用了这个选项，以上那些就都不会输出。在使用<TT
CLASS="OPTION"
>-c</TT
>选项时，配合这个选项很有用。这等效于设置变量<TT
CLASS="VARNAME"
>QUIET</TT
>为<TT
CLASS="LITERAL"
>on</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-R <TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--record-separator=<TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
></TT
></DT
><DD
><P
>      把<TT
CLASS="REPLACEABLE"
><I
>separator</I
></TT
>用作非对齐输出的记录分隔符。这等效于<TT
CLASS="COMMAND"
>\pset recordsep</TT
>命令。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
><BR><TT
CLASS="OPTION"
>--single-step</TT
></DT
><DD
><P
>      运行在单步模式中。这意味着在每个命令被发送给服务器之前都会提示用户一个可以取消执行的选项。使用这个选项可以调试脚本。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-S</TT
><BR><TT
CLASS="OPTION"
>--single-line</TT
></DT
><DD
><P
>      运行在单行模式中，其中新行会终止一个 SQL 命令，就像分号的作用一样。
      </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      这种模式被提供给那些坚持使用它的用户，但是并不一定要使用它。特别地，如果在一行中混合了<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>和元命令，那对于没有经的用户来说，它们的执行顺序可能不总是那么清晰。
      </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
><BR><TT
CLASS="OPTION"
>--tuples-only</TT
></DT
><DD
><P
>      关闭打印列名和结果行计数页脚等。这等效于<TT
CLASS="COMMAND"
>\t</TT
>命令。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-T <TT
CLASS="REPLACEABLE"
><I
>table_options</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--table-attr=<TT
CLASS="REPLACEABLE"
><I
>table_options</I
></TT
></TT
></DT
><DD
><P
>      指定要替换<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
> <CODE
CLASS="SGMLTAG"
>table</CODE
>标签的选项。详见<TT
CLASS="COMMAND"
>\pset</TT
>。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-U <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--username=<TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
></TT
></DT
><DD
><P
>      作为用户<TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
>而不是默认用户连接到数据库（当然，你必须具有这样做的权限）。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-v <TT
CLASS="REPLACEABLE"
><I
>assignment</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--set=<TT
CLASS="REPLACEABLE"
><I
>assignment</I
></TT
></TT
><BR><TT
CLASS="OPTION"
>--variable=<TT
CLASS="REPLACEABLE"
><I
>assignment</I
></TT
></TT
></DT
><DD
><P
>      执行一次变量赋值，和<TT
CLASS="COMMAND"
>\set</TT
>元命令相似。注意你必须在命令行上用等号分隔名字和值（如果有）。要重置一个变量，去掉等号就行。要把一个变量置为空值，使用等号但是去掉值。这些赋值都是在启动的很早期阶段完成的，因此为内部目的保留的变量可能会在后面被覆盖。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-V</TT
><BR><TT
CLASS="OPTION"
>--version</TT
></DT
><DD
><P
>      打印<SPAN
CLASS="APPLICATION"
>psql</SPAN
>版本并且退出。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-w</TT
><BR><TT
CLASS="OPTION"
>--no-password</TT
></DT
><DD
><P
>       从不发出一个口令提示。如果服务器要求口令认证并且没有其他方式提供口令（例如一个<TT
CLASS="FILENAME"
>.pgpass</TT
>文件），那儿连接尝试将失败。这个选项对于批处理任务和脚本有用，因为在其中没有一个用户来输入口令。
      </P
><P
>       注意这个选项将对整个会话保持设置，并且因此它会影响元命令<TT
CLASS="COMMAND"
>\connect</TT
>的使用，就像初始的连接尝试那样。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-W</TT
><BR><TT
CLASS="OPTION"
>--password</TT
></DT
><DD
><P
>       强制<SPAN
CLASS="APPLICATION"
>psql</SPAN
>在连接到一个数据库之前提示要求一个口令。
      </P
><P
>       这个选项不是必不可少的，因为如果服务器要求口令认证，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将自动提示要求一个口令。但是，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将浪费一次连接尝试来发现服务器想要一个口令。在某些情况下值得用<TT
CLASS="OPTION"
>-W</TT
>来避免额外的连接尝试。
      </P
><P
>       注意这个选项将对整个会话保持设置，并且因此它会影响元命令<TT
CLASS="COMMAND"
>\connect</TT
>的使用，就像初始的连接尝试那样。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-x</TT
><BR><TT
CLASS="OPTION"
>--expanded</TT
></DT
><DD
><P
>      打开扩展表格式模式。这等效于<TT
CLASS="COMMAND"
>\x</TT
>命令。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-X,</TT
><BR><TT
CLASS="OPTION"
>--no-psqlrc</TT
></DT
><DD
><P
>      不读取启动文件（要么是系统范围的<TT
CLASS="FILENAME"
>psqlrc</TT
>文件，要么是用户的<TT
CLASS="FILENAME"
>~/.psqlrc</TT
>文件）。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-z</TT
><BR><TT
CLASS="OPTION"
>--field-separator-zero</TT
></DT
><DD
><P
>      设置非对齐输出的域分隔符为零字节。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-0</TT
><BR><TT
CLASS="OPTION"
>--record-separator-zero</TT
></DT
><DD
><P
>      设置非对齐输出的记录分隔符为零字节。例如，这对与<TT
CLASS="LITERAL"
>xargs -0</TT
>配合有关。
      </P
></DD
><DT
><TT
CLASS="OPTION"
>-1</TT
><BR><TT
CLASS="OPTION"
>--single-transaction</TT
></DT
><DD
><P
>        这个选项只能被用于与一个或者多个<TT
CLASS="OPTION"
>-c</TT
>以及/或者<TT
CLASS="OPTION"
>-f</TT
>选项组合。它会让<SPAN
CLASS="APPLICATION"
>psql</SPAN
>在第一个上述选项之前发出一条<TT
CLASS="COMMAND"
>BEGIN</TT
>命令并且在最后一个上述选项之后发出一条<TT
CLASS="COMMAND"
>COMMIT</TT
>命令，这样就把所有的命令都包裹在一个事务中。这个选项可以保证要么所有的命令都成功地完成，要么不应用任何更改。
       </P
><P
>        如果命令本身包含<TT
CLASS="COMMAND"
>BEGIN</TT
>、<TT
CLASS="COMMAND"
>COMMIT</TT
>或者<TT
CLASS="COMMAND"
>ROLLBACK</TT
>，这个选项将不会得到想要的效果。还有，如果当个命令不能在一个事务块中执行，指定这个选项将导致整个事务失败。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-?</TT
><BR><TT
CLASS="OPTION"
>--help[=<TT
CLASS="REPLACEABLE"
><I
>topic</I
></TT
>]</TT
></DT
><DD
><P
>      显示有关<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的帮助并且退出。可选的<TT
CLASS="REPLACEABLE"
><I
>topic</I
></TT
>参数（默认为<TT
CLASS="LITERAL"
>options</TT
>）选择要解释哪一部分的<SPAN
CLASS="APPLICATION"
>psql</SPAN
>：<TT
CLASS="LITERAL"
>commands</TT
>描述<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的反斜线命令；<TT
CLASS="LITERAL"
>options</TT
>描述可以被传递给<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的命令行选项；而<TT
CLASS="LITERAL"
>variables</TT
>则显示有关<SPAN
CLASS="APPLICATION"
>psql</SPAN
>配置变量的帮助。
      </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN98589"
></A
><H2
>退出状态</H2
><P
>   如果<SPAN
CLASS="APPLICATION"
>psql</SPAN
>正常完成，它会向 shell 返回 0。如果它自身发生一个致命错误（例如内存用完、找不到文件），它会返回 1。如果到服务器的连接出问题并且事务不是交互式的，它会返回 2。如果在脚本中发生错误，它会返回 3 并且变量<TT
CLASS="VARNAME"
>ON_ERROR_STOP</TT
>会被设置。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN98594"
></A
><H2
>用法</H2
><DIV
CLASS="REFSECT2"
><A
NAME="R2-APP-PSQL-CONNECTING"
></A
><H3
>连接到数据库</H3
><P
>    <SPAN
CLASS="APPLICATION"
>psql</SPAN
>是一个常规<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>客户端应用。为了连接到数据库，你需要知道你的目标数据库的名称、主机名和该服务器的端口号，还有要作为哪个用户名连接。可以通过命令行选项告知<SPAN
CLASS="APPLICATION"
>psql</SPAN
>这些参数，分别是<TT
CLASS="OPTION"
>-d</TT
>、<TT
CLASS="OPTION"
>-h</TT
>、<TT
CLASS="OPTION"
>-p</TT
>以及<TT
CLASS="OPTION"
>-U</TT
>。如果发现一个参数不属于任何选项，它将被解释为数据库名称（如果已经给出数据库名称，就解释为用户名）。并非所有这些选项都是必需的，它们都有可用的默认值。如果省略主机名，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将通过一个 Unix 域套接字连接到本地主机上的服务器，或者通过 TCP/IP 连接到没有 Unix 域套接字的主机上的<TT
CLASS="LITERAL"
>localhost</TT
>。默认端口号则在编译时决定。由于数据库服务器使用相同的默认值，大多数情况下你将不必指定端口。默认的用户名是你的操作系统用户名，它也会是默认的数据库名。注意你不一定能连接到任意用户名下的任何数据库。你的数据库管理员应该已经告知过你有关你的访问权限。
    </P
><P
>    当默认值不是很符合实际时，可以把环境变量<TT
CLASS="ENVAR"
>PGDATABASE</TT
>、<TT
CLASS="ENVAR"
>PGHOST</TT
>、<TT
CLASS="ENVAR"
>PGPORT</TT
>以及<TT
CLASS="ENVAR"
>PGUSER</TT
>设置为适当的值，这样也能节省一些敲打键盘的工作（额外的环境变量可见<A
HREF="libpq-envars.html"
>第 32.14 &#33410;</A
>）。用一个<TT
CLASS="FILENAME"
>~/.pgpass</TT
>文件来避免定期输入密码也很方便。详见<A
HREF="libpq-pgpass.html"
>第 32.15 &#33410;</A
>。
    </P
><P
>     另一种指定连接参数的方法是用一个<TT
CLASS="PARAMETER"
>conninfo</TT
>字符串或者一个<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>，它可以被用来替代数据库名。这种机制可以让我们对连接具有很广的控制权。例如：
</P><PRE
CLASS="PROGRAMLISTING"
>$ <KBD
CLASS="USERINPUT"
>psql "service=myservice sslmode=require"</KBD
>
$ <KBD
CLASS="USERINPUT"
>psql postgresql://dbmaster:5433/mydb?sslmode=require</KBD
></PRE
><P>
     用这种方式，你也可以把<ACRONYM
CLASS="ACRONYM"
>LDAP</ACRONYM
>用于<A
HREF="libpq-ldap.html"
>第 32.17 &#33410;</A
>中描述的连接参数查找。可用连接选项的更多信息请见<A
HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS"
>第 32.1.2 &#33410;</A
>。
    </P
><P
>    如果由于任何原因（例如权限不足、服务器没有在目标主机上运行等）导致连接无法建立，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将返回一个错误并且终止。
    </P
><P
>     如果标准输入和标准输出都是一个终端，那么<SPAN
CLASS="APPLICATION"
>psql</SPAN
>会把客户端编码设置成<SPAN
CLASS="QUOTE"
>"auto"</SPAN
>，这会使<SPAN
CLASS="APPLICATION"
>psql</SPAN
>从区域设置（Unix 系统上的<TT
CLASS="ENVAR"
>LC_CTYPE</TT
>环境变量）中检测合适的客户端编码。如果这样不起作用，可以使用环境变量<TT
CLASS="ENVAR"
>PGCLIENTENCODING</TT
>覆盖客户端编码。
    </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="R2-APP-PSQL-4"
></A
><H3
>输入 SQL 命令</H3
><P
>    在正常操作时，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>会提供一个提示符，该提示符是<SPAN
CLASS="APPLICATION"
>psql</SPAN
>当前连接到的数据库名称后面跟上字符串<TT
CLASS="LITERAL"
>=&gt;</TT
>。例如：
</P><PRE
CLASS="PROGRAMLISTING"
>$ <KBD
CLASS="USERINPUT"
>psql testdb</KBD
>
psql (9.6.0)
Type "help" for help.

testdb=&gt;</PRE
><P>
    </P
><P
>    在提示符下，用户可以键入<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令。正常情况下，当碰到一个表示命令终结的分号时，输入的行会被发送给服务器。一行的结束并不表示命令的完结。因此，为了清晰，可以把命令散布在多个行上。如果命令被发送并且执行而不产生错误，该命令的结果将会显示在屏幕上。
    </P
><P
>    只要执行命令，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>还会测试<A
HREF="sql-listen.html"
>LISTEN</A
>和<A
HREF="sql-notify.html"
>NOTIFY</A
>产生的异步通知。
    </P
><P
>    虽然 C 风格的注释块会被传给服务器处理并且移除，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>会自己移除掉 SQL 标准的注释。
    </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="APP-PSQL-META-COMMANDS"
></A
><H3
>元命令</H3
><P
>    你输入到<SPAN
CLASS="APPLICATION"
>psql</SPAN
>中的任何以未加引用的反斜线开始的东西都是一个<SPAN
CLASS="APPLICATION"
>psql</SPAN
>元命令，它们由<SPAN
CLASS="APPLICATION"
>psql</SPAN
>自行处理。这些命令让<SPAN
CLASS="APPLICATION"
>psql</SPAN
>对管理和编写脚本更有用。元命令常常被称作斜线或者反斜线命令。
    </P
><P
>    <SPAN
CLASS="APPLICATION"
>psql</SPAN
>命令的格式是用反斜线后面直接跟上一个命令动词，然后是一些参数。参数与命令动词和其他参数之间用任意多个空白字符分隔开。
    </P
><P
>    要在一个参数中包括空白，可以将它加上单引号。要在一个参数中包括一个单引号，则需要在文本中写上两个单引号。任何包含在单引号中的东西都服从与 C 语言中<TT
CLASS="LITERAL"
>\n</TT
>（新行）、<TT
CLASS="LITERAL"
>\t</TT
>（制表符）、<TT
CLASS="LITERAL"
>\b</TT
>（退格）、<TT
CLASS="LITERAL"
>\r</TT
>（回车）、<TT
CLASS="LITERAL"
>\f</TT
>（换页）、<TT
CLASS="LITERAL"
>\</TT
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>（10 进制）以及<TT
CLASS="LITERAL"
>\x</TT
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>（16 进制）类似的替换规则。单引号内文本中的其他任何字符（不管它是什么）前面的反斜线都没有实际意义（会被忽略）。
    </P
><P
>    在一个参数中，封闭在反引号（<TT
CLASS="LITERAL"
>`</TT
>）中的文本被当做要被送给 shell 的一个命令行。该命令的输出（去掉尾部的新行）将会替换这段用反引号文本。
    </P
><P
>    如果一个参数中出现一个未加引号的冒号（<TT
CLASS="LITERAL"
>:</TT
>）后面跟着一个<SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量名，如<A
HREF="app-psql.html#APP-PSQL-INTERPOLATION"
><I
><I
>SQL</I
> 中插入变量</I
></A
>中所述，它会被该变量的值所替换。
    </P
><P
>    有些命令把<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>标识符（例如一个表名）当作参数。这些参数遵循<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>的语法规则：无引号的字母被强制变为小写，而双引号（<TT
CLASS="LITERAL"
>"</TT
>）可以保护字母避免大小写转换并且允许在标识符中包含空白。 在双引号内，成对的双引号会被缩减为结果名称中的单个双引号。例如，<TT
CLASS="LITERAL"
>FOO"BAR"BAZ</TT
>会被解释成<TT
CLASS="LITERAL"
>fooBARbaz</TT
>，而<TT
CLASS="LITERAL"
>"A weird"" name"</TT
>会变成<TT
CLASS="LITERAL"
>A weird" name</TT
>。
    </P
><P
>    对参数的解析会在行尾或者碰到另一个未加引号的反斜线时停止。一个未加引号的反斜线被当做新元命令的开始。特殊的序列<TT
CLASS="LITERAL"
>\\</TT
>（两个反斜线）表示参数结束并且应继续解析<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令（如果还有）。使用这种方法，<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令和<SPAN
CLASS="APPLICATION"
>psql</SPAN
>命令可以被自由地混合在一行中。但是无论在何种情况中，元命令的参数都无法跨越一行。
    </P
><P
>    可以使用下列元命令：

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>\a</TT
></DT
><DD
><P
>        如果当前的表输出格式是非对齐的，则切换成对齐格式。如果不是非对齐格式，则设置成非对齐格式。保留这个命令是为了向后兼容性。更一般的方案请见<TT
CLASS="COMMAND"
>\pset</TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\c</TT
> or <TT
CLASS="LITERAL"
>\connect [ -reuse-previous=<TT
CLASS="REPLACEABLE"
><I
>on|off</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
> ] | <TT
CLASS="REPLACEABLE"
><I
>conninfo</I
></TT
> ]</TT
></DT
><DD
><P
>        与一台<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>服务器建立一个新连接。可以使用位置语法指定要使用的连接参数，或者使用<A
HREF="libpq-connect.html#LIBPQ-CONNSTRING"
>第 32.1.1 &#33410;</A
>中详细介绍的<TT
CLASS="REPLACEABLE"
><I
>conninfo</I
></TT
>连接串。
        </P
><P
>        在省略了数据库名、用户、主机或者端口的命令中，新的连接将会重用之前一个连接的值。默认情况下，前一个连接的值将会被重用，除非给出了一个<TT
CLASS="REPLACEABLE"
><I
>conninfo</I
></TT
>串。给出第一个参数<TT
CLASS="LITERAL"
>-reuse-previous=on</TT
>或者<TT
CLASS="LITERAL"
>-reuse-previous=off</TT
>可以覆盖默认行为。当这个命令既没有指定一个参数也没有重用它时，将使用<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>的默认值。把<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
>或者<TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
>中的任何一个指定为<TT
CLASS="LITERAL"
>-</TT
>等价于省略该参数。
        </P
><P
>        如果新连接成功地被建立，之前的连接会被关闭。如果连接尝试失败（错误的用户名、访问被拒绝等），只有在<SPAN
CLASS="APPLICATION"
>psql</SPAN
>处于交互模式的情况下才会保留之前的连接。当执行一个非交互式脚本时出现连接尝试失败，处理将被立即停止，并且报出一个错误。这种区别一方面可以帮助用户发现打字错误，另一方面也可以作为一种安全机制防止脚本在错误的数据库上执行动作。
        </P
><P
>        例子：
        </P
><PRE
CLASS="PROGRAMLISTING"
>=&gt; \c mydb myuser host.dom 6432
=&gt; \c service=foo
=&gt; \c "host=localhost port=5432 dbname=mydb connect_timeout=10 sslmode=disable"
=&gt; \c postgresql://tom@localhost/mydb?application_name=myapp</PRE
></DD
><DT
><TT
CLASS="LITERAL"
>\C [ <TT
CLASS="REPLACEABLE"
><I
>title</I
></TT
> ]</TT
></DT
><DD
><P
>        设置查询结果的任何表的标题，或者重置这类标题。这个命令等效于<TT
CLASS="LITERAL"
>\pset title <TT
CLASS="REPLACEABLE"
><I
>title</I
></TT
></TT
>（这个命令的名称来自于<SPAN
CLASS="QUOTE"
>"caption"</SPAN
>，因为它之前只被用来在<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>表格中设置标题）。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\cd [ <TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
> ]</TT
></DT
><DD
><P
>         把当前工作目录改为<TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
>。如果不带参数，则切换到当前用户的主目录。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>          要打印当前的工作目录，可以使用<TT
CLASS="LITERAL"
>\! pwd</TT
>。
         </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\conninfo</TT
></DT
><DD
><P
>        输出有关当前数据库连接的信息。
        </P
></DD
><DT
><A
NAME="APP-PSQL-META-COMMANDS-COPY"
></A
><TT
CLASS="LITERAL"
>\copy { <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_list</I
></TT
> ) ] | ( <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
> ) }
        { <TT
CLASS="LITERAL"
>from</TT
> | <TT
CLASS="LITERAL"
>to</TT
> }
        { <TT
CLASS="REPLACEABLE"
><I
>'filename'</I
></TT
> | program <TT
CLASS="REPLACEABLE"
><I
>'command'</I
></TT
> | stdin | stdout | pstdin | pstdout }
        [ [ with ] ( <TT
CLASS="REPLACEABLE"
><I
>option</I
></TT
> [, ...] ) ]</TT
></DT
><DD
><P
>        执行一次前端拷贝。这个操作会运行一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> <A
HREF="sql-copy.html"
>COPY</A
>命令，不过不是服务器读取或者写入指定的文件，而是由<SPAN
CLASS="APPLICATION"
>psql</SPAN
>读写文件并且把数据从本地文件系统导向服务器。这意味着文件的可访问性和权限是本地用户的而非服务器上的，并且不需要 SQL 超级用户特权。
        </P
><P
>        当<TT
CLASS="LITERAL"
>program</TT
>被指定时，<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>被<SPAN
CLASS="APPLICATION"
>psql</SPAN
>执行并且传给<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>的数据或者从<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>传出的数据会在服务器和客户端之间流动。同样地，执行特权是本地用户的而非服务器上的，并且不需要 SQL 超级用户特权。
        </P
><P
>        对于<TT
CLASS="LITERAL"
>\copy ... from stdin</TT
>，数据行从发出该命令的同一来源读取，一直到读到<TT
CLASS="LITERAL"
>\.</TT
>或者数据流到达<ACRONYM
CLASS="ACRONYM"
>EOF</ACRONYM
>。这个选项可以用来填充内嵌在一个 SQL 脚本文件中的表。对于<TT
CLASS="LITERAL"
>\copy ... to stdout</TT
>，输出被发送到与<SPAN
CLASS="APPLICATION"
>psql</SPAN
>命令输出相同的位置，并且<TT
CLASS="LITERAL"
>COPY <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
></TT
>命令的状态不会被打印（因为它会被一个数据行搞乱）。要读/写<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的标准输入或者输出而不管当前命令的来源或者<TT
CLASS="LITERAL"
>\o</TT
>选项，可以写<TT
CLASS="LITERAL"
>from pstdin</TT
>或者<TT
CLASS="LITERAL"
>to pstdout</TT
>。
        </P
><P
>        这个命令的语法和<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> <A
HREF="sql-copy.html"
>COPY</A
>命令类似。所有除开数据来源/目的地的选项都和<A
HREF="sql-copy.html"
>COPY</A
>指定的一样。因此，<TT
CLASS="COMMAND"
>\copy</TT
>命令由特殊的解析规则。特别地，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的变量替换规则和反斜线转义不适合于此。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        这个操作不如<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> <TT
CLASS="COMMAND"
>COPY</TT
>命令有效，因为所有的数据必须通过客户端/服务器的连接来传递。对于大量的数据来说<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令可能会更好。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\copyright</TT
></DT
><DD
><P
>        显示<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的版权以及发布条款。
        </P
></DD
><DT
><A
NAME="APP-PSQL-META-COMMANDS-CROSSTABVIEW"
></A
><TT
CLASS="LITERAL"
>\crosstabview [
            <TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>
            [ <TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>
            [ <TT
CLASS="REPLACEABLE"
><I
>colD</I
></TT
>
            [ <TT
CLASS="REPLACEABLE"
><I
>sortcolH</I
></TT
>
            ] ] ] ] </TT
></DT
><DD
><P
>        执行当前的查询缓冲区（像<TT
CLASS="LITERAL"
>\g</TT
>那样）并且在一个交叉表格子中显示结果。该查询必须返回至少三列。由<TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>标识的输出列会成为垂直页眉并且<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>所标识的输出列会成为水平页眉。<TT
CLASS="REPLACEABLE"
><I
>colD</I
></TT
>标识显示在格子中的输出列。<TT
CLASS="REPLACEABLE"
><I
>sortcolH</I
></TT
>标识用于水平页眉的可选的排序列。
        </P
><P
>        每一个列说明可以是一个列编号（从 1 开始）或者一个列名。常用的 SQL 大小写折叠和引用规则适用于列名。如果省略，<TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>被当做列 1 并且<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>被当做列 2。<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>必须和<TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>不同。如果没有指定<TT
CLASS="REPLACEABLE"
><I
>colD</I
></TT
>，那么在查询结果中必须正好有三列，并且<TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>和<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>之外的那一列会被当做<TT
CLASS="REPLACEABLE"
><I
>colD</I
></TT
>。
        </P
><P
>        垂直页眉显示为最左边的列，它包含列<TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>中找到的值，值的顺序和查询结果中的顺序相同，但是重复值会被移除。
        </P
><P
>        水平页眉显示为第一行，它包含列<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>中找到的值，其中的重复值被移除。默认情况下，这些值会以查询结果中相同的顺序出现。但是如果给出了可选的<TT
CLASS="REPLACEABLE"
><I
>sortcolH</I
></TT
>参数，它标识一个值必须为整数编号的列，并且来自<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>的值将会根据相应的<TT
CLASS="REPLACEABLE"
><I
>sortcolH</I
></TT
>值排序后出现在水平页眉中。
        </P
><P
>        在交叉表格子中，对于<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>的每一个可区分的值<TT
CLASS="LITERAL"
>x</TT
>以及<TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>的每一个可区分的值<TT
CLASS="LITERAL"
>y</TT
>，位于交叉点<TT
CLASS="LITERAL"
>(x,y)</TT
>的单元包含<TT
CLASS="REPLACEABLE"
><I
>colH</I
></TT
>值为<TT
CLASS="LITERAL"
>x</TT
>且<TT
CLASS="REPLACEABLE"
><I
>colV</I
></TT
>值为<TT
CLASS="LITERAL"
>y</TT
>的查询结果行中<TT
CLASS="LITERAL"
>colD</TT
>列的值。如果没有这样的行，则该单元为空。如果有多个这样的行，则会报告一个错误。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\d[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        对于每一个匹配<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>的关系（表、视图、索引、序列或者外部表）或者组合类型，显示所有的列、它们的类型、表空间（如果非默认表空间）以及任何诸如<TT
CLASS="LITERAL"
>NOT NULL</TT
>或者默认值的特殊属性。相关的索引、约束、规则以及触发器也会被显示。对于外部表，还会显示相关的外部服务器（下文的<A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><I
>模式（Pattern）</I
></A
>中定义了<SPAN
CLASS="QUOTE"
>"匹配模式"</SPAN
>）。
        </P
><P
>        对于某些类型的关系，<TT
CLASS="LITERAL"
>\d</TT
>会为每一列显示额外的信息：对于序列会显示列值，对于索引显示被索引的表达式，对于外部表显示外部数据包装器选项。
        </P
><P
>        命令形式<TT
CLASS="LITERAL"
>\d+</TT
>是一样的，不过会显示更多信息：与该表的列相关的任何注释，表中是否存在 OID，如果关系是视图则显示视图定义，非默认的<A
HREF="sql-altertable.html#SQL-CREATETABLE-REPLICA-IDENTITY"
>replica identity</A
>设置。
        </P
><P
>        默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        如果使用<TT
CLASS="COMMAND"
>\d</TT
>但不带有<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>参数，它等价于<TT
CLASS="COMMAND"
>\dtvsE</TT
>，后者将显示所有可见的表、视图、序列和外部表的列表。这纯粹是一种便利措施。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\da[S] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出聚集函数，以及它们的返回类型和它们所操作的数据类型。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的聚集。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dA[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出访问方法。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的访问方法。如果在命令名称后面追加<TT
CLASS="LITERAL"
>+</TT
>，则与访问方法相关的处理器函数和描述也会和访问方法本身一起被列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\db[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出表空间。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的表空间。如果在命令名称后面追加<TT
CLASS="LITERAL"
>+</TT
>，则与表空间相关的选项、磁盘上的尺寸、权限以及描述也会和表空间本身一起被列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dc[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出字符集编码之间的转换。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的转换。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。如果在命令名称后面追加<TT
CLASS="LITERAL"
>+</TT
>，则每一个对象相关的描述也会被列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dC[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出类型转换。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出源类型和目标类型匹配该模式的转换。如果在命令名称后面追加<TT
CLASS="LITERAL"
>+</TT
>，则每一个对象相关的描述也会被列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dd[S] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        显示<TT
CLASS="LITERAL"
>约束</TT
>、<TT
CLASS="LITERAL"
>操作符类</TT
>、<TT
CLASS="LITERAL"
>操作符族</TT
>、<TT
CLASS="LITERAL"
>规则</TT
>以及<TT
CLASS="LITERAL"
>触发器</TT
>类型对象的描述。所有其他注释可以通过那些对象类型相应的反斜线命令查看。
        </P
><P
><TT
CLASS="LITERAL"
>\dd</TT
>显示匹配<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>的对象的描述，如果没有给出参数则显示合适类型的可见对象的描述。但是在任一种情况下都只列出具有描述的对象。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。
        </P
><P
>        对象的描述可以用<A
HREF="sql-comment.html"
>COMMENT</A
> <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令创建。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>\ddp [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出默认的访问特权设置。对那些默认特权设置已经被改变得与内建默认值不同的角色（以及模式，如果适用），为每一个角色（以及模式）显示一项。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出角色名称或者模式名称匹配该模式的项。
        </P
><P
>        <A
HREF="sql-alterdefaultprivileges.html"
>ALTER DEFAULT PRIVILEGES</A
>命令被用来设置默认访问特权。在<A
HREF="sql-grant.html"
>GRANT</A
>中解释了显示的特权的含义。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dD[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出域。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的域。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。如果在命令名称后面追加<TT
CLASS="LITERAL"
>+</TT
>，则每一个对象相关的权限和描述也会被列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dE[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
><BR><TT
CLASS="LITERAL"
>\di[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
><BR><TT
CLASS="LITERAL"
>\dm[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
><BR><TT
CLASS="LITERAL"
>\ds[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
><BR><TT
CLASS="LITERAL"
>\dt[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
><BR><TT
CLASS="LITERAL"
>\dv[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        在这一组命令中，字母<TT
CLASS="LITERAL"
>E</TT
>、<TT
CLASS="LITERAL"
>i</TT
>、<TT
CLASS="LITERAL"
>m</TT
>、<TT
CLASS="LITERAL"
>s</TT
>、<TT
CLASS="LITERAL"
>t</TT
>和<TT
CLASS="LITERAL"
>v</TT
>分别对应着外部表、索引、物化视图、序列、表和视图。你可以以任何顺序指定这些字母中的任意一个或者多个，这样可以得到这些类型的对象的列表。例如，<TT
CLASS="LITERAL"
>\dit</TT
>会列出索引和表。如果在命令名称后面追加<TT
CLASS="LITERAL"
>+</TT
>，则每一个对象的物理尺寸以及相关的描述也会被列出。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的对象。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\des[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出外部服务器（助记：<SPAN
CLASS="QUOTE"
>"外部服务器"</SPAN
>）。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的那些服务器。如果使用了<TT
CLASS="LITERAL"
>\des+</TT
>形式，将显示每个服务器的完整描述，包括该服务器的 ACL、类型、版本、选项和描述。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\det[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出外部表（助记：<SPAN
CLASS="QUOTE"
>"外部表"</SPAN
>）。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出表名称或者模式名称匹配该模式的项。如果使用了<TT
CLASS="LITERAL"
>\det+</TT
>选项，一般选项和外部表描述也会被显示。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\deu[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出用户映射（助记：<SPAN
CLASS="QUOTE"
>"外部用户"</SPAN
>）。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出用户名匹配该模式的那些映射。如果使用了<TT
CLASS="LITERAL"
>\deu+</TT
>形式，有关每个映射的额外信息也会被显示。
        </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="90%"
><TR
><TD
ALIGN="CENTER"
><B
>&#23567;&#24515;</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>        <TT
CLASS="LITERAL"
>\deu+</TT
>可能也会显示远程用户的用户名和口令，所以要小心不要把它们泄露出去。
        </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\dew[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出外部数据包装器（助记：<SPAN
CLASS="QUOTE"
>"外部包装器"</SPAN
>）。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的那些外部数据包装器。如果使用了<TT
CLASS="LITERAL"
>\dew+</TT
>形式，外部数据包装器的 ACL、选项和描述也会被显示。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\df[antwS+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出函数，以及它们的结果数据类型、参数数据类型和函数类型，函数类型被分为<SPAN
CLASS="QUOTE"
>"agg"</SPAN
>（聚集）、<SPAN
CLASS="QUOTE"
>"normal"</SPAN
>、<SPAN
CLASS="QUOTE"
>"trigger"</SPAN
>以及<SPAN
CLASS="QUOTE"
>"window"</SPAN
>。如果要只显示指定类型的函数，可以在该命令上增加相应的字母<TT
CLASS="LITERAL"
>a</TT
>、<TT
CLASS="LITERAL"
>n</TT
>、<TT
CLASS="LITERAL"
>t</TT
>或者<TT
CLASS="LITERAL"
>w</TT
>。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的函数。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。如果使用了<TT
CLASS="LITERAL"
>\df+</TT
>形式，则有关每个函数的额外信息也会被显示，包括易失性、并行安全性、拥有者、安全性分类、访问特权、语言、源代码和描述。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        如果要查找接收指定数据类型参数或者返回指定类型值的函数，可以使用分页器的搜索能力来滚动显示<TT
CLASS="LITERAL"
>\df</TT
>输出。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\dF[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>         列出文本搜索配置。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的配置。如果使用了<TT
CLASS="LITERAL"
>\dF+</TT
>形式，每种配置的完整描述也会被显示，包括底层的文本搜索解析器和用于每一种解析器记号类型的字典列表。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dFd[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>         列出文本搜索字典。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的字典。如果使用了<TT
CLASS="LITERAL"
>\dFd+</TT
>形式，有关每一种选中的字典的额外信息也会被显示，包括底层的文本搜索模板和选项值。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dFp[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>         列出文本搜索解析器。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的解析器。如果使用了<TT
CLASS="LITERAL"
>\dFp+</TT
>形式，每一种解析器的完整描述也会被显示，包括底层的函数和可识别的记号类型列表。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dFt[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>         列出文本搜索模板。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只显示名称匹配该模式的模板。如果使用了<TT
CLASS="LITERAL"
>\dFt+</TT
>形式，每一种模板有关的额外信息也会被显示，包括底层的函数名称。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dg[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出数据库角色（因为<SPAN
CLASS="QUOTE"
>"用户"</SPAN
>和<SPAN
CLASS="QUOTE"
>"组"</SPAN
>的概念已经被统一成<SPAN
CLASS="QUOTE"
>"角色"</SPAN
>，这个命令现在等价于<TT
CLASS="LITERAL"
>\du</TT
>）。默认情况下只会显示用户创建的角色，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统角色包括在内。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的那些角色。如果使用了<TT
CLASS="LITERAL"
>\dg+</TT
>形式，有关每种角色的额外信息也将被显示，当前这种形式会为角色增加显示注释。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dl</TT
></DT
><DD
><P
>        这是<TT
CLASS="COMMAND"
>\lo_list</TT
>的一个别名，它显示大对象的列表。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dL[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出过程语言。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的语言。默认情况下只会显示用户创建的语言，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。如果向命令名称追加<TT
CLASS="LITERAL"
>+</TT
>，则每一种语言会和它的调用处理器、验证器、访问特权以及它是否为系统对象一起列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dn[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出模式（名字空间）。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的模式。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。如果向命令名称追加<TT
CLASS="LITERAL"
>+</TT
>，每个对象会与它相关的权限及描述（如果有）一起被列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\do[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出操作符及其操作数和结果类型。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的操作符。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。如果向命令名称追加<TT
CLASS="LITERAL"
>+</TT
>，有关每个操作符的额外信息也将被显示，当前只包括底层函数的名称。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dO[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出排序规则。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的排序规则。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。如果向命令名称追加<TT
CLASS="LITERAL"
>+</TT
>，每个排序规则将和它相关的描述（如果有）一起被列出。注意只有可用于当前数据库编码的排序规则会被显示，因此在同一个安装下的不同数据库中执行此命令可能会得到不同的结果。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dp [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出表、视图和序列，包括与它们相关的访问特权。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的表、视图以及序列。
        </P
><P
>        <A
HREF="sql-grant.html"
>GRANT</A
>和<A
HREF="sql-revoke.html"
>REVOKE</A
>命令被用来设置访问特权。所显示的特权的含义在<A
HREF="sql-grant.html"
>GRANT</A
>中有介绍。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\drds [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>role-pattern</I
></TT
></A
> [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>database-pattern</I
></TT
></A
> ] ]</TT
></DT
><DD
><P
>        列出已定义的配置设置。这些设置可以是针对角色的、针对数据库的或者同时针对两者的。<TT
CLASS="REPLACEABLE"
><I
>role-pattern</I
></TT
>和<TT
CLASS="REPLACEABLE"
><I
>database-pattern</I
></TT
>分别被用来选择要列出的角色和数据库。如果省略它们或者指定了<TT
CLASS="LITERAL"
>*</TT
>，则会列出所有设置，分别会包括针对角色和针对数据库的设置。
        </P
><P
>        <A
HREF="sql-alterrole.html"
>ALTER ROLE</A
>以及<A
HREF="sql-alterdatabase.html"
>ALTER DATABASE</A
>命令可以用来定义一个角色以及一个数据库的配置设置。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dT[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出数据类型。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的类型。如果向命令名称追加<TT
CLASS="LITERAL"
>+</TT
>，每一种类型、其内部名称和尺寸、允许的值（如果是一种<TT
CLASS="TYPE"
>enum</TT
>类型）以及相关权限会被一同列出。默认情况下只会显示用户创建的对象，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统对象包括在内。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\du[S+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出数据库角色（因为<SPAN
CLASS="QUOTE"
>"用户"</SPAN
>和<SPAN
CLASS="QUOTE"
>"组"</SPAN
>的概念已经被统一成<SPAN
CLASS="QUOTE"
>"角色"</SPAN
>，这个命令现在等价于）。默认情况下只会显示用户创建的角色，提供一个模式或者<TT
CLASS="LITERAL"
>S</TT
>修饰符可以把系统角色包括在内。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的那些角色。如果使用了<TT
CLASS="LITERAL"
>\du+</TT
>形式，有关每一种角色的额外信息也会被显示，当前只会多显示角色的注释。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dx[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出已安装的扩展。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的那些扩展。如果使用了<TT
CLASS="LITERAL"
>\dx+</TT
>形式，所有属于每个匹配扩展的对象会被列出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\dy[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出事件触发器。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，只列出名称匹配该模式的事件触发器。如果在命令名称后面加上<TT
CLASS="LITERAL"
>+</TT
>，还会为每个列出的对象显示其相关的描述。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\e</TT
> or <TT
CLASS="LITERAL"
>\edit</TT
> <TT
CLASS="LITERAL"
> [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>line_number</I
></TT
> </SPAN
>] </TT
></DT
><DD
><P
>        如果指定了<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>，则会编辑该文件，并且在编辑器退出后，它的内容会被复制到查询缓冲区中。如果没有给出<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>，将会把当前的查询缓冲区复制到一个临时文件并且以同样的方式编辑该临时文件。
        </P
><P
>        新的查询缓冲区接下来将被重新根据<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的规则进行解析，这里整个缓冲区会被当做一个单一行处理（因此无法用这种方式制作脚本，如果需要做脚本请用<TT
CLASS="COMMAND"
>\i</TT
>）。这意味着如果查询以一个分号结束（或者包含一个分号），它会立即被执行。否则它将在查询缓冲区中等待，键入分号或者<TT
CLASS="LITERAL"
>\g</TT
>会把它发出，用<TT
CLASS="LITERAL"
>\r</TT
>则可以取消之。
        </P
><P
>        如果指定了一个行号，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将会把游标（注意不是服务器端的游标）定位到文件或者查询缓冲区的指定行上。注意如果给出了一个全是数字的参数，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>就会假定它是行号而不是文件名。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        关于如何配置以及自定义编辑器，请见<A
HREF="app-psql.html#APP-PSQL-ENVIRONMENT"
><I
>环境</I
></A
>。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\echo <TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
> [ ... ]</TT
></DT
><DD
><P
>        把参数打印到标准输出，参数之间用一个空格分隔，最后加上一个新行。这可以用来在脚本的输出中间混入信息，例如：
</P><PRE
CLASS="PROGRAMLISTING"
>=&gt; <KBD
CLASS="USERINPUT"
>\echo `date`</KBD
>
Tue Oct 26 21:40:57 CEST 1999</PRE
><P>
        如果第一个参数是一个没有加引号的<TT
CLASS="LITERAL"
>-n</TT
>，则不会加上最后的新行。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        如果使用<TT
CLASS="COMMAND"
>\o</TT
>命令来重定向查询的输出，你可能希望使用<TT
CLASS="COMMAND"
>\qecho</TT
>来取代这个命令。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\ef [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>function_description</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>  <TT
CLASS="REPLACEABLE"
><I
>line_number</I
></TT
> </SPAN
>] </SPAN
>] </TT
></DT
><DD
><P
>         这个命令会以一个<TT
CLASS="COMMAND"
>CREATE OR REPLACE FUNCTION</TT
>的形式取出并且编辑指定函数的定义。编辑的方式与<TT
CLASS="LITERAL"
>\edit</TT
>完全相同。在编辑器退出后，更新过的命令将在查询缓冲区中等待，可以键入分号或者<TT
CLASS="LITERAL"
>\g</TT
>把它发出，也可以用<TT
CLASS="LITERAL"
>\r</TT
>取消之。
        </P
><P
>         目标函数可以单独用名称或者用名称和参数（例如<TT
CLASS="LITERAL"
>foo(integer, text)</TT
>）来指定。如果有多于一个函数具有同样的名称，则必须给出参数的类型。
        </P
><P
>         如果没有指定函数，将会给出一个空白的<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>模板来编辑。
        </P
><P
>        如果指定了一个行号，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将把游标定位在该函数体的指定行上（注意函数体通常不是开始于文件的第一行）。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        有关如何配置和自定义编辑器可见<A
HREF="app-psql.html#APP-PSQL-ENVIRONMENT"
><I
>环境</I
></A
>。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\encoding [ <TT
CLASS="REPLACEABLE"
><I
>encoding</I
></TT
> ]</TT
></DT
><DD
><P
>        设置客户端字符集编码。如果没有参数，这个命令会显示当前的编码。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\errverbose</TT
></DT
><DD
><P
>        以最详细的程度重复最近的服务器错误消息，就好像<TT
CLASS="VARNAME"
>VERBOSITY</TT
>被设置为<TT
CLASS="LITERAL"
>verbose</TT
>妾<TT
CLASS="VARNAME"
>SHOW_CONTEXT</TT
>被设置为<TT
CLASS="LITERAL"
>always</TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\ev [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>view_name</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>  <TT
CLASS="REPLACEABLE"
><I
>line_number</I
></TT
> </SPAN
>] </SPAN
>] </TT
></DT
><DD
><P
>         这个命令会以一个<TT
CLASS="COMMAND"
>CREATE OR REPLACE VIEW</TT
>的形式取出并且编辑指定函数的定义。编辑的方式与<TT
CLASS="LITERAL"
>\edit</TT
>完全相同。在编辑器退出后，更新过的命令将在查询缓冲区中等待，可以键入分号或者<TT
CLASS="LITERAL"
>\g</TT
>把它发出，也可以用<TT
CLASS="LITERAL"
>\r</TT
>取消之。
        </P
><P
>         如果没有指定函数，将会给出一个空白的<TT
CLASS="COMMAND"
>CREATE VIEW</TT
>模板来编辑。
        </P
><P
>         如果指定了一个行号，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将把游标定位在该视图定义的指定行上。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\f [ <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> ]</TT
></DT
><DD
><P
>        设置用于非对齐查询输出的域分隔符。默认值是竖线（<TT
CLASS="LITERAL"
>|</TT
>）。还可以参见用于设置输出选项的一般方法<TT
CLASS="COMMAND"
>\pset</TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\g [ <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> ]</TT
><BR><TT
CLASS="LITERAL"
>\g [ |<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> ]</TT
></DT
><DD
><P
>        把当前查询输入缓冲区发送到服务器，并且根据选择把查询的输出存储在<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>或者把输出用管道导向 shell 命令<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>。只有该查询成功地返回零个或者更多元组时才会向文件或者命令写入，而查询失败或者不是返回数据的 SQL 命令时则不会写入。
        </P
><P
>        一个裸的<TT
CLASS="LITERAL"
>\g</TT
>实质上等价于一个分号。带有参数的<TT
CLASS="LITERAL"
>\g</TT
>是<TT
CLASS="COMMAND"
>\o</TT
>命令的一个<SPAN
CLASS="QUOTE"
>"一次性的"</SPAN
>替换方案。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\gexec</TT
></DT
><DD
><P
>         把当前查询输入缓冲区发送到服务器，然后该查询输出（如果有）中的每一行的每一列都当作一个要被执行的 SQL 语句。例如，要在<TT
CLASS="STRUCTNAME"
>my_table</TT
>的每一列上都创建一个索引：
</P><PRE
CLASS="PROGRAMLISTING"
>=&gt; <KBD
CLASS="USERINPUT"
>SELECT format('create index on my_table(%I)', attname)</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>FROM pg_attribute</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>WHERE attrelid = 'my_table'::regclass AND attnum &gt; 0</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>ORDER BY attnum</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>\gexec</KBD
>
CREATE INDEX
CREATE INDEX
CREATE INDEX
CREATE INDEX</PRE
><P>
        </P
><P
>         产生的查询会按照其所在行被返回的顺序执行，如果有多个列，则同一行中按照从左至右的顺序执行。NULL 域会被忽略。产生的查询会被原样发送给服务器处理，因此它们即不能是<SPAN
CLASS="APPLICATION"
>psql</SPAN
>元命令，也不能包含<SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量引用。如果其中任何一个查询失败，剩余查询的执行将会继续，除非设置了<TT
CLASS="VARNAME"
>ON_ERROR_STOP</TT
>。每个查询的执行都遵照<TT
CLASS="VARNAME"
>ECHO</TT
>的处理（在使用<TT
CLASS="COMMAND"
>\gexec</TT
>时，通常建议设置<TT
CLASS="VARNAME"
>ECHO</TT
>为<TT
CLASS="LITERAL"
>all</TT
>或者<TT
CLASS="LITERAL"
>queries</TT
>）。查询日志、单步模式、计时以及其他查询执行特性也适用于每一个生成的查询。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\gset [ <TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
> ]</TT
></DT
><DD
><P
>         把当前查询输入缓冲区发送给服务器并且将查询的输出存储在<SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量中（见<A
HREF="app-psql.html#APP-PSQL-VARIABLES"
><I
>变量</I
></A
>）。被执行的查询必须只返回一行。该行的每一列会被存储到一个单独的变量中，变量和该列的名字一样。例如：
</P><PRE
CLASS="PROGRAMLISTING"
>=&gt; <KBD
CLASS="USERINPUT"
>SELECT 'hello' AS var1, 10 AS var2</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>\gset</KBD
>
=&gt; <KBD
CLASS="USERINPUT"
>\echo :var1 :var2</KBD
>
hello 10</PRE
><P>
        </P
><P
>         如果指定了一个<TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>，那么该字符串会被追加在该查询的输出列名称之前用来创建要使用的变量名：
</P><PRE
CLASS="PROGRAMLISTING"
>=&gt; <KBD
CLASS="USERINPUT"
>SELECT 'hello' AS var1, 10 AS var2</KBD
>
-&gt; <KBD
CLASS="USERINPUT"
>\gset result_</KBD
>
=&gt; <KBD
CLASS="USERINPUT"
>\echo :result_var1 :result_var2</KBD
>
hello 10</PRE
><P>
        </P
><P
>         如果一个列的结果为 NULL，那么对应的变量会被重置而不是被设置。
        </P
><P
>         如果查询失败或者没有返回一行，则不会有任何变量被更改。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\h</TT
> or <TT
CLASS="LITERAL"
>\help</TT
> <TT
CLASS="LITERAL"
>[ <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> ]</TT
></DT
><DD
><P
>        给出指定<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令的语法帮助。如果没有指定<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>，则<SPAN
CLASS="APPLICATION"
>psql</SPAN
>会列出可以显示语法帮助的所有命令。如果<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>是一个星号（<TT
CLASS="LITERAL"
>*</TT
>），则会显示所有<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令的语法帮助。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        为了简化输入，由几个词构成的命令不需要被加上引号。因此，键入<KBD
CLASS="USERINPUT"
>\help alter table</KBD
>是可以的。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\H</TT
> or <TT
CLASS="LITERAL"
>\html</TT
></DT
><DD
><P
>        开启<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>查询输出格式。如果<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>格式已经开启，这会把它切换回默认的对齐文本格式。这个命令是为了兼容性和方便，有关设置其他输出选项请见<TT
CLASS="COMMAND"
>\pset</TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\i</TT
> or <TT
CLASS="LITERAL"
>\include</TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></DT
><DD
><P
>        从文件<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>读取输入并且把它当作从键盘输入的命令来执行。
        </P
><P
>        如果<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>是<TT
CLASS="LITERAL"
>-</TT
>（连字符），那么会一直读取标准输入直到碰到一个 EOF 指示符或者<TT
CLASS="COMMAND"
>\q</TT
>元命令。这可以用来把交互式输入与文件输入混杂。注意只有在最外层激活了 readline 行为的情况下才将会使用 readline 行为。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        如果想在屏幕上看到被读入的行，必须把变量<TT
CLASS="VARNAME"
>ECHO</TT
>设置成<TT
CLASS="LITERAL"
>all</TT
>。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\ir</TT
> or <TT
CLASS="LITERAL"
>\include_relative</TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></DT
><DD
><P
>        <TT
CLASS="LITERAL"
>\ir</TT
>命令类似于<TT
CLASS="LITERAL"
>\i</TT
>，但是以不同的方式处理相对路径文件名。在交互模式中执行时，这两个命令的行为相同。不过，当被从脚本中调用时，<TT
CLASS="LITERAL"
>\ir</TT
>相对于脚本所在的目录而不是根据当前工作目录来解释文件名。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\l[+]</TT
> or <TT
CLASS="LITERAL"
>\list[+] [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出服务器中的数据库并且显示它们的名称、拥有者、字符集编码以及访问特权。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，则只列出名称匹配该模式的数据库。如果向命令名称追加<TT
CLASS="LITERAL"
>+</TT
>，则还会显示数据库的尺寸、默认表空间以及描述（尺寸信息只对当前用户能连接的数据库可用）。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_export <TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></TT
></DT
><DD
><P
>        从数据库中读取具有<ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
> <TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
>的大对象并且将它写入到<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>。注意这和服务器函数<CODE
CLASS="FUNCTION"
>lo_export</CODE
>有微妙的不同，后者会以运行数据库服务器的用户权限来执行并且运行在服务器的文件系统上。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        使用<TT
CLASS="COMMAND"
>\lo_list</TT
>可以找出大对象的<ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
>。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_import <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>comment</I
></TT
> ]</TT
></DT
><DD
><P
>        把该文件存储到<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>大对象。可选地，它可以把给定的注释关联到该对象。例如：
</P><PRE
CLASS="PROGRAMLISTING"
>foo=&gt; <KBD
CLASS="USERINPUT"
>\lo_import '/home/peter/pictures/photo.xcf' 'a picture of me'</KBD
>
lo_import 152801</PRE
><P>
        该响应表示该大对象得到的对象 ID 是 152801，未来可以用这个 ID 来访问这个新创建的大对象。为了便于阅读，推荐总是给每一个对象都关联人类可读的注释。OID 和注释都可以用<TT
CLASS="COMMAND"
>\lo_list</TT
>命令查看。
        </P
><P
>        注意这个命令和服务器端的<CODE
CLASS="FUNCTION"
>lo_import</CODE
>有微妙的不同，因为它以本地文件系统上的本地用户的身份运行，而不是服务器用户和文件系统。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_list</TT
></DT
><DD
><P
>        显示当前存储在数据库中的所有<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>大对象，同时显示它们的任何注释。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\lo_unlink <TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
></TT
></DT
><DD
><P
>        从数据库中删除<ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
>为<TT
CLASS="REPLACEABLE"
><I
>loid</I
></TT
>的大对象。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        使用<TT
CLASS="COMMAND"
>\lo_list</TT
>可以找出该大对象的<ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
>。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\o</TT
> or <TT
CLASS="LITERAL"
>\out [ <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> ]</TT
><BR><TT
CLASS="LITERAL"
>\o</TT
> or <TT
CLASS="LITERAL"
>\out [ |<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> ]</TT
></DT
><DD
><P
>        安排把未来的查询结果保存到文件<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>中或者用管道导向到 shell 命令<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>。如果没有指定参数，查询输出会被重置到标准输出。
        </P
><P
><SPAN
CLASS="QUOTE"
>"查询结果"</SPAN
>包括从数据库服务器得到的所有表、命令响应和提示，还有查询数据库的各种反斜线命令（如<TT
CLASS="COMMAND"
>\d</TT
>）的输出，但不包括错误消息。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        要在查询结果之间混入文本输出，可以使用<TT
CLASS="COMMAND"
>\qecho</TT
>。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\p</TT
> or <TT
CLASS="LITERAL"
>\print</TT
></DT
><DD
><P
>        把当前查询缓冲区打印到标准输出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\password [ <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
> ]</TT
></DT
><DD
><P
>        更改指定用户（默认情况下是当前用户）的口令。这个命令会提示要求输入新口令、对口令加密然后把加密后的口令作为一个<TT
CLASS="COMMAND"
>ALTER ROLE</TT
>命令发送到服务器。这确保新口令不会以明文的形式出现在命令历史、服务器日志或者其他地方。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\prompt [ <TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
></DT
><DD
><P
>         提示用户提供一个文本用于分配给变量<TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>。可以指定一个可选的提示字符串<TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
>（对于多个词组成的提示，把文本包裹在单引号中）。
        </P
><P
>         默认情况下，<TT
CLASS="LITERAL"
>\prompt</TT
>使用终端进行输入和输出。不过，如果使用了<TT
CLASS="OPTION"
>-f</TT
>命令行开关，<TT
CLASS="LITERAL"
>\prompt</TT
>会使用标准输入和标准输出。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\pset [ <TT
CLASS="REPLACEABLE"
><I
>option</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> ] ]</TT
></DT
><DD
><P
>        这个命令设置影响查询结果表输出的选项。<TT
CLASS="REPLACEABLE"
><I
>option</I
></TT
>表示要设置哪个选项。<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>的语义取决于选中的选项。对于某些选项，如果省略<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>会导致该选项值被切换或者被重置，具体是哪些选项可见特定选项的描述。如果没有上面提到的那种行为，那么省略<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>只会导致当前设置被显示。
        </P
><P
>        不带任何参数的<TT
CLASS="COMMAND"
>\pset</TT
>显示所有打印选项的当前状态。
        </P
><P
>        可调整的打印选项有：
        <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>border</TT
></DT
><DD
><P
>          <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>必须是一个数字。通常，数字越大，表格就会有更多的边框和线条，但具体要看是哪一种格式。在<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>格式中，这会直接被转换成<TT
CLASS="LITERAL"
>border=...</TT
>属性。在大部分其他格式中，只有值 0（没有边框）、1（内部分隔线）和 2（表格边框）有意义，并且 2 以上的值会被视为与<TT
CLASS="LITERAL"
>border = 2</TT
>相同。<TT
CLASS="LITERAL"
>latex</TT
>和<TT
CLASS="LITERAL"
>latex-longtable</TT
>格式会额外地允许一个值 3 表示在数据行之间增加分隔线。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>columns</TT
></DT
><DD
><P
>          为<TT
CLASS="LITERAL"
>wrapped</TT
>格式设置目标宽度，还有扩展自动模式中决定输出是否足够多到需要分页器或者切换到垂直显示的宽度限制。零（默认）导致目标宽度由环境变量<TT
CLASS="ENVAR"
>COLUMNS</TT
>所控制，如果没有设置<TT
CLASS="ENVAR"
>COLUMNS</TT
>则使用检测到的屏幕宽度。此外，如果<TT
CLASS="LITERAL"
>columns</TT
>为零则<TT
CLASS="LITERAL"
>wrapped</TT
>格式只影响屏幕输出。如果<TT
CLASS="LITERAL"
>columns</TT
>为非零则文件和管道输出也会被包裹成该宽度。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>expanded</TT
> (or <TT
CLASS="LITERAL"
>x</TT
>)</DT
><DD
><P
>          如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被指定，它必须是<TT
CLASS="LITERAL"
>on</TT
>或者<TT
CLASS="LITERAL"
>off</TT
>，它们分别会启用或者禁用扩展模式，也可以是<TT
CLASS="LITERAL"
>auto</TT
>。如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被省略，则该命令会在开启和关闭设置之间切换。当扩展模式被启用时，查询结果被显示在两列中，第一列是列名而第二列是列值。如果在通常的<SPAN
CLASS="QUOTE"
>"水平"</SPAN
>模式中数据不适合屏幕，则可以用这种模式。在自动设置中，只要查询输出有多于一列并且比屏幕宽，就会使用扩展模式。否则，将使用常规模式。只有在对齐格式和 wrapped 格式中自动设置才有效。在其他格式中，它的行为总是像扩展模式被关闭一样。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>fieldsep</TT
></DT
><DD
><P
>          指定在非对齐输出格式中使用的域分隔符。用那种方式，用户可以创建 tab 或者逗号分隔的输出，这种形式其他程序可能更喜欢。要设置 tab 为域分隔符，可以键入<TT
CLASS="LITERAL"
>\pset fieldsep '\t'</TT
>。默认的域分隔符是<TT
CLASS="LITERAL"
>'|'</TT
>（一个竖线）。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>fieldsep_zero</TT
></DT
><DD
><P
>          把用在非对齐输出格式中的域分隔符设置为一个零字节。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>footer</TT
></DT
><DD
><P
>          如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被指定，它必须是<TT
CLASS="LITERAL"
>on</TT
>或者<TT
CLASS="LITERAL"
>off</TT
>，它们分别会启用或者禁用表格页脚（<TT
CLASS="LITERAL"
>(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> rows)</TT
>计数）的显示。如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被省略，则该命令会切换页脚显示为打开或者关闭。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>format</TT
></DT
><DD
><P
>          设置输出格式为<TT
CLASS="LITERAL"
>unaligned</TT
>、<TT
CLASS="LITERAL"
>aligned</TT
>、<TT
CLASS="LITERAL"
>wrapped</TT
>、<TT
CLASS="LITERAL"
>html</TT
>、<TT
CLASS="LITERAL"
>asciidoc</TT
>、<TT
CLASS="LITERAL"
>latex</TT
>（使用<TT
CLASS="LITERAL"
>tabular</TT
>）、<TT
CLASS="LITERAL"
>latex-longtable</TT
>或者<TT
CLASS="LITERAL"
>troff-ms</TT
>之一。也可以使用不造成歧义的缩写（这意味着一个字母就够了）。
          </P
><P
><TT
CLASS="LITERAL"
>unaligned</TT
>格式把一个数据行的所有列都写在一行上，之间用当前活动的域分隔符分隔。这可用于生成意图由其他程序读取的输出（例如，tab 分隔或者逗号分隔格式）。
          </P
><P
><TT
CLASS="LITERAL"
>aligned</TT
>格式是标准的、人类可读的、格式化好的文本输出，这是默认格式。
          </P
><P
><TT
CLASS="LITERAL"
>wrapped</TT
>格式和<TT
CLASS="LITERAL"
>aligned</TT
>相似，但是前者会把过宽的数据值分成多个行以便输出能够适合目标行的宽度。目标行的宽度由<TT
CLASS="LITERAL"
>columns</TT
>选项决定。注意<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将不会尝试对列头部标题进行换行，因此如果列头部需要的总宽度超过目标宽度，<TT
CLASS="LITERAL"
>wrapped</TT
>格式的行为就变得和<TT
CLASS="LITERAL"
>aligned</TT
>一样了。
          </P
><P
>          <TT
CLASS="LITERAL"
>html</TT
>、<TT
CLASS="LITERAL"
>asciidoc</TT
>、<TT
CLASS="LITERAL"
>latex</TT
>、<TT
CLASS="LITERAL"
>latex-longtable</TT
>和<TT
CLASS="LITERAL"
>troff-ms</TT
>格式分别用相应的标记语言把要输出的表格放在文档中，不过它们的输出并不是完整的文档。在<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>中这可能并不重要，但是在<SPAN
CLASS="APPLICATION"
>LaTeX</SPAN
>中必须有完整的文档。<TT
CLASS="LITERAL"
>latex-longtable</TT
>还要求有<SPAN
CLASS="APPLICATION"
>LaTeX</SPAN
>的<TT
CLASS="LITERAL"
>longtable</TT
>以及<TT
CLASS="LITERAL"
>booktabs</TT
>包。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>linestyle</TT
></DT
><DD
><P
>          设置边框线的绘制样式为<TT
CLASS="LITERAL"
>ascii</TT
>、<TT
CLASS="LITERAL"
>old-ascii</TT
>或者<TT
CLASS="LITERAL"
>unicode</TT
>之一。允许不产生歧义的缩写（这意味着一个字母就足够了）。默认的设置是<TT
CLASS="LITERAL"
>ascii</TT
>。这个选项只影响<TT
CLASS="LITERAL"
>aligned</TT
>以及<TT
CLASS="LITERAL"
>wrapped</TT
>输出格式。
          </P
><P
><TT
CLASS="LITERAL"
>ascii</TT
>样式使用纯<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>字符。数据中的新行使用一个<TT
CLASS="LITERAL"
>+</TT
>符号在右手边的空白处显示。当在<TT
CLASS="LITERAL"
>wrapped</TT
>格式中包裹两行中间没有新行字符的数据时，会在第一行右手边空白处显示一个点号（<TT
CLASS="LITERAL"
>.</TT
>），并且在下一行的左手边空白处也显示一个点号（<TT
CLASS="LITERAL"
>.</TT
>）。
          </P
><P
><TT
CLASS="LITERAL"
>old-ascii</TT
>样式使用纯<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>字符，使用<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.4 及更早版本中用过的格式化样式。数据中的新行使用<TT
CLASS="LITERAL"
>:</TT
>符号来代替左手边的列分隔符显示。在包裹两行中间没有新行字符的数据时，会用一个<TT
CLASS="LITERAL"
>;</TT
>符号取代左手边的列分隔符。
          </P
><P
><TT
CLASS="LITERAL"
>unicode</TT
>样式使用 Unicode 的方框绘制字符。数据中的新行会使用一个回车符号显示在右手边的空白处。在包裹两行中间没有新行字符的数据时，会在第一行的右手边空白处显示一个省略号，并且在下一行的左手边空白处也显示一个省略号。
          </P
><P
>          当<TT
CLASS="LITERAL"
>border</TT
>设置大于零时，<TT
CLASS="LITERAL"
>linestyle</TT
>选项也决定边框线用什么字符绘制。纯<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>字符到处都可以使用，但是在识别 Unicode 字符的显示上使用 Unicode 字符会更好看。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>null</TT
></DT
><DD
><P
>          设置要用来替代空值被打印的字符串。默认是什么也不打印，对于一个空字符串这很容易弄错。例如，有人可能更想用<TT
CLASS="LITERAL"
>\pset null '(null)'</TT
>。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>numericlocale</TT
></DT
><DD
><P
>          如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被指定，它必须是<TT
CLASS="LITERAL"
>on</TT
>或者<TT
CLASS="LITERAL"
>off</TT
>，它们将分别启用或者禁用一个与区域相关的字符来分隔数字和左边的十进制标记。如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被省略，该命令会在常规输出和区域相关的数字输出之间切换。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>pager</TT
></DT
><DD
><P
>          控制对查询和<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的帮助输出使用分页器程序。如果环境变量<TT
CLASS="ENVAR"
>PAGER</TT
>被设置，输出会被用管道输送到指定的程序。否则将使用与平台相关的默认分页器程序（例如<TT
CLASS="FILENAME"
>more</TT
>）。
          </P
><P
>          如果<TT
CLASS="LITERAL"
>pager</TT
>选项被设为<TT
CLASS="LITERAL"
>off</TT
>，则不会使用分页器程序。如果<TT
CLASS="LITERAL"
>pager</TT
>选项被设为<TT
CLASS="LITERAL"
>on</TT
>，则会在适当的时候使用分页器，即当输出到终端并且无法适合屏幕时就会使用分页器。<TT
CLASS="LITERAL"
>pager</TT
>选项也可以被设置为<TT
CLASS="LITERAL"
>always</TT
>，这会导致对所有的终端输出都是用分页器而不管输出是否适合屏幕。不带<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>的<TT
CLASS="LITERAL"
>\pset pager</TT
>会切换分页器开、关状态。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>pager_min_lines</TT
></DT
><DD
><P
>          如果<TT
CLASS="LITERAL"
>pager_min_lines</TT
>被设置为一个大于页面高度的数字，在至少这么多输出行被显示之前都不会调用分页器程序。默认设置为 0。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>recordsep</TT
></DT
><DD
><P
>          指定用在非对齐输出格式中的记录（行）分隔符。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>recordsep_zero</TT
></DT
><DD
><P
>          把用在非对齐输出格式中的记录分隔符设置为一个零字节。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>tableattr</TT
> (or <TT
CLASS="LITERAL"
>T</TT
>)</DT
><DD
><P
>          在<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>格式中，这会指定要放在<CODE
CLASS="SGMLTAG"
>table</CODE
>标记内的属性。例如，这可能是<TT
CLASS="LITERAL"
>cellpadding</TT
>或者<TT
CLASS="LITERAL"
>bgcolor</TT
>。注意你可能不想在这里指定<TT
CLASS="LITERAL"
>border</TT
>，因为那由<TT
CLASS="LITERAL"
>\pset border</TT
>负责。如果没有给出<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>，则表属性会被重置。
          </P
><P
>          在<TT
CLASS="LITERAL"
>latex-longtable</TT
>格式中，这个选项控制每个包含左对齐数据类型的列的宽度比例。这个选项的值是一个由空格分隔的值列表，例如<TT
CLASS="LITERAL"
>'0.2 0.2 0.6'</TT
>。没有指定的输出列会使用最后一个指定的值。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>title</TT
> (or <TT
CLASS="LITERAL"
>C</TT
>)</DT
><DD
><P
>          设置用于任何后续被打印表的表标题。这可以用来给输出加上描述性的标签。如果没有给出<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>，这个标题会被复原。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>tuples_only</TT
> (or <TT
CLASS="LITERAL"
>t</TT
>)</DT
><DD
><P
>          如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被指定，它必须是<TT
CLASS="LITERAL"
>on</TT
>或者<TT
CLASS="LITERAL"
>off</TT
>，这个选项将启用或者禁用只显示元组的模式。如果<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>被省略，则该命令会在常规输出和只显示元组输出之间切换。常规输出包括列头、标题以及多种页脚之类的额外信息。在只显示元组的模式中，只会显示实际的表数据。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>unicode_border_linestyle</TT
></DT
><DD
><P
>          设置<TT
CLASS="LITERAL"
>unicode</TT
>线型的边框绘制风格为<TT
CLASS="LITERAL"
>single</TT
>或者<TT
CLASS="LITERAL"
>double</TT
>之一。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>unicode_column_linestyle</TT
></DT
><DD
><P
>          设置<TT
CLASS="LITERAL"
>unicode</TT
>线型的列绘制风格为<TT
CLASS="LITERAL"
>single</TT
>或者<TT
CLASS="LITERAL"
>double</TT
>之一。
          </P
></DD
><DT
><TT
CLASS="LITERAL"
>unicode_header_linestyle</TT
></DT
><DD
><P
>          设置<TT
CLASS="LITERAL"
>unicode</TT
>线型的页眉绘制风格为<TT
CLASS="LITERAL"
>single</TT
>或者<TT
CLASS="LITERAL"
>double</TT
>之一。
          </P
></DD
></DL
></DIV
><P>
        </P
><P
>        这些不同格式的外观可以在<A
HREF="app-psql.html#APP-PSQL-EXAMPLES"
><I
>示例</I
></A
>小节的图示中看到。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        <TT
CLASS="COMMAND"
>\pset</TT
>有多种快捷命令。请参见<TT
CLASS="COMMAND"
>\a</TT
>、<TT
CLASS="COMMAND"
>\C</TT
>、<TT
CLASS="COMMAND"
>\H</TT
>、<TT
CLASS="COMMAND"
>\t</TT
>、<TT
CLASS="COMMAND"
>\T</TT
>以及<TT
CLASS="COMMAND"
>\x</TT
>。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\q</TT
> or <TT
CLASS="LITERAL"
>\quit</TT
></DT
><DD
><P
>        退出<SPAN
CLASS="APPLICATION"
>psql</SPAN
>程序。在一个脚本文件中，只有该脚本的执行会被终止。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\qecho <TT
CLASS="REPLACEABLE"
><I
>text</I
></TT
> [ ... ] </TT
></DT
><DD
><P
>        这个命令和<TT
CLASS="COMMAND"
>\echo</TT
>一样，不过输出将被写到<TT
CLASS="COMMAND"
>\o</TT
>所设置的查询输出通道。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\r</TT
> or <TT
CLASS="LITERAL"
>\reset</TT
></DT
><DD
><P
>        重置（清除）查询缓冲区。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\s [ <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
> ]</TT
></DT
><DD
><P
>        打印<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的命令行历史到<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>。如果省略<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>，该历史会被写入到标准输出（如果适用则使用分页器）。如果编译<SPAN
CLASS="APPLICATION"
>psql</SPAN
>时没有加上<SPAN
CLASS="APPLICATION"
>Readline</SPAN
>支持，则这个命令不可用。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\set [ <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [ ... ] ] ]</TT
></DT
><DD
><P
>        设置<SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量<TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>为<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>，如果给出了多于一个值，则把该变量的值设置为所有给出的值的串接。如果只给了一个参数，会用一个空值设置该变量。要重置一个变量，可以使用<TT
CLASS="COMMAND"
>\unset</TT
> 命令。
        </P
><P
>不带任何参数的<TT
CLASS="COMMAND"
>\set</TT
>显示所有当前设置的<SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量的名称和值。
        </P
><P
>        合法的变量名可以包含字母、数字和下划线。详见下文的<A
HREF="app-psql.html#APP-PSQL-VARIABLES"
><I
>变量</I
></A
>。变量名是大小写敏感的。
        </P
><P
>        尽管可以自由地把任意变量设置为任意的值，但是有几个变量会受到<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的特殊对待。在有关变量的小节中有介绍。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        这个命令和<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令<A
HREF="sql-set.html"
>SET</A
>无关。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>\setenv <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> ]</TT
></DT
><DD
><P
>        把环境变量<TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>设置为<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>，如果没有提供<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>，则会重置该环境变量。例如：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\setenv PAGER less</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>\setenv LESS -imx4F</KBD
></PRE
><P></P
></DD
><DT
><TT
CLASS="LITERAL"
>\sf[+] <TT
CLASS="REPLACEABLE"
><I
>function_description</I
></TT
> </TT
></DT
><DD
><P
>         这个命令以一个<TT
CLASS="COMMAND"
>CREATE OR REPLACE FUNCTION</TT
>命令取出并且显示指定函数的定义。定义会被打印到当前的查询输出渠道，就像<TT
CLASS="COMMAND"
>\o</TT
>所作的那样。
        </P
><P
>         目标函数可以单独用名称指定，也可以用名称和参数指定，例如<TT
CLASS="LITERAL"
>foo(integer, text)</TT
>。如果有多于一个函数具有相同的名字，则必须给出参数的类型。
        </P
><P
>         如果向命令名称追加<TT
CLASS="LITERAL"
>+</TT
>，那么输出行会被编号，函数体的第一行会被编为 1。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\sv[+] <TT
CLASS="REPLACEABLE"
><I
>view_name</I
></TT
> </TT
></DT
><DD
><P
>          这个命令以一个<TT
CLASS="COMMAND"
>CREATE OR REPLACE VIEW</TT
>命令取出并且显示指定视图的定义。定义会被打印到当前的查询输出渠道，就像<TT
CLASS="COMMAND"
>\o</TT
>所作的那样。
         </P
><P
>          如果在命令名称上追加<TT
CLASS="LITERAL"
>+</TT
>，那么输出行会从 1 开始编号。
         </P
></DD
><DT
><TT
CLASS="LITERAL"
>\t</TT
></DT
><DD
><P
>        切换输出列名标题和行计数页脚的显示。这个命令等效于<TT
CLASS="LITERAL"
>\pset tuples_only</TT
>，提供它只是为了使用方便而已。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\T <TT
CLASS="REPLACEABLE"
><I
>table_options</I
></TT
></TT
></DT
><DD
><P
>        指定在<ACRONYM
CLASS="ACRONYM"
>HTML</ACRONYM
>输出格式中，要放在<CODE
CLASS="SGMLTAG"
>table</CODE
>标签内的属性。这个命令等效于<TT
CLASS="LITERAL"
>\pset tableattr <TT
CLASS="REPLACEABLE"
><I
>table_options</I
></TT
></TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\timing [ <TT
CLASS="REPLACEABLE"
><I
>on</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>off</I
></TT
> ]</TT
></DT
><DD
><P
>         如果不带参数，则打开/关闭显示每个 SQL 语句花费的时间（以毫秒为单位）。如果有参数，参数是<TT
CLASS="REPLACEABLE"
><I
>on</I
></TT
>则打开显示，否则关闭显示。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\unset <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
></DT
><DD
><P
>        重置（删除）<SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量<TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\w</TT
> or <TT
CLASS="LITERAL"
>\write</TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
><BR><TT
CLASS="LITERAL"
>\w</TT
> or <TT
CLASS="LITERAL"
>\write</TT
> <TT
CLASS="LITERAL"
>|</TT
><TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
></DT
><DD
><P
>        把当前查询缓冲区输出到文件<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>或者用管道导出到 shell 命令<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\watch [ <TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
> ]</TT
></DT
><DD
><P
>        反复执行当前的查询缓冲区（就像<TT
CLASS="LITERAL"
>\g</TT
>那样）直到被中止或者查询失败。两次执行之间等待指定的秒数（默认是 2 秒）。显示每个查询结果时带上一个由<TT
CLASS="LITERAL"
>\pset title</TT
>字符串（如果有）、从查询开始起的时间以及延时间隔组成的页眉。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\x [ <TT
CLASS="REPLACEABLE"
><I
>on</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>off</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>auto</I
></TT
> ]</TT
></DT
><DD
><P
>        设置或者切换扩展表格格式化模式。究其本身而言，这个命令等效于<TT
CLASS="LITERAL"
>\pset expanded</TT
>。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>\z [ <A
HREF="app-psql.html#APP-PSQL-PATTERNS"
><TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
></A
> ]</TT
></DT
><DD
><P
>        列出表、视图和序列，以及它们相关的访问特权。如果指定了<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>，则只会列出名称匹配该模式的表、视图和序列。
        </P
><P
>        这是<TT
CLASS="COMMAND"
>\dp</TT
>（<SPAN
CLASS="QUOTE"
>"display privileges"</SPAN
>）的一个别名。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\! [ <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> ]</TT
></DT
><DD
><P
>        跳到一个单独的 shell 或者执行 shell 命令<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>。参数不会被进一步解释，shell 将会原封不动地看到参数。特别要说明的是，变量替换规则和反斜线转义在这里不适用。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>\? [ <TT
CLASS="REPLACEABLE"
><I
>topic</I
></TT
> ]</TT
></DT
><DD
><P
>        显示帮助信息。可选的<TT
CLASS="REPLACEABLE"
><I
>topic</I
></TT
>参数（默认是<TT
CLASS="LITERAL"
>commands</TT
>）选择解释<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的哪一部分：<TT
CLASS="LITERAL"
>commands</TT
>表示<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的反斜线命令；<TT
CLASS="LITERAL"
>options</TT
>表示可以传递给<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的命令行选项；而<TT
CLASS="LITERAL"
>variables</TT
>显示有关<SPAN
CLASS="APPLICATION"
>psql</SPAN
>配置变量的帮助。
        </P
></DD
></DL
></DIV
><P>
  </P
><DIV
CLASS="REFSECT3"
><A
NAME="APP-PSQL-PATTERNS"
></A
><H4
>模式（Pattern）</H4
><P
>   很多<TT
CLASS="LITERAL"
>\d</TT
>命令都可以用一个<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>参数来指定要被显示的对象名称。在最简单的情况下，模式正好就是该对象的准确名称。在模式中的字符通常会被变成小写形式（就像在 SQL 名称中那样），例如<TT
CLASS="LITERAL"
>\dt FOO</TT
>将会显示名为<TT
CLASS="LITERAL"
>foo</TT
>的表。就像在 SQL 名称中那样，把模式放在双引号中可以阻止它被转换成小写形式。如果需要在一个模式中包括一个真正的双引号字符，则需要把它写成两个相邻的双引号，这同样是符合 SQL 引用标识符的规则。例如，<TT
CLASS="LITERAL"
>\dt "FOO""BAR"</TT
>将显示名为<TT
CLASS="LITERAL"
>FOO"BAR</TT
>（不是<TT
CLASS="LITERAL"
>foo"bar</TT
>）的表。和普通的 SQL 名称规则不同，你不能只在模式的一部分周围放上双引号，例如<TT
CLASS="LITERAL"
>\dt FOO"FOO"BAR</TT
>将会显示名为<TT
CLASS="LITERAL"
>fooFOObar</TT
>的表。
  </P
><P
>   只要<TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>参数被完全省略，<TT
CLASS="LITERAL"
>\d</TT
>命令会显示在当前 schema 搜索路径中可见的全部对象 &mdash; 这等价于用<TT
CLASS="LITERAL"
>*</TT
>作为模式（如果一个对象所在的 schema 位于搜索路径中并且没有同类且同名的对象出现在搜索路径中该 schema 之前的 schema 中，则说该对象是<I
CLASS="FIRSTTERM"
>可见</I
>的。这表示可以直接用名称引用该对象，而不需要用 schema 来进行限定）。要查看数据库中所有的对象而不管它们的可见性，可以把<TT
CLASS="LITERAL"
>*.*</TT
>用作模式。
  </P
><P
>   如果放在一个模式中，<TT
CLASS="LITERAL"
>*</TT
>将匹配任意字符序列（包括空序列），而<TT
CLASS="LITERAL"
>?</TT
>会匹配任意的单个字符（这种记号方法就像 Unix shell 的文件名模式一样）。例如，<TT
CLASS="LITERAL"
>\dt int*</TT
>会显示名称以<TT
CLASS="LITERAL"
>int</TT
>开始的表。但是如果被放在双引号内，<TT
CLASS="LITERAL"
>*</TT
>和<TT
CLASS="LITERAL"
>?</TT
>就会失去这些特殊含义而变成普通的字符。
  </P
><P
>   包含一个点号（<TT
CLASS="LITERAL"
>.</TT
>）的模式被解释为一个 schema 名称模式后面跟上一个对象名称模式。例如，<TT
CLASS="LITERAL"
>\dt foo*.*bar*</TT
>会显示名称以<TT
CLASS="LITERAL"
>foo</TT
>开始的 schema 中所有名称包括<TT
CLASS="LITERAL"
>bar</TT
>的表。如果没有出现点号，那么模式将只匹配当前 schema 搜索路径中可见的对象。同样，双引号内的点号会失去其特殊含义并且变成普通的字符。
  </P
><P
>   高级用户可以使用字符类等正则表达式记法，如<TT
CLASS="LITERAL"
>[0-9]</TT
>可以匹配任意数字。所有的正则表达式特殊字符都按照<A
HREF="functions-matching.html#FUNCTIONS-POSIX-REGEXP"
>第 9.7.3 &#33410;</A
>所说的工作，以下字符除外：<TT
CLASS="LITERAL"
>.</TT
>会按照上面所说的作为一种分隔符，<TT
CLASS="LITERAL"
>*</TT
>会被翻译成正则表达式记号<TT
CLASS="LITERAL"
>.*</TT
>，<TT
CLASS="LITERAL"
>?</TT
>会被翻译成<TT
CLASS="LITERAL"
>.</TT
>，而<TT
CLASS="LITERAL"
>$</TT
>则按字面意思匹配。根据需要，可以通过书写<TT
CLASS="LITERAL"
>?</TT
>、<TT
CLASS="LITERAL"
>(<TT
CLASS="REPLACEABLE"
><I
>R</I
></TT
>+|)</TT
>、<TT
CLASS="LITERAL"
>(<TT
CLASS="REPLACEABLE"
><I
>R</I
></TT
>|)</TT
>和<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>R</I
></TT
>?</TT
>来分别模拟模式字符<TT
CLASS="LITERAL"
>.</TT
>、<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>R</I
></TT
>*</TT
>和<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>R</I
></TT
>?</TT
>。<TT
CLASS="LITERAL"
>$</TT
>不需要作为一个正则表达式字符，因为模式必须匹配整个名称，而不是像正则表达式的常规用法那样解释（换句话说，<TT
CLASS="LITERAL"
>$</TT
>会被自动地追加到模式上）。如果不希望该模式的匹配位置被固定，可以在开头或者结尾写上<TT
CLASS="LITERAL"
>*</TT
>。注意在双引号内，所有的正则表达式特殊字符会失去其特殊含义并且按照其字面意思进行匹配。还有，在操作符名称模式中（即作为<TT
CLASS="LITERAL"
>\do</TT
>的参数），正则表达式特殊字符也按照字面意思进行匹配。
  </P
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN100023"
></A
><H3
>高级特性</H3
><DIV
CLASS="REFSECT3"
><A
NAME="APP-PSQL-VARIABLES"
></A
><H4
>变量</H4
><P
>    <SPAN
CLASS="APPLICATION"
>psql</SPAN
>提供了和普通 Unix 命令 shell 相似的变量替换特性。变量简单来说就是一对名称/值，其中值可以是任意长度的任意字符串。名称必须由字母（包括非拉丁字母）、数字和下划线构成。
    </P
><P
>    要设置一个变量，可以使用<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的元命令<TT
CLASS="COMMAND"
>\set</TT
>。例如，
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\set foo bar</KBD
></PRE
><P>
    会设置<TT
CLASS="LITERAL"
>foo</TT
>为值<TT
CLASS="LITERAL"
>bar</TT
>。要检索该变量的内容，可以在名称前放一个分号，例如：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\echo :foo</KBD
>
bar</PRE
><P>
    这在常规 SQL 命令和元命令中均有效，下文的<A
HREF="app-psql.html#APP-PSQL-INTERPOLATION"
><I
><I
>SQL</I
> 中插入变量</I
></A
>中有更多细节。
    </P
><P
>    如果调用<TT
CLASS="COMMAND"
>\set</TT
>时没有第二个参数，会用一个空字符串作为值来设置该变量。要重置（即删除）一个变量，可以使用命令<TT
CLASS="COMMAND"
>\unset</TT
>。要显示所有变量的值，在调用<TT
CLASS="COMMAND"
>\set</TT
>时不带任何参数即可。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    <TT
CLASS="COMMAND"
>\set</TT
>的参数服从与其他命令相同的替换规则。因此可以构造有趣的引用，例如<TT
CLASS="LITERAL"
>\set :foo 'something'</TT
>以及分别得到<SPAN
CLASS="PRODUCTNAME"
>Perl</SPAN
>或者<SPAN
CLASS="PRODUCTNAME"
><ACRONYM
CLASS="ACRONYM"
>PHP</ACRONYM
></SPAN
>的<SPAN
CLASS="QUOTE"
>"软链接"</SPAN
>或者<SPAN
CLASS="QUOTE"
>"可变变量"</SPAN
>。不幸的是（或者幸运的是？），这些构造出来的东西并没有什么用处。在另一方面，<TT
CLASS="LITERAL"
>\set bar :foo</TT
>是一种很好的拷贝变量的方法。
    </P
></BLOCKQUOTE
></DIV
><P
>    有一些变量会被<SPAN
CLASS="APPLICATION"
>psql</SPAN
>特殊对待。它们表示特定的选项设置，运行时这类选项设置可以通过修改该变量的值来改变，或者在某些情况下它们表示<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的可更改的状态。尽管可以把这些变量用于其他目的，但并不推荐这样做，因为该程序的行为可能发展得很快很奇怪。按照惯例，所有被特殊对待的变量的名称由全部大写形式的 ASCII 字母（还有可能是数字和下划线）组成。为了确保未来最大的兼容性，最好避免把这类变量名用于自己的目的。下文列出了所有被特殊对待的变量。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>AUTOCOMMIT</TT
>
       </DT
><DD
><P
>        在被设置为<TT
CLASS="LITERAL"
>on</TT
>（默认）时，每一个 SQL 命令在成功完成时会被自动提交。在这种模式中要推迟提交，必须输入一个<TT
CLASS="COMMAND"
>BEGIN</TT
>或者<TT
CLASS="COMMAND"
>START TRANSACTION</TT
> SQL 命令。当被设置为<TT
CLASS="LITERAL"
>off</TT
>或者被重置时，在显式发出<TT
CLASS="COMMAND"
>COMMIT</TT
>或者<TT
CLASS="COMMAND"
>END</TT
>之前，SQL 命令不会被提交。自动提交关闭模式会为你发出一个隐式的<TT
CLASS="COMMAND"
>BEGIN</TT
>，这会发生在任何不在一个事务块中且本身即不是<TT
CLASS="COMMAND"
>BEGIN</TT
>及其他事务控制命令且不是无法在事务块中执行的命令（例如<TT
CLASS="COMMAND"
>VACUUM</TT
>）之前。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>         在自动提交关闭模式中，必须通过<TT
CLASS="COMMAND"
>ABORT</TT
>或者<TT
CLASS="COMMAND"
>ROLLBACK</TT
>显式地放弃任何失败的事务。还要记住，如果退出会话时没有提交，则所有的工作都会丢失。
        </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>         自动提交打开模式是<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的传统行为，但是自动提交关闭模式更接近于 SQL 的规范。如果更喜欢自动提交关闭模式，可以在系统级的<TT
CLASS="FILENAME"
>psqlrc</TT
>文件或者个人的<TT
CLASS="FILENAME"
>~/.psqlrc</TT
>文件中设置它。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>COMP_KEYWORD_CASE</TT
></DT
><DD
><P
>        确定在补全一个 SQL 关键词时要使用的大小写形式。如果被设置为<TT
CLASS="LITERAL"
>lower</TT
>或者<TT
CLASS="LITERAL"
>upper</TT
>，补全后的词将分别是小写或者大写形式。如果被设置为<TT
CLASS="LITERAL"
>preserve-lower</TT
>或者<TT
CLASS="LITERAL"
>preserve-upper</TT
>（默认），补全后的词将会保持该词已输入部分的大小写形式，但是如果被补全的词还没有被输入，则它会被分别补全成小写或者大写形式。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>DBNAME</TT
></DT
><DD
><P
>        当前已连接的数据库名称。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被重置。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>ECHO</TT
></DT
><DD
><P
>        如果被设置为<TT
CLASS="LITERAL"
>all</TT
>，所有非空输入行会被按照读入它们的样子打印到标准输出（不适用于交互式读取的行）。要在程序开始时选择这种行为，可以使用开关<TT
CLASS="OPTION"
>-a</TT
>。如果被设置为<TT
CLASS="LITERAL"
>queries</TT
>，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>会在发送每个查询给服务器时将它们打印到标准输出。这种行为的开关是<TT
CLASS="OPTION"
>-e</TT
>。如果被设置为<TT
CLASS="LITERAL"
>errors</TT
>，那么只有失败的查询会被显示在标准错误输出上。它的开关是<TT
CLASS="OPTION"
>-b</TT
>。如果被重置或者设置为<TT
CLASS="LITERAL"
>none</TT
>（或者其他非上述值）则不会显示任何查询。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>ECHO_HIDDEN</TT
></DT
><DD
><P
>        当这个变量被设置为<TT
CLASS="LITERAL"
>on</TT
>且一个反斜线命令查询数据库时，相应的查询会被先显示。这种特性可以帮助我们学习<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的内部并且在自己的程序中提供类似的功能（要在程序开始时选择这种行为，可以使用开关<TT
CLASS="OPTION"
>-E</TT
>）。如果把这个变量设置为值<TT
CLASS="LITERAL"
>noexec</TT
>，则对应的查询只会被显示而并不真正被发送给服务器执行。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>ENCODING</TT
></DT
><DD
><P
>        当前的客户端字符集编码。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>FETCH_COUNT</TT
></DT
><DD
><P
>        如果这个变量被设置为一个 &gt; 0 的整数值，<TT
CLASS="COMMAND"
>SELECT</TT
>查询的结果会以一组一组的方式取出并且显示（而不是像默认的那样把整个结果集拿到以后再显示），每一组就会包括这么多个行。因此，这种方式只会使用有限的内存量，而不管整个结果集的大小。在启用这个特性时，通常会使用 100 到 1000 的设置。记住在使用这种特性时，一个查询可能会在已经显示了一些行之后失败。
        </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>        尽管可以把这种特性用于任何的输出格式，但是默认的<TT
CLASS="LITERAL"
>aligned</TT
>格式看起来会比较糟糕，因为每一组的<TT
CLASS="VARNAME"
>FETCH_COUNT</TT
>个行将被单独格式化，这就会导致不同的行组的列宽不同。其他的输出格式会更好。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>HISTCONTROL</TT
></DT
><DD
><P
>         如果这个变量被设置为<TT
CLASS="LITERAL"
>ignorespace</TT
>，则以一个空格开始的行不会被放入到历史列表中。如果被设置为值<TT
CLASS="LITERAL"
>ignoredups</TT
>，则匹配之前的历史行的行不会被放入。值<TT
CLASS="LITERAL"
>ignoreboth</TT
>组合了上述两种值。如果被重置或者被设置为<TT
CLASS="LITERAL"
>none</TT
>（或者其他非上述值），所有在交互模式中被读入的行都会保存在历史列表中。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        这个特性是可耻地从<SPAN
CLASS="APPLICATION"
>Bash</SPAN
>抄袭过来的。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>HISTFILE</TT
></DT
><DD
><P
>        将被用于存储历史列表的文件名。默认值是<TT
CLASS="FILENAME"
>~/.psql_history</TT
>。例如，把
</P><PRE
CLASS="PROGRAMLISTING"
>\set HISTFILE ~/.psql_history- :DBNAME</PRE
><P>
        放在<TT
CLASS="FILENAME"
>~/.psqlrc</TT
>中将会导致<SPAN
CLASS="APPLICATION"
>psql</SPAN
>为每一个数据库维护一个单独的历史。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        这个特性是可耻地从<SPAN
CLASS="APPLICATION"
>Bash</SPAN
>抄袭过来的。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>HISTSIZE</TT
></DT
><DD
><P
>        存储在命令历史中的命令数。默认值是 500。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        这个特性是可耻地从<SPAN
CLASS="APPLICATION"
>Bash</SPAN
>抄袭过来的。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>HOST</TT
></DT
><DD
><P
>        当前连接到的数据库服务器端口。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被重置。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>IGNOREEOF</TT
></DT
><DD
><P
>         如果被重置，向<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的一个交互式会话发送一个<ACRONYM
CLASS="ACRONYM"
>EOF</ACRONYM
>字符（通常是<B
CLASS="KEYCAP"
>Control</B
>+<B
CLASS="KEYCAP"
>D</B
>）将会终止该应用。如果被设置为一个数字值，则在应用终止前会忽略那么多个<ACRONYM
CLASS="ACRONYM"
>EOF</ACRONYM
>字符。如果该变量被设置但不是数字值，则默认为 10。
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        这个特性是可耻地从<SPAN
CLASS="APPLICATION"
>Bash</SPAN
>抄袭过来的。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>LASTOID</TT
></DT
><DD
><P
>        最后被影响的 OID 的值，这可能会由<TT
CLASS="COMMAND"
>INSERT</TT
>或者<TT
CLASS="COMMAND"
>\lo_import</TT
>命令返回。这个变量只保证在下一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>命令被显示完之前有效。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>ON_ERROR_ROLLBACK</TT
>
       </DT
><DD
><P
>        当被设置为<TT
CLASS="LITERAL"
>on</TT
>时，如果事务块中的一个语句产生一个错误，该错误会被忽略并且该事务会继续。当被设置为<TT
CLASS="LITERAL"
>interactive</TT
>时，只在交互式会话中忽略这类错误，而读取脚本文件时则不会忽略错误。当被重置或者设置为<TT
CLASS="LITERAL"
>off</TT
>时，事务块中产生错误的一个语句会中止整个事务。错误回滚模式的工作原理是在事务块的每个命令之前都为你发出一个隐式的<TT
CLASS="COMMAND"
>SAVEPOINT</TT
>，然后在该命令失败时回滚到该保存点。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>ON_ERROR_STOP</TT
></DT
><DD
><P
>        默认情况下，出现一个错误后命令处理会继续下去。当这个变量被设置为<TT
CLASS="LITERAL"
>on</TT
>后，出现错误后命令处理会立即停止。在交互模式下，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将会返回到命令提示符；否则，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>将会退出并且返回错误代码 3 来把这种情况与致命错误区分开来，致命错误会被报告为错误代码 1。在两种情况下，任何当前正在运行的脚本（顶层脚本以及任何它已经调用的其他脚本）将被立即中止。如果顶层命名字符串包含多个 SQL 命令，将在当前命令处停止处理。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>PORT</TT
></DT
><DD
><P
>        当前连接到的数据库服务器端口。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被重置。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>PROMPT1</TT
><BR><TT
CLASS="VARNAME"
>PROMPT2</TT
><BR><TT
CLASS="VARNAME"
>PROMPT3</TT
></DT
><DD
><P
>        这些变量指定<SPAN
CLASS="APPLICATION"
>psql</SPAN
>发出的提示符的模样。见下文的<A
HREF="app-psql.html#APP-PSQL-PROMPTING"
><I
>提示符</I
></A
>。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>QUIET</TT
></DT
><DD
><P
>        把这个变量设置为<TT
CLASS="LITERAL"
>on</TT
>等效于命令行选项<TT
CLASS="OPTION"
>-q</TT
>。在交互模式下可能用处不大。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>SHOW_CONTEXT</TT
></DT
><DD
><P
>        这个变量可以被设置为值<TT
CLASS="LITERAL"
>never</TT
>、<TT
CLASS="LITERAL"
>errors</TT
>或者<TT
CLASS="LITERAL"
>always</TT
>来控制是否在来自服务器的消息中显示<TT
CLASS="LITERAL"
>CONTEXT</TT
>域。默认是<TT
CLASS="LITERAL"
>errors</TT
>（表示在错误消息中显示上下文，但在通知和警告消息中不显示）。当<TT
CLASS="VARNAME"
>VERBOSITY</TT
>被设置为<TT
CLASS="LITERAL"
>terse</TT
>时，这个设置无效（另见<TT
CLASS="COMMAND"
>\errverbose</TT
>，它可以用来得到刚遇到的错误的详细信息）。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>SINGLELINE</TT
></DT
><DD
><P
>        设置这个变量为<TT
CLASS="LITERAL"
>on</TT
>等效于命令行选项<TT
CLASS="OPTION"
>-S</TT
>。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>SINGLESTEP</TT
></DT
><DD
><P
>        设置这个变量为<TT
CLASS="LITERAL"
>on</TT
>等效于命令选项<TT
CLASS="OPTION"
>-s</TT
>。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>USER</TT
></DT
><DD
><P
>        当前连接的数据库用户。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被重置。
        </P
></DD
><DT
><TT
CLASS="VARNAME"
>VERBOSITY</TT
></DT
><DD
><P
>        这个变量可以被设置为值<TT
CLASS="LITERAL"
>default</TT
>、<TT
CLASS="LITERAL"
>verbose</TT
>或者<TT
CLASS="LITERAL"
>terse</TT
>来控制错误报告的详细程度（另见<TT
CLASS="COMMAND"
>\errverbose</TT
>，在想得到之前的错误的详细版本时使用）。
        </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="APP-PSQL-INTERPOLATION"
></A
><H4
><ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> 中插入变量</H4
><P
>    <SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量的一个关键特性是可以把它们替换（<SPAN
CLASS="QUOTE"
>"插入"</SPAN
>）到常规<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>语句中，也可以把它们作为元命令的参数。此外，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>还提供了功能来确保被用作 SQL 文字和标识符的变量值会被正确地引用。插入一个值而不需要加引用的语法是在变量名前面加上一个冒号（<TT
CLASS="LITERAL"
>:</TT
>）。例如，
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\set foo 'my_table'</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM :foo;</KBD
></PRE
><P>
    将查询表<TT
CLASS="LITERAL"
>my_table</TT
>。注意这可能会不安全：该变量的值会被按字面拷贝，因此它可能包含不平衡的引号甚至反斜线命令。必须确保把它放在那里是有意义的。
    </P
><P
>    当一个值被用作 SQL 文本或者标识符时，最安全的是把它加上引用。要引用一个变量的值作为 SQL 文本，可以把变量名称放在单引号中并且在引号前面写一个冒号。要引用作为 SQL 标识符，则可以把变量名称放在双引号中并且在引号前面写一个冒号。这种结构可以正确地处理变量值中嵌入的引号和其他特殊字符。之前的例子用这种方法写会更安全：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\set foo 'my_table'</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM :"foo";</KBD
></PRE
><P>
    </P
><P
>    在被引用的<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>文本和标识符中将不会执行变量插入。因此，一个诸如<TT
CLASS="LITERAL"
>':foo'</TT
>的结构不会从一个变量的值产生一个被引用的文本（即便能够也会不安全，因为无法正确地处理嵌入在值中的引号）。
    </P
><P
>    使用这种机制的一个例子是把一个文件的内容拷贝到一个表列中。首先把该文件载入到一个变量，然后把该变量的值作为一个被引用的字符串插入：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\set content `cat my_file.txt`</KBD
>
testdb=&gt; <KBD
CLASS="USERINPUT"
>INSERT INTO my_table VALUES (:'content');</KBD
></PRE
><P>
    （注意如果<TT
CLASS="FILENAME"
>my_file.txt</TT
>包含 NUL 字节，这样也不行。<SPAN
CLASS="APPLICATION"
>psql</SPAN
>不支持在变量值中嵌入 NUL 字节）。
    </P
><P
>    因为冒号可以合法地出现在 SQL 命令中，一次明显的插入尝试（即<TT
CLASS="LITERAL"
>:name</TT
>、<TT
CLASS="LITERAL"
>:'name'</TT
>或者<TT
CLASS="LITERAL"
>:"name"</TT
>）不会被替换，除非所提及的变量就是当前被设置的。在任何情况下，可以用一个反斜线对冒号进行转义以避免它被替换。
    </P
><P
>    变量的冒号语法对嵌入式查询语言（例如<SPAN
CLASS="APPLICATION"
>ECPG</SPAN
>）来说是标准的<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>。用于数组切片和类型造型的冒号语法是<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>扩展，它有时可能会与标准用法冲突。把一个变量值转义成 SQL 文本或者标识符的冒号引用语法是一种<SPAN
CLASS="APPLICATION"
>psql</SPAN
>扩展。
    </P
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="APP-PSQL-PROMPTING"
></A
><H4
>提示符</H4
><P
>    <SPAN
CLASS="APPLICATION"
>psql</SPAN
>发出的提示符可以根据用户的喜好自定义。<TT
CLASS="VARNAME"
>PROMPT1</TT
>、<TT
CLASS="VARNAME"
>PROMPT2</TT
>和<TT
CLASS="VARNAME"
>PROMPT3</TT
>这三个变量包含了描述提示符外观的字符串和特殊转义序列。Prompt 1 是当<SPAN
CLASS="APPLICATION"
>psql</SPAN
>等待新命令时发出的常规提示符。Prompt 2 是在命令输入时需要更多输入时发出的提示符，例如因为当命令没有被分号终止或者引用没有被关闭时就会发出这个提示符。在运行一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> <TT
CLASS="COMMAND"
>COPY FROM STDIN</TT
>命令并且需要在终端上输入一个行值时，会发出 Prompt 3。
    </P
><P
>    被选中的提示符变量会被原样打印，除非碰到一个百分号（<TT
CLASS="LITERAL"
>%</TT
>）。百分号的下一个字符会被特定的其他文本替换。预定义好的替换有：

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>%M</TT
></DT
><DD
><P
>          数据库服务器的完整主机名（带有域名），或者当该连接是建立在一个 Unix 域套接字上时则是<TT
CLASS="LITERAL"
>[local]</TT
>，或者当 Unix 域套接字不在编译在系统内的默认位置上时则是<TT
CLASS="LITERAL"
>[local:<TT
CLASS="REPLACEABLE"
><I
>/dir/name</I
></TT
>]</TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>%m</TT
></DT
><DD
><P
>          数据库服务器的主机名称（在第一个点处截断），或者当连接建立在一个 Unix 域套接字上时是<TT
CLASS="LITERAL"
>[local]</TT
>。
         </P
></DD
><DT
><TT
CLASS="LITERAL"
>%&gt;</TT
></DT
><DD
><P
>数据库服务器正在监听的端口号。</P
></DD
><DT
><TT
CLASS="LITERAL"
>%n</TT
></DT
><DD
><P
>          数据库会话的用户名（在数据库会话期间，这个值可能会因为命令<TT
CLASS="COMMAND"
>SET SESSION AUTHORIZATION</TT
>的结果而改变）。
         </P
></DD
><DT
><TT
CLASS="LITERAL"
>%/</TT
></DT
><DD
><P
>当前数据库的名称。</P
></DD
><DT
><TT
CLASS="LITERAL"
>%~</TT
></DT
><DD
><P
>和<TT
CLASS="LITERAL"
>%/</TT
>类似，但是如果数据库是默认数据库时输出是<TT
CLASS="LITERAL"
>~</TT
>（波浪线）。</P
></DD
><DT
><TT
CLASS="LITERAL"
>%#</TT
></DT
><DD
><P
>          如果会话用户时一个数据库超级用户，则是<TT
CLASS="LITERAL"
>#</TT
>，否则是一个<TT
CLASS="LITERAL"
>&gt;</TT
>（在数据库会话期间，这个值可能会因为命令<TT
CLASS="COMMAND"
>SET SESSION AUTHORIZATION</TT
>的结果而改变）。
         </P
></DD
><DT
><TT
CLASS="LITERAL"
>%p</TT
></DT
><DD
><P
>当前连接到的后端的进程 ID。</P
></DD
><DT
><TT
CLASS="LITERAL"
>%R</TT
></DT
><DD
><P
>        在提示符 1 中通常是<TT
CLASS="LITERAL"
>=</TT
>，但如果在单行模式中是<TT
CLASS="LITERAL"
>^</TT
>，如果会话断开了与数据库的连接（如果<TT
CLASS="COMMAND"
>\connect</TT
>失败会这样）则是<TT
CLASS="LITERAL"
>!</TT
>。在提示符 2 中，根据为什么<SPAN
CLASS="APPLICATION"
>psql</SPAN
>期待更多的输入，<TT
CLASS="LITERAL"
>%R</TT
>会被一个相应的字符替换：如果命令还没有被终止是<TT
CLASS="LITERAL"
>-</TT
>，如果有一个未完的<TT
CLASS="LITERAL"
>/* ... */</TT
>注释则是<TT
CLASS="LITERAL"
>*</TT
>，如果有一个未完的被引用字符串则是一个单引号，如果有一个未完的被引用标识符则是一个双引号，如果有一个未完的美元引用字符串则是一个美元符号，如果有一个还没有被配对的左圆括号则是<TT
CLASS="LITERAL"
>(</TT
>。在提示符 3 中<TT
CLASS="LITERAL"
>%R</TT
>不会产生任何东西。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>%x</TT
></DT
><DD
><P
>        事务状态：当不在事务块中时是一个空字符串，在一个事务块中时是<TT
CLASS="LITERAL"
>*</TT
>，在一个失败的事务块中时是<TT
CLASS="LITERAL"
>!</TT
>，当事务状态是未判定时（例如因为没有连接）为<TT
CLASS="LITERAL"
>?</TT
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>%l</TT
></DT
><DD
><P
>          当前语句中的行号，从<TT
CLASS="LITERAL"
>1</TT
>开始。
         </P
></DD
><DT
><TT
CLASS="LITERAL"
>%</TT
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></DT
><DD
><P
>        带有指定的八进制码的字符会被替换。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>%:</TT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
><TT
CLASS="LITERAL"
>:</TT
></DT
><DD
><P
>        <SPAN
CLASS="APPLICATION"
>psql</SPAN
>变量<TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>的值。详见<A
HREF="app-psql.html#APP-PSQL-VARIABLES"
><I
>变量</I
></A
>。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>%`</TT
><TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
><TT
CLASS="LITERAL"
>`</TT
></DT
><DD
><P
>        <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>的输出，类似于平常的<SPAN
CLASS="QUOTE"
>"反引号"</SPAN
>替换。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>%[</TT
> ... <TT
CLASS="LITERAL"
>%]</TT
></DT
><DD
><P
>         提示符可以包含终端控制字符，例如改变提示符文本的颜色、背景或者风格以及更改终端窗口标题的控制字符。为了让<SPAN
CLASS="APPLICATION"
>Readline</SPAN
>的行编辑特性正确工作，这些不可打印的控制字符必须被包裹在<TT
CLASS="LITERAL"
>%[</TT
>和<TT
CLASS="LITERAL"
>%]</TT
>之间以指定它们是不可见的。在提示附中可以出现多个这样的标识对。例如：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; \set PROMPT1 '%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%# '</PRE
><P>
         会导致一个在兼容 VT100 的彩色终端上的粗体（<TT
CLASS="LITERAL"
>1;</TT
>）的、黑底黄字（<TT
CLASS="LITERAL"
>33;40</TT
>）的提示符。
        </P
></DD
></DL
></DIV
><P>

    要在你的提示符中插入一个百分号，可以写成<TT
CLASS="LITERAL"
>%%</TT
>。提示符 1 和 2 的默认提示是<TT
CLASS="LITERAL"
>'%/%R%# '</TT
>，提示符 3 的提示是<TT
CLASS="LITERAL"
>'&gt;&gt; '</TT
>。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    这个特性是可耻地从<SPAN
CLASS="APPLICATION"
>tcsh</SPAN
>抄袭过来的。
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="AEN100448"
></A
><H4
>命令行编辑</H4
><P
>    为了方便的行编辑和检索，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>支持<SPAN
CLASS="APPLICATION"
>Readline</SPAN
>库。<SPAN
CLASS="APPLICATION"
>psql</SPAN
>退出时命令历史会被自动保存，而当<SPAN
CLASS="APPLICATION"
>psql</SPAN
>启动时命令历史会被重新载入。<SPAN
CLASS="APPLICATION"
>psql</SPAN
>也支持 tab 补全，不过补全逻辑绝不是一个<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>解析器。tab 补全产生的查询也可能会受其他 SQL 命令干扰，例如<TT
CLASS="LITERAL"
>SET TRANSACTION ISOLATION LEVEL</TT
>。如果出于某种原因不想用 tab 键补全，可以把下面的代码放在主目录下的名为<TT
CLASS="FILENAME"
>.inputrc</TT
>文件中关闭该特性：
</P><PRE
CLASS="PROGRAMLISTING"
>$if psql
set disable-completion on
$endif</PRE
><P>
    （这不是<SPAN
CLASS="APPLICATION"
>psql</SPAN
>特性而是<SPAN
CLASS="APPLICATION"
>Readline</SPAN
>的特性。进一步的细节请阅读它的文档。）
    </P
></DIV
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="APP-PSQL-ENVIRONMENT"
></A
><H2
>环境</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="ENVAR"
>COLUMNS</TT
></DT
><DD
><P
>      如果<TT
CLASS="LITERAL"
>\pset columns</TT
>为零，这个环境变量控制用于<TT
CLASS="LITERAL"
>wrapped</TT
>格式的宽度以及用来确定是否输出需要用到分页器或者切换到扩展自动模式中的垂直格式的宽度。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>PAGER</TT
></DT
><DD
><P
>      如果屏幕无法容纳查询结果，则查询结果会通过这个命令导出。典型的值是<TT
CLASS="LITERAL"
>more</TT
>或者<TT
CLASS="LITERAL"
>less</TT
>。它的默认值与平台相关。分页器的使用可以通过使用<TT
CLASS="COMMAND"
>\pset</TT
>命令禁止。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>PGDATABASE</TT
><BR><TT
CLASS="ENVAR"
>PGHOST</TT
><BR><TT
CLASS="ENVAR"
>PGPORT</TT
><BR><TT
CLASS="ENVAR"
>PGUSER</TT
></DT
><DD
><P
>      默认连接参数（见<A
HREF="libpq-envars.html"
>第 32.14 &#33410;</A
>）。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>PSQL_EDITOR</TT
><BR><TT
CLASS="ENVAR"
>EDITOR</TT
><BR><TT
CLASS="ENVAR"
>VISUAL</TT
></DT
><DD
><P
>      <TT
CLASS="COMMAND"
>\e</TT
>、<TT
CLASS="COMMAND"
>\ef</TT
>以及<TT
CLASS="COMMAND"
>\ev</TT
>命令使用的编辑器。将以上述列出的顺序检查这些变量，第一个被设置的变量将被使用。
     </P
><P
>      在 Unix 系统上内建的默认编辑器是<TT
CLASS="FILENAME"
>vi</TT
>，Windows 系统上则是<TT
CLASS="FILENAME"
>notepad.exe</TT
>。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>PSQL_EDITOR_LINENUMBER_ARG</TT
></DT
><DD
><P
>      当<TT
CLASS="COMMAND"
>\e</TT
>、<TT
CLASS="COMMAND"
>\ef</TT
>或者<TT
CLASS="COMMAND"
>\ev</TT
>带有一个行号参数时，这个变量指定用于传递起始行号给用户编辑器的命令行参数。对于<SPAN
CLASS="PRODUCTNAME"
>Emacs</SPAN
>或者<SPAN
CLASS="PRODUCTNAME"
>vi</SPAN
>之类的编辑器，这个变量是一个加号。如果需要在选项名称和行号之间有空格，可以在该变量的值中包括一个结尾的空格。例如：
</P><PRE
CLASS="PROGRAMLISTING"
>PSQL_EDITOR_LINENUMBER_ARG='+'
PSQL_EDITOR_LINENUMBER_ARG='--line '</PRE
><P>
     </P
><P
>      在 Unix 系统上默认是<TT
CLASS="LITERAL"
>+</TT
>（对应于默认编辑器<TT
CLASS="FILENAME"
>vi</TT
>，且对很多其他常见编辑器可用）。在 Windows 系统上没有默认值。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>PSQL_HISTORY</TT
></DT
><DD
><P
>      命令历史文件的替代位置。波浪线（<TT
CLASS="LITERAL"
>~</TT
>）扩展会被执行。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>PSQLRC</TT
></DT
><DD
><P
>      用户的<TT
CLASS="FILENAME"
>.psqlrc</TT
>文件的替代位置。波浪线（<TT
CLASS="LITERAL"
>~</TT
>）扩展会被执行。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>SHELL</TT
></DT
><DD
><P
>      被<TT
CLASS="COMMAND"
>\!</TT
>命令执行的命令。
     </P
></DD
><DT
><TT
CLASS="ENVAR"
>TMPDIR</TT
></DT
><DD
><P
>      存储临时文件的目录。默认是<TT
CLASS="FILENAME"
>/tmp</TT
>。
     </P
></DD
></DL
></DIV
><P
>   和大部分其他<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>工具一样，这个工具也使用<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>所支持的环境变量（见<A
HREF="libpq-envars.html"
>第 32.14 &#33410;</A
>）。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN100550"
></A
><H2
>文件</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="FILENAME"
>psqlrc</TT
> and <TT
CLASS="FILENAME"
>~/.psqlrc</TT
></DT
><DD
><P
>     如果没有<TT
CLASS="OPTION"
>-X</TT
>选项，在连接到数据库后但在接收正常的命令之前，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>会尝试依次从系统级的启动文件（<TT
CLASS="FILENAME"
>psqlrc</TT
>）和用户的个人启动文件（<TT
CLASS="FILENAME"
>~/.psqlrc</TT
>）中读取并且执行命令。这些文件可以被用来设置客户端或者服务器，通常是一些<TT
CLASS="COMMAND"
>\set</TT
>和<TT
CLASS="COMMAND"
>SET</TT
>命令。
    </P
><P
>     系统级的启动文件是<TT
CLASS="FILENAME"
>psqlrc</TT
>，它应该在安装好的<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的<SPAN
CLASS="QUOTE"
>"系统配置"</SPAN
>目录中，最可靠的定位方法是运行<TT
CLASS="LITERAL"
>pg_config --sysconfdir</TT
>。默认情况下，这个目录将是<TT
CLASS="FILENAME"
>../etc/</TT
>（相对于包含<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>可执行文件的目录）。可以通过<TT
CLASS="ENVAR"
>PGSYSCONFDIR</TT
>环境变量显式地设置这个目录的名称。
    </P
><P
>     用户个人的启动文件是<TT
CLASS="FILENAME"
>.psqlrc</TT
>，它应该在调用用户的主目录中。在 Windows 上，由于没有用户主目录的概念，个人的启动文件是<TT
CLASS="FILENAME"
>%APPDATA%\postgresql\psqlrc.conf</TT
>。用户启动文件的位置可以通过<TT
CLASS="ENVAR"
>PSQLRC</TT
>环境变量设置。        
    </P
><P
>     系统级和用户个人的启动文件都可以弄成是针对特定<SPAN
CLASS="APPLICATION"
>psql</SPAN
>版本的，方法是在文件名后面加上一个横线以及<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的主、次版本号，例如<TT
CLASS="FILENAME"
>~/.psqlrc-9.2</TT
>或者<TT
CLASS="FILENAME"
>~/.psqlrc-9.2.5</TT
>。版本最为匹配的文件会优先于不那么匹配的文件读入。
    </P
></DD
><DT
><TT
CLASS="FILENAME"
>.psql_history</TT
></DT
><DD
><P
>     命令行历史被存储在文件<TT
CLASS="FILENAME"
>~/.psql_history</TT
>中，或者是 Windows 的文件<TT
CLASS="FILENAME"
>%APPDATA%\postgresql\psql_history</TT
>中。
    </P
><P
>     历史文件的位置可以通过<TT
CLASS="ENVAR"
>PSQL_HISTORY</TT
>环境变量显式地设置。
    </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN100591"
></A
><H2
>注解</H2
><P
></P
><UL
><LI
><P
><SPAN
CLASS="APPLICATION"
>psql</SPAN
>和具有相同主版本或者更老的主版本服务器最为匹配。如果服务器的版本比<SPAN
CLASS="APPLICATION"
>psql</SPAN
>本身要高，则反斜线命令尤其容易失败。不过，<TT
CLASS="LITERAL"
>\d</TT
>家族的反斜线命令应该可以和版本 7.4 之后的服务器一起使用，但服务器的版本不必比<SPAN
CLASS="APPLICATION"
>psql</SPAN
>本身新。运行 SQL 命令并且显示查询结果的一般功能应该也能和具有更新主版本的服务器一起使用，但是并非在所有的情况下都能保证如此。
      </P
><P
>       如果你想用<SPAN
CLASS="APPLICATION"
>psql</SPAN
>连接到多个具有不同主版本的服务器，推荐使用最新版本的<SPAN
CLASS="APPLICATION"
>psql</SPAN
>。或者，你可以为每一个主版本保留一份<SPAN
CLASS="APPLICATION"
>psql</SPAN
>拷贝，并且针对相应的服务器使用匹配的版本。但实际上，这种额外的麻烦是不必要的。
      </P
></LI
><LI
><P
>       在<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.6 之前，<TT
CLASS="OPTION"
>-c</TT
>选项表示<TT
CLASS="OPTION"
>-X</TT
>（<TT
CLASS="OPTION"
>--no-psqlrc</TT
>），但现在不是这样了。
      </P
></LI
><LI
><P
>       在<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.4 之前，<SPAN
CLASS="APPLICATION"
>psql</SPAN
>允许一个单字母反斜线命令的第一个参数直接写在该命令后面，中间不需要空格。现在则要求一些空格。
      </P
></LI
></UL
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN100614"
></A
><H2
>给 Windows 用户的注解</H2
><P
>  <SPAN
CLASS="APPLICATION"
>psql</SPAN
>是一个<SPAN
CLASS="QUOTE"
>"控制台应用"</SPAN
>。由于 Windows 的控制台窗口使用的是一种和系统中其他应用不同的编码，在<SPAN
CLASS="APPLICATION"
>psql</SPAN
>中使用 8 位字符时要特别注意。如果<SPAN
CLASS="APPLICATION"
>psql</SPAN
>检测到一个有问题的控制台代码页，它将会在启动时警告你。要更改控制台代码页，有两件事是必要的：

   <P
></P
></P><UL
><LI
><P
>      输入<KBD
CLASS="USERINPUT"
>cmd.exe /c chcp 1252</KBD
>可以设置代码页（1252 是适用于德语的一个代码页，请在这里替换成你的值）。如果正在使用 Cygwin，可以把这个命令放在<TT
CLASS="FILENAME"
>/etc/profile</TT
>中。
     </P
></LI
><LI
><P
>      把控制台字体设置为<TT
CLASS="LITERAL"
>Lucida Console</TT
>，因为栅格字体无法与 ANSI 代码页一起使用。
     </P
></LI
></UL
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="APP-PSQL-EXAMPLES"
></A
><H2
>示例</H2
><P
>  第一个例子展示了如何如何跨越多行输入一个命令。注意提示符的改变：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>CREATE TABLE my_table (</KBD
>
testdb(&gt; <KBD
CLASS="USERINPUT"
> first integer not null default 0,</KBD
>
testdb(&gt; <KBD
CLASS="USERINPUT"
> second text)</KBD
>
testdb-&gt; <KBD
CLASS="USERINPUT"
>;</KBD
>
CREATE TABLE</PRE
><P>
  现在再看看表定义：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\d my_table</KBD
>
             Table "my_table"
 Attribute |  Type   |      Modifier
-----------+---------+--------------------
 first     | integer | not null default 0
 second    | text    |&#13;</PRE
><P>
  现在我们把提示符改一改：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>\set PROMPT1 '%n@%m %~%R%# '</KBD
>
peter@localhost testdb=&gt;</PRE
><P>
  假定已经用数据填充了这个表并且想看看其中的数据：
</P><PRE
CLASS="PROGRAMLISTING"
>peter@localhost testdb=&gt; SELECT * FROM my_table;
 first | second
-------+--------
     1 | one
     2 | two
     3 | three
     4 | four
(4 rows)&#13;</PRE
><P>
  你可以用<TT
CLASS="COMMAND"
>\pset</TT
>命令以不同的方式显示表：
</P><PRE
CLASS="PROGRAMLISTING"
>peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset border 2</KBD
>
Border style is 2.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM my_table;</KBD
>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)

peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset border 0</KBD
>
Border style is 0.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM my_table;</KBD
>
first second
----- ------
    1 one
    2 two
    3 three
    4 four
(4 rows)

peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset border 1</KBD
>
Border style is 1.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset format unaligned</KBD
>
Output format is unaligned.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset fieldsep ","</KBD
>
Field separator is ",".
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\pset tuples_only</KBD
>
Showing only tuples.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT second, first FROM my_table;</KBD
>
one,1
two,2
three,3
four,4</PRE
><P>
  或者使用短命令：
</P><PRE
CLASS="PROGRAMLISTING"
>peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>\a \t \x</KBD
>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT * FROM my_table;</KBD
>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four</PRE
><P></P
><P
>  如果需要，可以用<TT
CLASS="COMMAND"
>\crosstabview</TT
>命令以交叉表的形式显示查询结果：
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT first, second, first &gt; 2 AS gt2 FROM my_table;</KBD
>
 first | second | ge2 
-------+--------+-----
     1 | one    | f
     2 | two    | f
     3 | three  | t
     4 | four   | t
(4 rows)

testdb=&gt; <KBD
CLASS="USERINPUT"
>\crosstabview first second</KBD
>
 first | one | two | three | four 
-------+-----+-----+-------+------
     1 | f   |     |       | 
     2 |     | f   |       | 
     3 |     |     | t     | 
     4 |     |     |       | t
(4 rows)</PRE
><P>

这第二个例子展示了表的“乘法”（连接），行按照序号降序排序且列按照独立的、升序的方式排序。
</P><PRE
CLASS="PROGRAMLISTING"
>testdb=&gt; <KBD
CLASS="USERINPUT"
>SELECT t1.first as "A", t2.first+100 AS "B", t1.first*(t2.first+100) as "AxB",</KBD
>
testdb(&gt; <KBD
CLASS="USERINPUT"
>row_number() over(order by t2.first) AS ord</KBD
>
testdb(&gt; <KBD
CLASS="USERINPUT"
>FROM my_table t1 CROSS JOIN my_table t2 ORDER BY 1 DESC</KBD
>
testdb(&gt; <KBD
CLASS="USERINPUT"
>\crosstabview "A" "B" "AxB" ord</KBD
>
 A | 101 | 102 | 103 | 104 
---+-----+-----+-----+-----
 4 | 404 | 408 | 412 | 416
 3 | 303 | 306 | 309 | 312
 2 | 202 | 204 | 206 | 208
 1 | 101 | 102 | 103 | 104
(4 rows)</PRE
><P>&#13;</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="app-pgrestore.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="app-reindexdb.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>pg_restore</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="reference-client.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><SPAN
CLASS="APPLICATION"
>reindexdb</SPAN
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
