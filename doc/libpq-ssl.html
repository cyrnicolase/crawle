<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>SSL 支持</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C 库"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="连接参数的 LDAP 查找"
HREF="libpq-ldap.html"><LINK
REL="NEXT"
TITLE="在线程化程序中的行为"
HREF="libpq-threading.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/libpq.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="连接参数的 LDAP 查找"
HREF="libpq-ldap.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 32. <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C 库</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="在线程化程序中的行为"
HREF="libpq-threading.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-SSL"
>32.18. SSL 支持</A
></H1
><P
>   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>本地支持使用<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>
   连接加密客户端/服务器通信以提高安全性。关于服务器端的<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>
   功能详见<A
HREF="ssl-tcp.html"
>第 18.9 &#33410;</A
>。
  </P
><P
>   <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>读取系统范围的<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>
   配置文件。默认情况下，这个文件被命名为<TT
CLASS="FILENAME"
>openssl.cnf</TT
>并且存放在
   <TT
CLASS="LITERAL"
>openssl version -d</TT
>报告的目录中。可以通过设置环境变量
   <TT
CLASS="ENVAR"
>OPENSSL_CONF</TT
>把这个默认值覆盖为想要的配置文件的名称。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBQ-SSL-CERTIFICATES"
>32.18.1. 服务器证书的客户端验证</A
></H2
><P
>   默认情况下，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>将不会执行服务器证书的任何验证。
   这意味着可以在不被客户端知晓的情况下伪造服务器身份
   （例如通过修改一个 DNS 记录或者接管服务器的 IP 地址）。为了阻止哄骗，
   必须使用<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>证书验证。
  </P
><P
>   如果参数<TT
CLASS="LITERAL"
>sslmode</TT
>被设置为<TT
CLASS="LITERAL"
>verify-ca</TT
>，
   libpq 将通过检查证书链一直到一个可信的证书机构（<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>）
   来验证服务器是可信的。如果<TT
CLASS="LITERAL"
>sslmode</TT
>被设置为<TT
CLASS="LITERAL"
>verify-full</TT
>，
   libpq 将<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>还会</I
></SPAN
>验证服务器主机名是否匹配它的证书。
   如果服务器证书不能被验证，SSL 连接将失败。在大部分对安全敏感的环境中，
   建议使用<TT
CLASS="LITERAL"
>verify-full</TT
>。
  </P
><P
>   在<TT
CLASS="LITERAL"
>verify-full</TT
>模式下，主机名与证书的Subject Alternative Name
   （主题备用名称)属性进行匹配，
   或者如果没有类型为dNSName的主题备用名称，则与Common Name（公用名称）属性进行匹配。
   如果证书的名称属性以星号（<TT
CLASS="LITERAL"
> * </TT
>）开头，则星号将被视为通配符，
   其将匹配<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>除了</I
></SPAN
>点(<TT
CLASS="LITERAL"
>.</TT
>)之外的所有字符。这意味着证书将不会匹配子域。
   如果使用IP地址而不是主机名进行连接，则将匹配IP地址（不进行任何DNS查找）。  
  </P
><P
>   要允许服务器证书验证，一个或多个可信的<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>必须被放置在用户home目录下的文件
   <TT
CLASS="FILENAME"
>~/.postgresql/root.crt</TT
>中。如果中间<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>出现在
   <TT
CLASS="FILENAME"
>root.crt</TT
>中，该文件必须也包含到它们的根<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>的证书链
   （在微软 Windows 上该文件被命名为<TT
CLASS="FILENAME"
>%APPDATA%\postgresql\root.crt</TT
>）。
  </P
><P
>   如果文件<TT
CLASS="FILENAME"
>~/.postgresql/root.crl</TT
>存在
   （微软 Windows 上的<TT
CLASS="FILENAME"
>%APPDATA%\postgresql\root.crl</TT
>），
   也会检查证书撤销列表（CRL）项。
  </P
><P
>   根证书文件和 CRL 的位置可以通过设置连接参数<TT
CLASS="LITERAL"
>sslrootcert</TT
>和
   <TT
CLASS="LITERAL"
>sslcrl</TT
>或环境变量<TT
CLASS="ENVAR"
>PGSSLROOTCERT</TT
>和<TT
CLASS="ENVAR"
>PGSSLCRL</TT
>改变。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    为了与 PostgreSQL 的早期版本达到向后兼容，如果存在一个根 CA 文件，
    <TT
CLASS="LITERAL"
>sslmode</TT
>=<TT
CLASS="LITERAL"
>require</TT
>的行为将与
    <TT
CLASS="LITERAL"
>verify-ca</TT
>相同，意味着服务器证书根据 CA 验证。
    不鼓励依赖这种行为，并且需要证书验证的应用程序应该总是使用
    <TT
CLASS="LITERAL"
>verify-ca</TT
>或者<TT
CLASS="LITERAL"
>verify-full</TT
>。
   </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-SSL-CLIENTCERT"
>32.18.2. 客户端证书</A
></H2
><P
>   如果服务器要求一个可信的客户端证书，<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>
   将发送用户主目录中<TT
CLASS="FILENAME"
>~/.postgresql/postgresql.crt</TT
>文件存储的证书。
   该证书必须由一个受服务器信任的证书机构（<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>）签发。
   也必须存在一个匹配的私钥文件<TT
CLASS="FILENAME"
>~/.postgresql/postgresql.key</TT
>。
   该私钥文件不允许全局或组用户的任何访问，可以通过命令
   <TT
CLASS="COMMAND"
>chmod 0600 ~/.postgresql/postgresql.key</TT
>实现。
   在微软 Windows 上这些文件被命名为<TT
CLASS="FILENAME"
>%APPDATA%\postgresql\postgresql.crt</TT
>
   和<TT
CLASS="FILENAME"
>%APPDATA%\postgresql\postgresql.key</TT
>，不会有特别的权限检查，
   因为该目录被假定为安全。证书和密钥文件的位置可以使用连接参数<TT
CLASS="LITERAL"
>sslcert</TT
>
   和<TT
CLASS="LITERAL"
>sslkey</TT
>或者环境变量<TT
CLASS="ENVAR"
>PGSSLCERT</TT
>和<TT
CLASS="ENVAR"
>PGSSLKEY</TT
>覆盖。
  </P
><P
>   在一些情况下，客户端证书可以由<SPAN
CLASS="QUOTE"
>"中间"</SPAN
>证书机构签名，
   而不是由服务器直接信任的证书机构。
   要使用这样一个证书，将签发机构的证书加入到<TT
CLASS="FILENAME"
>postgresql.crt</TT
>文件，
   然后是它的上级机构的证书，并且一直到一个受服务器信任的证书机构（
   <SPAN
CLASS="QUOTE"
>"根"</SPAN
>机构或者<SPAN
CLASS="QUOTE"
>"中间"</SPAN
>机构），即由该服务器的
   <TT
CLASS="FILENAME"
>root.crt</TT
>文件中的一个证书签发。
  </P
><P
>   注意客户端的<TT
CLASS="FILENAME"
>~/.postgresql/root.crt</TT
>
   列出了被认为可信的能用于签发服务器证书的顶层 CA。
   原则上不需要列出签发客户端证书的 CA，
   大部分情况下这些 CA 也被信任可以用于服务器证书。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-SSL-PROTECTION"
>32.18.3. 不同模式中提供的保护</A
></H2
><P
>   <TT
CLASS="LITERAL"
>sslmode</TT
>参数的不同值提供了不同级别的保护。
   SSL 能够针对三类攻击提供保护：

   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>窃听</DT
><DD
><P
>如果一个第三方能够检查客户端和服务器之间的网络流量，
      它能读取连接信息（包括用户名和口令）以及被传递的数据。
      <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>使用加密来阻止这种攻击。
      </P
></DD
><DT
>中间人（<ACRONYM
CLASS="ACRONYM"
>MITM</ACRONYM
>）</DT
><DD
><P
>如果一个第三方能对客户端和服务器之间传送的数据进行修改，
      它就能假装是服务器并且因此能看见并且修改数据，<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>即使这些数据已被加密</I
></SPAN
>。
      然后第三方可以将连接信息和数据传送给原来的服务器，使得它不可能检测到攻击。
      这样做的常用载体包括 DNS 中毒和地址劫持，借此客户端被定向到预期之外的不同的服务器。
      还有几种其他的攻击方式能够完成这种攻击。<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>
      使用证书验证让客户端认证服务器，就可以阻止这种攻击。
      </P
></DD
><DT
>模仿</DT
><DD
><P
>如果第三方可以伪装成一个授权的客户端，
      那么它能够轻松访问它本不能访问的数据。通常这可以由不安全的口令管理所致。
      <ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>使用客户端证书来阻止这种情况，
      即确保只有持有合法证书的客户才能访问服务器。
      </P
></DD
></DL
></DIV
><P>
  </P
><P
>   对于一个已知安全的连接，在连接被建立之前，必须在
   <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>客户端和服务器端</I
></SPAN
>都进行SSL配置。如果只在服务器上配置，
   客户端在知道服务器要求高安全性之前可能会结束发送敏感信息（例如口令）。
   在 libpq 中，可以通过将<TT
CLASS="LITERAL"
>sslmode</TT
>参数设置为<TT
CLASS="LITERAL"
>verify-full</TT
>或
   <TT
CLASS="LITERAL"
>verify-ca</TT
>来确保安全连接，并且为系统提供一个根证书用来验证。
   这类似于使用<TT
CLASS="LITERAL"
>https</TT
> <ACRONYM
CLASS="ACRONYM"
>URL</ACRONYM
>进行加密网页浏览。
  </P
><P
>   一旦服务器已经被认证，客户端可以传递敏感数据。这意味着直到这一点，
   客户端都不需要知道是否证书将被用于认证，这样只需要在服务器配置中指定就比较安全。
  </P
><P
>   所有<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>选项都带来了加密和密钥交换的开销，
   因此必须在性能和安全性之间做出平衡。<A
HREF="libpq-ssl.html#LIBPQ-SSL-SSLMODE-STATEMENTS"
>&#34920; 32-1</A
>
   说明不同<TT
CLASS="LITERAL"
>sslmode</TT
>值所保护的风险，以及关于安全和开销所做出的声明。
  </P
><DIV
CLASS="TABLE"
><A
NAME="LIBPQ-SSL-SSLMODE-STATEMENTS"
></A
><P
><B
>&#34920; 32-1. SSL 模式描述</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
><TT
CLASS="LITERAL"
>sslmode</TT
></TH
><TH
>窃听保护</TH
><TH
><ACRONYM
CLASS="ACRONYM"
>MITM</ACRONYM
>保护</TH
><TH
>声明</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>disable</TT
></TD
><TD
>否</TD
><TD
>否</TD
><TD
>我不关心安全性，并且我不想承担加密的开销。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>allow</TT
></TD
><TD
>可能</TD
><TD
>否</TD
><TD
>我不关心安全性，但如果服务器坚持，我会承担加密开销 。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>prefer</TT
></TD
><TD
>可能</TD
><TD
>否</TD
><TD
>我不关心加密，但如果服务器支持，我希望承担加密开销。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>require</TT
></TD
><TD
>是</TD
><TD
>否</TD
><TD
>我希望我的数据加密，我接受开销。
      我相信该网络将确保我始终连接到想要连接的服务器。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>verify-ca</TT
></TD
><TD
>是</TD
><TD
><TT
CLASS="LITERAL"
>取决于 CA</TT
>-策略</TD
><TD
>我希望我的数据加密，我接受开销。
      我想要确保我连接到的是我信任的服务器。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>verify-full</TT
></TD
><TD
>是</TD
><TD
>是</TD
><TD
>我希望我的数据加密，我接受开销。
       我想要确保我连接到的是我信任的服务器，并且就是我指定的那一个。
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="LITERAL"
>verify-ca</TT
>和<TT
CLASS="LITERAL"
>verify-full</TT
>之间的区别取决于根<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>的策略。
   如果使用了一个公共<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>，<TT
CLASS="LITERAL"
>verify-ca</TT
>允许连接到那些可能已经被
   <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>其他人</I
></SPAN
>注册到该<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>的服务器。在这种情况下，总是应该使用
   <TT
CLASS="LITERAL"
>verify-full</TT
>。如果使用了一个本地<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>或者甚至是一个自签名的证书，
   使用<TT
CLASS="LITERAL"
>verify-ca</TT
>通常就可以提供足够的保护。
  </P
><P
>   <TT
CLASS="LITERAL"
>sslmode</TT
>的默认值是<TT
CLASS="LITERAL"
>prefer</TT
>。如表中所示，
   从安全角度来看这样做是没有意义的，并且它只承诺可能的性能开销。
   提供它作为默认值只是为了向后兼容，在安全部署中不建议使用。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-SSL-FILEUSAGE"
>32.18.4. SSL 客户端文件使用</A
></H2
><P
>   <A
HREF="libpq-ssl.html#LIBPQ-SSL-FILE-USAGE"
>&#34920; 32-2</A
>总结了与客户端 SSL 设置相关的文件。
  </P
><DIV
CLASS="TABLE"
><A
NAME="LIBPQ-SSL-FILE-USAGE"
></A
><P
><B
>&#34920; 32-2. Libpq/客户端 SSL 文件用法</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>文件</TH
><TH
>内容</TH
><TH
>影响</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="FILENAME"
>~/.postgresql/postgresql.crt</TT
></TD
><TD
>客户端证书</TD
><TD
>由服务器要求</TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>~/.postgresql/postgresql.key</TT
></TD
><TD
>客户端私钥</TD
><TD
>证明由所有者发送客户端证书，并不表示证书所有者是可信的</TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>~/.postgresql/root.crt</TT
></TD
><TD
>受信任的证书颁发机构</TD
><TD
>检查服务器证书是由一个可信的证书机构签发</TD
></TR
><TR
><TD
><TT
CLASS="FILENAME"
>~/.postgresql/root.crl</TT
></TD
><TD
>被证书颁发机构撤销的证书</TD
><TD
>服务器证书必须不在这个列表中</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-SSL-INITIALIZE"
>32.18.5. SSL 库初始化</A
></H2
><P
>   如果你的应用初始化<TT
CLASS="LITERAL"
>libssl</TT
>或<TT
CLASS="LITERAL"
>libcrypto</TT
>库以及
   <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>编译为支持<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>，你应该调用
   <CODE
CLASS="FUNCTION"
>PQinitOpenSSL</CODE
>来告诉<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>：<TT
CLASS="LITERAL"
>libssl</TT
>
   或<TT
CLASS="LITERAL"
>libcrypto</TT
>库已经被你的应用初始化，这样<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>
   将不会再初始化这些库。
   
   关于 SSL API 详见<A
HREF="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html"
TARGET="_top"
>http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html</A
>。
  </P
><P
>   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQINITOPENSSL"
></A
><CODE
CLASS="FUNCTION"
>PQinitOpenSSL</CODE
>
      </DT
><DD
><P
>       允许应用选择要初始化哪个安全库。
</P><PRE
CLASS="SYNOPSIS"
>void PQinitOpenSSL(int do_ssl, int do_crypto);</PRE
><P>
      </P
><P
>       当<TT
CLASS="PARAMETER"
>do_ssl</TT
>是非零时，<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>
       将在第一次打开数据库连接前初始化<SPAN
CLASS="APPLICATION"
>OpenSSL</SPAN
>库。
       当<TT
CLASS="PARAMETER"
>do_crypto</TT
>是非零时，<TT
CLASS="LITERAL"
>libcrypto</TT
>库将被初始化。
       默认情况下（如果没有调用<CODE
CLASS="FUNCTION"
>PQinitOpenSSL</CODE
>），两个库都会被初始化。
       当 SSL 支持没有被编译时，这个函数也存在但是什么也不做。
      </P
><P
>       如果你的应用使用并且初始化<SPAN
CLASS="APPLICATION"
>OpenSSL</SPAN
>或者它的底层<TT
CLASS="LITERAL"
>libcrypto</TT
>库，
       你<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>必须</I
></SPAN
>在第一次打开数据库连接前以合适的非零参数调用这个函数。
       同时要确保在打开一个数据库连接前已经完成了初始化。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQINITSSL"
></A
><CODE
CLASS="FUNCTION"
>PQinitSSL</CODE
>
      </DT
><DD
><P
>       允许应用选择要初始化哪个安全库。
</P><PRE
CLASS="SYNOPSIS"
>void PQinitSSL(int do_ssl);</PRE
><P>
      </P
><P
>       这个函数等效于<TT
CLASS="LITERAL"
>PQinitOpenSSL(do_ssl, do_ssl)</TT
>。
       这对于要么初始化<SPAN
CLASS="APPLICATION"
>OpenSSL</SPAN
>以及<TT
CLASS="LITERAL"
>libcrypto</TT
>
       要么都不初始化的应用足够用了。
      </P
><P
>       <CODE
CLASS="FUNCTION"
>PQinitSSL</CODE
>从<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.0 就存在了，
       而<CODE
CLASS="FUNCTION"
>PQinitOpenSSL</CODE
>直到<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.4 才被加入，
       因此<CODE
CLASS="FUNCTION"
>PQinitSSL</CODE
>可能对那些需要与旧版本
       <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>一起工作的应用来说更合适。
      </P
></DD
></DL
></DIV
><P>
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-ldap.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-threading.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>连接参数的 LDAP 查找</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>在线程化程序中的行为</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
