<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>pg_type</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="系统目录"
HREF="catalogs.html"><LINK
REL="PREVIOUS"
TITLE="pg_ts_template"
HREF="catalog-pg-ts-template.html"><LINK
REL="NEXT"
TITLE="pg_user_mapping"
HREF="catalog-pg-user-mapping.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/catalogs.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="pg_ts_template"
HREF="catalog-pg-ts-template.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="catalogs.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 50. 系统目录</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="pg_user_mapping"
HREF="catalog-pg-user-mapping.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CATALOG-PG-TYPE"
>50.55. <TT
CLASS="STRUCTNAME"
>pg_type</TT
></A
></H1
><P
>   目录<TT
CLASS="STRUCTNAME"
>pg_type</TT
>存储有关数据类型的信息。基类和枚举类型（标度类型）使用<A
HREF="sql-createtype.html"
>CREATE TYPE</A
>创建，而域使用<A
HREF="sql-createdomain.html"
>CREATE DOMAIN</A
>创建。数据库中的每一个表都会有一个自动创建的组合类型，用于表示表的行结构。也可以使用<TT
CLASS="COMMAND"
>CREATE TYPE AS</TT
>创建组合类型。
  </P
><DIV
CLASS="TABLE"
><A
NAME="AEN109655"
></A
><P
><B
>&#34920; 50-55. <TT
CLASS="STRUCTNAME"
>pg_type</TT
>的列</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>名称</TH
><TH
>类型</TH
><TH
>引用</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>oid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>&nbsp;</TD
><TD
>行标识符（隐藏属性，必须被显式选择才会显示）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>&nbsp;</TD
><TD
>数据类型的名字</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typnamespace</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-namespace.html"
><TT
CLASS="STRUCTNAME"
>pg_namespace</TT
></A
>.oid</TT
></TD
><TD
>       包含此类型的名字空间的OID
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typowner</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-authid.html"
><TT
CLASS="STRUCTNAME"
>pg_authid</TT
></A
>.oid</TT
></TD
><TD
>类型的拥有者</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typlen</TT
></TD
><TD
><TT
CLASS="TYPE"
>int2</TT
></TD
><TD
>&nbsp;</TD
><TD
>       对于一个固定尺寸的类型，<TT
CLASS="STRUCTFIELD"
>typlen</TT
>是该类型内部表示的字节数。对于一个变长类型，<TT
CLASS="STRUCTFIELD"
>typlen</TT
>为负值。-1表示一个<SPAN
CLASS="QUOTE"
>"varlena"</SPAN
>类型（具有长度字），-2表示一个以空值结尾的C字符串。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typbyval</TT
></TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
>&nbsp;</TD
><TD
>       <TT
CLASS="STRUCTFIELD"
>typbyval</TT
>判断内部例程传递这个类型的数值时是通过传值还是传引用。如果<TT
CLASS="STRUCTFIELD"
>typlen</TT
>不是1、2或4（或者在Datum为8字节的机器上为8），因此<TT
CLASS="STRUCTFIELD"
>typbyval</TT
>最好是假。变长类型总是传引用。注意即使长度允许传值， <TT
CLASS="STRUCTFIELD"
>typbyval</TT
>也可以为假。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typtype</TT
></TD
><TD
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
>&nbsp;</TD
><TD
>       <TT
CLASS="STRUCTFIELD"
>typtype</TT
>可以是：
       <TT
CLASS="LITERAL"
>b</TT
>表示一个基类，
       <TT
CLASS="LITERAL"
>c</TT
>表示一个组合类型（例如一个表的行类型），
       <TT
CLASS="LITERAL"
>d</TT
>表示一个域，
       <TT
CLASS="LITERAL"
>e</TT
>表示一个枚举类型，
       <TT
CLASS="LITERAL"
>p</TT
>表示一个伪类型，或
       <TT
CLASS="LITERAL"
>r</TT
>表示一个范围类型。
       另请参阅<TT
CLASS="STRUCTFIELD"
>typrelid</TT
>和<TT
CLASS="STRUCTFIELD"
>typbasetype</TT
>.
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typcategory</TT
></TD
><TD
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
>&nbsp;</TD
><TD
>       <TT
CLASS="STRUCTFIELD"
>typcategory</TT
>是一种任意的数据类型分类，它被分析器用来决定哪种隐式转换<SPAN
CLASS="QUOTE"
>"更好"</SPAN
>。参见<A
HREF="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE"
>&#34920; 50-56</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typispreferred</TT
></TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
>&nbsp;</TD
><TD
>       如果此类型在它的<TT
CLASS="STRUCTFIELD"
>typcategory</TT
>中是一个更好的转换目标，此列为真
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typisdefined</TT
></TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
>&nbsp;</TD
><TD
>       如果此类型已被定义则为真，如果此类型只是一个表示还未定义类型的占位符则为假。当<TT
CLASS="STRUCTFIELD"
>typisdefined</TT
>为假，除了类型名字、名字空间和OID之外什么都不能被依赖。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typdelim</TT
></TD
><TD
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
>&nbsp;</TD
><TD
>       在分析数组输入时，分隔两个此类型值的字符。注意该分隔符是与数组元素数据类型相关联的， 而不是和数组的数据类型关联。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typrelid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-class.html"
><TT
CLASS="STRUCTNAME"
>pg_class</TT
></A
>.oid</TT
></TD
><TD
>       如果这是一个复合类型（见<TT
CLASS="STRUCTFIELD"
>typtype</TT
>）， 那么这个列指向<TT
CLASS="STRUCTNAME"
>pg_class</TT
>中定义对应表的项（对于自由存在的复合类型，<TT
CLASS="STRUCTNAME"
>pg_class</TT
>项并不表示一个表，但不管怎样该类型的<TT
CLASS="STRUCTNAME"
>pg_attribute</TT
>项需要链接到它）。对非复合类型此列为零。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typelem</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-type.html"
><TT
CLASS="STRUCTNAME"
>pg_type</TT
></A
>.oid</TT
></TD
><TD
>       如果<TT
CLASS="STRUCTFIELD"
>typelem</TT
>不为0，则它标识<TT
CLASS="STRUCTNAME"
>pg_type</TT
>里面的另外一行。 当前类型可以被加上下标得到一个值为类型<TT
CLASS="STRUCTFIELD"
>typelem</TT
>的数组来描述。 一个<SPAN
CLASS="QUOTE"
>"真的"</SPAN
>数组类型是变长的（<TT
CLASS="STRUCTFIELD"
>typlen</TT
> = -1），但是一些定长的（<TT
CLASS="STRUCTFIELD"
>typlen</TT
> &gt; 0）类型也拥有非零的<TT
CLASS="STRUCTFIELD"
>typelem</TT
>，比如<TT
CLASS="TYPE"
>name</TT
>和<TT
CLASS="TYPE"
>point</TT
>。 如果一个定长类型拥有一个<TT
CLASS="STRUCTFIELD"
>typelem</TT
>， 则它的内部形式必须是某个<TT
CLASS="STRUCTFIELD"
>typelem</TT
>数据类型的值，不能有其它数据。变长数组类型有一个由该数组子例程定义的头。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typarray</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-type.html"
><TT
CLASS="STRUCTNAME"
>pg_type</TT
></A
>.oid</TT
></TD
><TD
>       如果<TT
CLASS="STRUCTFIELD"
>typarray</TT
>不是0，则它标识<TT
CLASS="STRUCTNAME"
>pg_type</TT
>中的另一行，这一行是一个将此类型作为元素的<SPAN
CLASS="QUOTE"
>"真的"</SPAN
>数组类型
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typinput</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-proc.html"
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></A
>.oid</TT
></TD
><TD
>输入转换函数（文本格式）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typoutput</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-proc.html"
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></A
>.oid</TT
></TD
><TD
>输出转换函数（文本格式）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typreceive</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-proc.html"
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></A
>.oid</TT
></TD
><TD
>输入转换函数（二进制格式），如果没有则为0</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typsend</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-proc.html"
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></A
>.oid</TT
></TD
><TD
>输出转换函数（二进制格式），如果没有则为0</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typmodin</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-proc.html"
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></A
>.oid</TT
></TD
><TD
>类型修改器输入函数，如果类型没有提供修改器则为0</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typmodout</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-proc.html"
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></A
>.oid</TT
></TD
><TD
>类型修改器输出函数，如果类型没有提供修改器则为0</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typanalyze</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-proc.html"
><TT
CLASS="STRUCTNAME"
>pg_proc</TT
></A
>.oid</TT
></TD
><TD
>自定义<TT
CLASS="COMMAND"
>ANALYZE</TT
>函数，0表示使用标准函数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typalign</TT
></TD
><TD
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
>&nbsp;</TD
><TD
><P
>&#13;       <TT
CLASS="STRUCTFIELD"
>typalign</TT
>是当存储此类型值时要求的对齐性质。它应用于磁盘存储以及该值在 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>内部的大多数表现形式。 如果数值是连续存放的，比如在磁盘上的一个完整行，在这种类型的数据前会插入填充，这样它就可以按照指定边界存储。 对齐引用是该序列中第一个数据的开头。对齐引用是序列中第一个数据的开始。
      </P
>

      <P
>       可能的值有：
       <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>c</TT
> = <TT
CLASS="TYPE"
>char</TT
>对齐，即不需要对齐。</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>s</TT
> = <TT
CLASS="TYPE"
>short</TT
>对齐（在大部分机器上为2字节）。</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>i</TT
> = <TT
CLASS="TYPE"
>int</TT
>对齐（在大部分机器上为4字节）。</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>d</TT
> = <TT
CLASS="TYPE"
>double</TT
>对齐（在很多机器上为8字节，但绝不是全部）。</P
></LI
></UL
><P>
      </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        对于系统表中使用的类型，很关键的是，<TT
CLASS="STRUCTNAME"
>pg_type</TT
>中定义的尺寸和对齐方式要和编译器在表示表行的结构中布局列的方式保持一致。
       </P
></BLOCKQUOTE
></DIV
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typstorage</TT
></TD
><TD
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
>&nbsp;</TD
><TD
><P
>       如果一个变长类型（<TT
CLASS="STRUCTFIELD"
>typlen</TT
> = -1）可被TOAST，<TT
CLASS="STRUCTFIELD"
>typstorage</TT
>说明这种类型的列应采取的默认策略。可能的值是：
       <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>p</TT
>：值必须平面存储。</P
></LI
><LI
><P
>          <TT
CLASS="LITERAL"
>e</TT
>：值可以被存储在一个<SPAN
CLASS="QUOTE"
>"二级"</SPAN
>关系（如果有，见<TT
CLASS="LITERAL"
>pg_class.reltoastrelid</TT
>）。
         </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>m</TT
>：值可以被压缩线内存储。</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>x</TT
>：值可以被压缩线内存储或存储在<SPAN
CLASS="QUOTE"
>"二级"</SPAN
>存储。</P
></LI
></UL
><P>
       注意<TT
CLASS="LITERAL"
>m</TT
>列也可以被移动到二级存储，但只能是作为最后一种方案（<TT
CLASS="LITERAL"
>e</TT
>和<TT
CLASS="LITERAL"
>x</TT
>列会先被移动）。
      </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typnotnull</TT
></TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
>&nbsp;</TD
><TD
><P
>       <TT
CLASS="STRUCTFIELD"
>typnotnull</TT
>表示类型上的一个非空约束。只用于域。
      </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typbasetype</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-type.html"
><TT
CLASS="STRUCTNAME"
>pg_type</TT
></A
>.oid</TT
></TD
><TD
><P
>       如果这是一个域（见<TT
CLASS="STRUCTFIELD"
>typtype</TT
>），则<TT
CLASS="STRUCTFIELD"
>typbasetype</TT
>标识这个域基于的类。如果此类不是一个域则为0。
      </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typtypmod</TT
></TD
><TD
><TT
CLASS="TYPE"
>int4</TT
></TD
><TD
>&nbsp;</TD
><TD
><P
>       域使用<TT
CLASS="STRUCTFIELD"
>typtypmod</TT
>来记录被应用于它们基类型的<TT
CLASS="LITERAL"
>typmod</TT
>（如果基类型不使用<TT
CLASS="LITERAL"
>typmod</TT
>，则为-1）。如果此类型不是一个域则为-1。
      </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typndims</TT
></TD
><TD
><TT
CLASS="TYPE"
>int4</TT
></TD
><TD
>&nbsp;</TD
><TD
><P
>       对于一个数组上的域，<TT
CLASS="STRUCTFIELD"
>typndims</TT
>是数组维度数（即，<TT
CLASS="STRUCTFIELD"
>typbasetype</TT
>是一个数组类型）。除数组类型上的域之外的类型的此列为0。
       </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typcollation</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="LITERAL"
><A
HREF="catalog-pg-collation.html"
><TT
CLASS="STRUCTNAME"
>pg_collation</TT
></A
>.oid</TT
></TD
><TD
><P
>       <TT
CLASS="STRUCTFIELD"
>typcollation</TT
>指定此类型的排序规则。如果类型不支持排序规则，此列为0。一个支持排序规则的基类型此列值为<TT
CLASS="SYMBOL"
>DEFAULT_COLLATION_OID</TT
>。如果一个可排序类型上的域被指定了一个排序规则，该域可能使用某些其他排序规则OID。
      </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typdefaultbin</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_node_tree</TT
></TD
><TD
>&nbsp;</TD
><TD
><P
>       如果<TT
CLASS="STRUCTFIELD"
>typdefaultbin</TT
>为非空，那么它是 该类型默认表达式的<CODE
CLASS="FUNCTION"
>nodeToString()</CODE
>表现形式。这个列只用于域。
      </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typdefault</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>&nbsp;</TD
><TD
><P
>       如果某类型没有相关默认值，那么<TT
CLASS="STRUCTFIELD"
>typdefault</TT
>为空。如果<TT
CLASS="STRUCTFIELD"
>typdefaultbin</TT
>不为空， 那么<TT
CLASS="STRUCTFIELD"
>typdefault</TT
>必须包含一个<TT
CLASS="STRUCTFIELD"
>typdefaultbin</TT
>所指的默认表达式的人类可读的版本。 如果<TT
CLASS="STRUCTFIELD"
>typdefaultbin</TT
>为空但<TT
CLASS="STRUCTFIELD"
>typdefault</TT
>不为空，则<TT
CLASS="STRUCTFIELD"
>typdefault</TT
>是该类型默认值的外部表现形式， 它可以被交给该类型的输入转换器来产生一个常量。
      </P
></TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>typacl</TT
></TD
><TD
><TT
CLASS="TYPE"
>aclitem[]</TT
></TD
><TD
>&nbsp;</TD
><TD
>       访问权限，另请参阅<A
HREF="sql-grant.html"
>GRANT</A
>和<A
HREF="sql-revoke.html"
>REVOKE</A
>
      </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <A
HREF="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE"
>&#34920; 50-56</A
>列出了<TT
CLASS="STRUCTFIELD"
>typcategory</TT
>的系统定义值。任何未来对此列表的增加都将是大写ASCII字母。所有其他ASCII字符都保留给用户定义的类别。
  </P
><DIV
CLASS="TABLE"
><A
NAME="CATALOG-TYPCATEGORY-TABLE"
></A
><P
><B
>&#34920; 50-56. <TT
CLASS="STRUCTFIELD"
>typcategory</TT
>编码</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>编码</TH
><TH
>类别</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>A</TT
></TD
><TD
>数组类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>B</TT
></TD
><TD
>布尔类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>C</TT
></TD
><TD
>组合类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>D</TT
></TD
><TD
>日期/时间类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>E</TT
></TD
><TD
>枚举类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>G</TT
></TD
><TD
>几何类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>I</TT
></TD
><TD
>网络地址类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>N</TT
></TD
><TD
>数字类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>P</TT
></TD
><TD
>伪类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>R</TT
></TD
><TD
>范围类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>S</TT
></TD
><TD
>字符串类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>T</TT
></TD
><TD
>时间间隔类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>U</TT
></TD
><TD
>用户定义类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>V</TT
></TD
><TD
>位串类型</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>X</TT
></TD
><TD
><TT
CLASS="TYPE"
>未知</TT
>类型</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="catalog-pg-ts-template.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="catalog-pg-user-mapping.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><TT
CLASS="STRUCTNAME"
>pg_ts_template</TT
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="catalogs.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><TT
CLASS="STRUCTNAME"
>pg_user_mapping</TT
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
