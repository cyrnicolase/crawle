<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>异步提示</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C 库"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="快速路径接口"
HREF="libpq-fastpath.html"><LINK
REL="NEXT"
TITLE="COPY命令相关的函数"
HREF="libpq-copy.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/libpq.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="快速路径接口"
HREF="libpq-fastpath.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 32. <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C 库</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="COPY命令相关的函数"
HREF="libpq-copy.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-NOTIFY"
>32.8. 异步提示</A
></H1
><P
>   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>通过<TT
CLASS="COMMAND"
>LISTEN</TT
>和<TT
CLASS="COMMAND"
>NOTIFY</TT
>命令提供了异步通知。一个客户端会话用<TT
CLASS="COMMAND"
>LISTEN</TT
>命令在一个特定的通知频道中注册它感兴趣的通知（也可以用<TT
CLASS="COMMAND"
>UNLISTEN</TT
>命令停止监听）。当任何会话执行一个带有特定频道名的<TT
CLASS="COMMAND"
>NOTIFY</TT
>命令时，所有正在监听该频道的会话会被异步通知。可以传递一个<SPAN
CLASS="QUOTE"
>"载荷"</SPAN
>字符串来与监听者沟通附加的数据。
  </P
><P
>   <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>应用把<TT
CLASS="COMMAND"
>LISTEN</TT
>、<TT
CLASS="COMMAND"
>UNLISTEN</TT
>和<TT
CLASS="COMMAND"
>NOTIFY</TT
>命令作为通常的 SQL 命令提交。 随后通过调用<CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>来检测<TT
CLASS="COMMAND"
>NOTIFY</TT
>消息的到达。
  </P
><P
>   函数<CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>从来自服务器的未处理通知消息列表中返回下一个通知。如果没有待处理的信息则返回一个空指针。一旦<CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>返回一个通知，该通知会被认为已处理并且将被从通知列表中删除。

</P><PRE
CLASS="SYNOPSIS"
>PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
} PGnotify;</PRE
><P>

   在处理完<CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>返回的<TT
CLASS="STRUCTNAME"
>PGnotify</TT
>对象后，别忘了用<CODE
CLASS="FUNCTION"
>PQfreemem</CODE
>把它释放。释放<TT
CLASS="STRUCTNAME"
>PGnotify</TT
>指针就足够了；<TT
CLASS="STRUCTFIELD"
>relname</TT
>和<TT
CLASS="STRUCTFIELD"
>extra</TT
>域并不代表独立分配的内存（这些域的名称是历史性的，尤其是频道名称与关系名称没有什么联系）。
  </P
><P
>   <A
HREF="libpq-example.html#LIBPQ-EXAMPLE-2"
>&#20363; 32-2</A
>给出了一个例子程序展示异步通知的使用。
  </P
><P
>   <CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>实际上并不从服务器读取数据；它只是返回被另一个<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>函数之前吸收的消息。在以前的<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>版本中，及时收到<TT
CLASS="COMMAND"
>NOTIFY</TT
>消息的唯一方法是持续地提交命令，即使是空命令也可以，并且在每次<CODE
CLASS="FUNCTION"
>PQexec</CODE
>后检查<CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>。 虽然这个方法还能用，但是由于太过浪费处理能力已被废弃。
  </P
><P
>   当你没有可用的命令提交时，一种更好的检查<TT
CLASS="COMMAND"
>NOTIFY</TT
>消息的方法是调用<CODE
CLASS="FUNCTION"
>PQconsumeInput</CODE
>，然后检查<CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>。你可以使用<CODE
CLASS="FUNCTION"
>select()</CODE
>来等待服务器数据到达，这样在无事可做时可以不浪费<ACRONYM
CLASS="ACRONYM"
>CPU</ACRONYM
>能力（参考<CODE
CLASS="FUNCTION"
>PQsocket</CODE
>来获得用于<CODE
CLASS="FUNCTION"
>select()</CODE
>的文件描述符）。注意不管是用<CODE
CLASS="FUNCTION"
>PQsendQuery</CODE
>/<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>提交命令还是简单地使用<CODE
CLASS="FUNCTION"
>PQexec</CODE
>，这种方法都能正常工作。不过，你应该记住在每次<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>或<CODE
CLASS="FUNCTION"
>PQexec</CODE
>之后检查<CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>，看看在命令的处理过程中是否有通知到达。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-fastpath.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-copy.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>快速路径接口</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><TT
CLASS="COMMAND"
>COPY</TT
>命令相关的函数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
