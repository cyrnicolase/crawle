<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>统计收集器</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="监控数据库活动"
HREF="monitoring.html"><LINK
REL="PREVIOUS"
TITLE="标准 Unix 工具"
HREF="monitoring-ps.html"><LINK
REL="NEXT"
TITLE="查看锁"
HREF="monitoring-locks.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/monitoring.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="标准 Unix 工具"
HREF="monitoring-ps.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="monitoring.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 28. 监控数据库活动</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="查看锁"
HREF="monitoring-locks.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="MONITORING-STATS"
>28.2. 统计收集器</A
></H1
><P
>   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的<I
CLASS="FIRSTTERM"
>统计收集器</I
>是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
  </P
><P
>   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>也支持报告有关系统正在干什么的
   动态信息，例如当前正在被其他服务器进程执行的命令以及系统中存在哪些其他连接。
   这个功能是独立于收集器进程存在的。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MONITORING-STATS-SETUP"
>28.2.1. 统计收集配置</A
></H2
><P
>   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在<TT
CLASS="FILENAME"
>postgresql.conf</TT
>中设置（关于设置配置参数的细节请见<A
HREF="runtime-config.html"
>第 19 &#31456;</A
>）。
  </P
><P
>   参数<A
HREF="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES"
>track_activities</A
>允许监控当前被任意服务器进程执行的命令。
  </P
><P
>   参数<A
HREF="runtime-config-statistics.html#GUC-TRACK-COUNTS"
>track_counts</A
>控制是否收集关于表和索引访问的统计信息。
  </P
><P
>   参数<A
HREF="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS"
>track_functions</A
>启用对用户定义函数使用的跟踪。
  </P
><P
>   参数<A
HREF="runtime-config-statistics.html#GUC-TRACK-IO-TIMING"
>track_io_timing</A
>启用对块读写次数的监控。
  </P
><P
>   通常这些参数被设置在<TT
CLASS="FILENAME"
>postgresql.conf</TT
>中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用<A
HREF="sql-set.html"
>SET</A
>命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用<TT
CLASS="COMMAND"
>SET</TT
>来改变这些参数）。
  </P
><P
>   统计收集器通过临时文件将收集到的信息传送给其他<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>进程。这些文件被存储在名字由<A
HREF="runtime-config-statistics.html#GUC-STATS-TEMP-DIRECTORY"
>stats_temp_directory</A
>参数指定的目录中，默认是<TT
CLASS="FILENAME"
>pg_stat_tmp</TT
>。为了得到更好的性能，<TT
CLASS="VARNAME"
>stats_temp_directory</TT
>可以被指向一个基于 RAM 的文件系统来降低物理 I/O 需求。当服务器被干净地关闭时，一份统计数据的永久拷贝被存储在<TT
CLASS="FILENAME"
>pg_stat</TT
>子目录中，这样在服务器重启后统计信息能被保持。当在服务器启动时执行恢复时（例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MONITORING-STATS-VIEWS"
>28.2.2. 查看统计信息</A
></H2
><P
>   <A
HREF="monitoring-stats.html#MONITORING-STATS-DYNAMIC-VIEWS-TABLE"
>&#34920; 28-1</A
>中列出了一些预定义视图
   可以用来显示系统的当前状态。
   <A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
>&#34920; 28-2</A
>中列出了另一些视图可以
   显示统计收集的结果。你也可以使用底层统计函数（在
   <A
HREF="monitoring-stats.html#MONITORING-STATS-FUNCTIONS"
>第 28.2.3 &#33410;</A
>中讨论）来建立自定义的视图。
  </P
><P
>   在使用统计信息监控收集到的数据时，你必须了解这些信息并非是实时更新的。每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每<TT
CLASS="VARNAME"
>PGSTAT_STAT_INTERVAL</TT
>毫秒（缺省为 500ms，除非在编译服务器的时候修改过）发送一 次新的报告。因此显示的信息总是落后于实际活动。但是由<TT
CLASS="VARNAME"
>track_activities</TT
>收集的当前查询信息总是最新的。
  </P
><P
>   另一个重点是当一个服务器进程被要求显示任何这些统计信息时，它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，直到它的当前事务的结尾。因此只要你继续当前事务，统计数据将会一直显示静态信息。相似地，当任何关于所有会话的当前查询的信息在一个事务中第一次被请求时，这样的信息将被收集。并且在整个事务期间将显示相同的信息。这是一种特性而非缺陷，因为它允许你在该统计信息上执行多个查询并且关联结果而不用担心那些数字会在你不知情的情况下改变。但是如果你希望用每个查询都看到新结果，要确保在任何事务块之外做那些查询。或者，你可以调用<CODE
CLASS="FUNCTION"
>pg_stat_clear_snapshot</CODE
>()，那将丢弃当前事务的统计快照（如果有）。下一次对统计性信息的使用将导致获取一个新的快照。
  </P
><P
>   一个事务也可以在视图<TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
>、<TT
CLASS="STRUCTNAME"
>pg_stat_xact_sys_tables</TT
>、<TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_tables</TT
>和<TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_functions</TT
>中看到它自己的统计信息（还没有被传送给收集器）。这些数字并不像上面所述的那样行动，相反它们在事务期间持续被更新。
  </P
><DIV
CLASS="TABLE"
><A
NAME="MONITORING-STATS-DYNAMIC-VIEWS-TABLE"
></A
><P
><B
>&#34920; 28-1. 动态统计视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>视图名称</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
>       <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>
       
      </TD
><TD
>       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见<A
HREF="monitoring-stats.html#PG-STAT-ACTIVITY-VIEW"
>pg_stat_activity</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
></TD
><TD
>每一个 WAL 发送进程一行，显示有关到该发送进程
      连接的后备服务器的复制的统计信息。详见
      <A
HREF="monitoring-stats.html#PG-STAT-REPLICATION-VIEW"
>pg_stat_replication</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_wal_receiver</TT
></TD
><TD
>只有一行，显示来自 WAL 接收器所连接服务器的有关该接收器的统计信息。详见<A
HREF="monitoring-stats.html#PG-STAT-WAL-RECEIVER-VIEW"
>pg_stat_wal_receiver</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_ssl</TT
></TD
><TD
>每个连接（常规连接和复制连接）一行，
      显示有关在此连接上使用的 SSL 的信息。
      详见<A
HREF="monitoring-stats.html#PG-STAT-SSL-VIEW"
>pg_stat_ssl</A
>。
      </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="MONITORING-STATS-VIEWS-TABLE"
></A
><P
><B
>&#34920; 28-2. 已收集统计信息的视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>视图名称</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_archiver</TT
></TD
><TD
>只有一行，显示有关 WAL 归档进程活动的统计信息。详见<A
HREF="monitoring-stats.html#PG-STAT-ARCHIVER-VIEW"
>pg_stat_archiver</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
></TD
><TD
>只有一行，显示有关后台写进程的活动的统计信息。详见<A
HREF="monitoring-stats.html#PG-STAT-BGWRITER-VIEW"
>pg_stat_bgwriter</A
>。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_database</TT
></TD
><TD
>每个数据库一行，显示数据库范围的统计信息。详见<A
HREF="monitoring-stats.html#PG-STAT-DATABASE-VIEW"
>pg_stat_database</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_database_conflicts</TT
></TD
><TD
>       每个数据库一行，显示数据库范围的统计信息，
       这些信息的内容是关于由于与后备服务器的恢复过程
       发生冲突而被取消的查询。详见
       <A
HREF="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW"
>pg_stat_database_conflicts</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
></TD
><TD
>       当前数据库中每个表一行，显示有关访问指定表的统计信息。详见<A
HREF="monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW"
>pg_stat_all_tables</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_sys_tables</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>一样，但只显示系统表。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_user_tables</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>一样，但只显示用户表。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>相似，但计数动作只在当前事务内发生（还<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>没有</I
></SPAN
>被包括在<TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_sys_tables</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
>一样，但只显示系统表。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_tables</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_xact_all_tables</TT
>一样，但只显示用户表。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
></TD
><TD
>       当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见<A
HREF="monitoring-stats.html#PG-STAT-ALL-INDEXES-VIEW"
>pg_stat_all_indexes</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_sys_indexes</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>一样，但只显示系统表上的索引。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_user_indexes</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>一样，但只显示用户表上的索引。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
></TD
><TD
>       当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。
       当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见<A
HREF="monitoring-stats.html#PG-STATIO-ALL-TABLES-VIEW"
>pg_statio_all_tables</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_sys_tables</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
>一样，但只显示系统表。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_user_tables</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
>一样，但只显示用户表。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
></TD
><TD
>       当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。
       当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见<A
HREF="monitoring-stats.html#PG-STATIO-ALL-INDEXES-VIEW"
>pg_statio_all_indexes</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_sys_indexes</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
>一样，但只显示系统表上的索引。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_user_indexes</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
>一样，但只显示用户表上的索引。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
></TD
><TD
>       当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。
       当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见<A
HREF="monitoring-stats.html#PG-STATIO-ALL-SEQUENCES-VIEW"
>pg_statio_all_sequences</A
>。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_sys_sequences</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
>一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_statio_user_sequences</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
>一样，但只显示用户序列。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
></TD
><TD
>       对于所有跟踪功能，函数的OID，模式，名称，数量 通话总时间，和自我的时间。自我时间是 在函数本身所花费的时间量，总时间包括 它调用函数所花费的时间。时间值以毫秒为单位。
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。详见<A
HREF="monitoring-stats.html#PG-STAT-USER-FUNCTIONS-VIEW"
>pg_stat_user_functions</A
>。
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_xact_user_functions</TT
></TD
><TD
>和<TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
>相似，但是只统计在当前事务期间的调用（还<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>没有</I
></SPAN
>被包括在<TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
>中）。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTNAME"
>pg_stat_progress_vacuum</TT
></TD
><TD
>每个运行<TT
CLASS="COMMAND"
>VACUUM</TT
>的后端（包括自动清理工作者进程）一行，显示当前的进度。见<A
HREF="progress-reporting.html#VACUUM-PROGRESS-REPORTING"
>第 28.4.1 &#33410;</A
>。</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </P
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_</TT
>系列视图主要用于判断缓冲区的效果。当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。但是，这些统计信息并没有给出所有的事情：由于<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>处理磁盘 I/O 的方式，不在<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>缓冲区中的数据库仍然驻留在内核的 I/O 缓存中，并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> I/O 行为更多细节的用户将<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ACTIVITY-VIEW"
></A
><P
><B
>&#34920; 28-3. <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
> 视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>这个后端连接到的数据库的OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个后端连接到的数据库的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>pid</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>这个后端的进程 ID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usesysid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>登录到这个后端的用户的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usename</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>登录到这个后端的用户的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>application_name</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>连接到这个后端的应用的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_addr</TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_hostname</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>已连接的客户端的主机名，由<TT
CLASS="STRUCTFIELD"
>client_addr</TT
>的反向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有<A
HREF="runtime-config-logging.html#GUC-LOG-HOSTNAME"
>log_hostname</A
>被启用时才会非空。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_port</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为<TT
CLASS="LITERAL"
>-1</TT
>
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>backend_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>这个进程被启动的时间，即客户端是什么时候连接到服务器的
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>xact_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于<TT
CLASS="STRUCTFIELD"
>query_start</TT
>。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>query_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>当前活动查询被开始的时间，如果<TT
CLASS="STRUCTFIELD"
>state</TT
>不是<TT
CLASS="LITERAL"
>active</TT
>，这个域为上一个查询被开始的时间
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>state_change</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
><TT
CLASS="STRUCTFIELD"
>state</TT
>上一次被改变的时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>wait_event_type</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>后端正在等待的事件类型，如果不存在则为 NULL。可能的值有：
       <P
></P
><UL
><LI
><P
>          <TT
CLASS="LITERAL"
>LWLockNamed</TT
>：后端正在等待一个特定命名的轻量级锁。每一个这样的锁保护共享内存中的一个特定数据结构。<TT
CLASS="LITERAL"
>wait_event</TT
>将包含该轻量级锁的名称。
         </P
></LI
><LI
><P
>          <TT
CLASS="LITERAL"
>LWLockTranche</TT
>：后端正在等待一组相关轻量级锁中的一个。该组中的所有锁都执行一种相似的功能。<TT
CLASS="LITERAL"
>wait_event</TT
>将标识这个组中锁的大体目的。
         </P
></LI
><LI
><P
>          <TT
CLASS="LITERAL"
>Lock</TT
>：后端正在等待一个重量级锁。重量级锁，也称为锁管理器锁或者简单锁，主要保护 SQL 可见的对象，例如表。不过，它们也被用于确保特定内部操作的互斥，例如关系扩展。<TT
CLASS="LITERAL"
>wait_event</TT
>将标识等待的锁的类型。
         </P
></LI
><LI
><P
>          <TT
CLASS="LITERAL"
>BufferPin</TT
>：服务器进程正在等待访问一个数据缓冲区，而此时没有其他进程正在检查该缓冲区。如果另一个进程持有一个最终从要访问的缓冲区中读取数据的打开的游标，缓冲区 pin 等待可能会被拖延。
         </P
></LI
></UL
>
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>wait_event</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>如果后端当前正在等待，则是等待事件的名称，否则为 NULL。详见<A
HREF="monitoring-stats.html#WAIT-EVENT-TABLE"
>&#34920; 28-4</A
>。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>state</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>这个后端的当前总体状态。可能的值是：
       <P
></P
><UL
><LI
><P
>           <TT
CLASS="LITERAL"
>active</TT
>：后端正在执行一个查询。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>idle</TT
>：后端正在等待一个新的客户端命令。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>idle in transaction</TT
>：后端在一个事务中，但是当前没有正在执行一个查询。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>idle in transaction (aborted)</TT
>：这个状态与<TT
CLASS="LITERAL"
>idle in transaction</TT
>相似，不过在该事务中的一个语句导致了一个错误。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>fastpath function call</TT
>：后端正在执行一个 fast-path 函数。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>disabled</TT
>：如果在这个后端中<A
HREF="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES"
>track_activities</A
>被禁用，则报告这个状态。
          </P
></LI
></UL
>
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>backend_xid</TT
></TD
><TD
><TT
CLASS="TYPE"
>xid</TT
></TD
><TD
>这个后端的顶层事务标识符（如果存在）。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>backend_xmin</TT
></TD
><TD
><TT
CLASS="TYPE"
>xid</TT
></TD
><TD
>当前后端的<TT
CLASS="LITERAL"
>xmin</TT
>范围。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>query</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>这个后端最近查询的文本。如果<TT
CLASS="STRUCTFIELD"
>state</TT
>为<TT
CLASS="LITERAL"
>active</TT
>，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。
     </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>视图将为每一个服务器进程有一行，显示与该进程的当前活动相关的信息。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    <TT
CLASS="STRUCTFIELD"
>wait_event</TT
>和<TT
CLASS="STRUCTFIELD"
>state</TT
>列是独立的。如果一个后端处于<TT
CLASS="LITERAL"
>active</TT
>状态，它可能是也可能不是某个事件上的<TT
CLASS="LITERAL"
>waiting</TT
>。如果状态是<TT
CLASS="LITERAL"
>active</TT
>并且<TT
CLASS="STRUCTFIELD"
>wait_event</TT
>为非空，它意味着一个查询正在被执行，但是它被阻塞在系统中某处。
   </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="WAIT-EVENT-TABLE"
></A
><P
><B
>&#34920; 28-4. <TT
CLASS="STRUCTNAME"
>wait_event</TT
> 描述</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>等待事件类型</TH
><TH
>等待事件名称</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
ROWSPAN="42"
><TT
CLASS="LITERAL"
>LWLockNamed</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ShmemIndexLock</TT
></TD
><TD
>正等待在共享内存中查找或者分配空间。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>OidGenLock</TT
></TD
><TD
>正等待分配或者赋予一个 OID。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>XidGenLock</TT
></TD
><TD
>正等待分配或者赋予一个事务 ID。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ProcArrayLock</TT
></TD
><TD
>正等待在事务结尾得到一个快照或者清除事务 ID。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SInvalReadLock</TT
></TD
><TD
>正等待从共享无效消息队列中检索或者移除消息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SInvalWriteLock</TT
></TD
><TD
>正等待在共享无效消息队列中增加一个消息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>WALBufMappingLock</TT
></TD
><TD
>正等待在 WAL 缓冲区中替换一个页面。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>WALWriteLock</TT
></TD
><TD
>正等待 WAL 缓冲区被写入到磁盘。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ControlFileLock</TT
></TD
><TD
>正等待读取或者更新控制文件或创建一个新的 WAL 文件。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>CheckpointLock</TT
></TD
><TD
>正等待执行检查点。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>CLogControlLock</TT
></TD
><TD
>正等待读取或者更新事务状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SubtransControlLock</TT
></TD
><TD
>正等待读取或者更新子事务信息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>MultiXactGenLock</TT
></TD
><TD
>正等待读取或者更新共享多事务状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>MultiXactOffsetControlLock</TT
></TD
><TD
>正等待读取或者更新多事务偏移映射。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>MultiXactMemberControlLock</TT
></TD
><TD
>正等待读取或者更新多事务成员映射。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>RelCacheInitLock</TT
></TD
><TD
>正等待读取或者写入关系缓冲区初始化文件。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>CheckpointerCommLock</TT
></TD
><TD
>正等待管理 fsync 请求。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>TwoPhaseStateLock</TT
></TD
><TD
>正等待读取或者更新预备事务的状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>TablespaceCreateLock</TT
></TD
><TD
>正等待创建或者删除表空间。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>BtreeVacuumLock</TT
></TD
><TD
>正等待读取或者更新一个 B-树索引的 vacuum 相关的信息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>AddinShmemInitLock</TT
></TD
><TD
>正等待管理共享内存中的空间分配。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>AutovacuumLock</TT
></TD
><TD
>自动清理工作者或者启动器正等待更新或者读取自动清理工作者的当前状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>AutovacuumScheduleLock</TT
></TD
><TD
>正等待确认选中进行清理的表仍需要清理。
         </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SyncScanLock</TT
></TD
><TD
>正等待为同步扫描得到一个表上扫描的开始位置。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>RelationMappingLock</TT
></TD
><TD
>正等待更新用来存储目录到文件节点映射的关系映射文件。
         </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>AsyncCtlLock</TT
></TD
><TD
>正等待读取或者更新共享通知状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>AsyncQueueLock</TT
></TD
><TD
>正等待读取或者更新通知消息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SerializableXactHashLock</TT
></TD
><TD
>正等待检索或者存储有关可序列化事务的信息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SerializableFinishedListLock</TT
></TD
><TD
>正等待访问已结束可序列化事务的列表。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SerializablePredicateLockListLock</TT
></TD
><TD
>正等待在由可序列化事务持有的所列表上执行一个操作。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>OldSerXidLock</TT
></TD
><TD
>正等待读取或者记录冲突的可序列化事务。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SyncRepLock</TT
></TD
><TD
>正等待读取或者更新有关同步复制的信息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>BackgroundWorkerLock</TT
></TD
><TD
>正等待读取或者更新后台工作者状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>DynamicSharedMemoryControlLock</TT
></TD
><TD
>正等待读取或者更新动态共享内存状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>AutoFileLock</TT
></TD
><TD
>正等待更新<TT
CLASS="FILENAME"
>postgresql.auto.conf</TT
>文件。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ReplicationSlotAllocationLock</TT
></TD
><TD
>正等待分配或者释放一个复制槽。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ReplicationSlotControlLock</TT
></TD
><TD
>正等待读取或者更新复制槽状态。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>CommitTsControlLock</TT
></TD
><TD
>正等待读取或者更新事务提交时间戳。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>CommitTsLock</TT
></TD
><TD
>正等待读取或者更新事务时间戳的最新设置值。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ReplicationOriginLock</TT
></TD
><TD
>正等待设置、删除或者使用复制源头。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>MultiXactTruncationLock</TT
></TD
><TD
>正等待读取或者阶段多事务信息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>OldSnapshotTimeMapLock</TT
></TD
><TD
>正等待读取或者更新旧的快照控制信息。</TD
></TR
><TR
><TD
ROWSPAN="16"
><TT
CLASS="LITERAL"
>LWLockTranche</TT
></TD
><TD
><TT
CLASS="LITERAL"
>clog</TT
></TD
><TD
>正等待一个 clog（事务状态）缓冲区上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>commit_timestamp</TT
></TD
><TD
>正等待提交时间戳缓冲区上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>subtrans</TT
></TD
><TD
>正等待子事务缓冲区上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>multixact_offset</TT
></TD
><TD
>正等待多事务偏移缓冲区上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>multixact_member</TT
></TD
><TD
>正等待多事务成员缓冲区上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>async</TT
></TD
><TD
>正等待 async（通知）缓冲区上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>oldserxid</TT
></TD
><TD
>正等待 oldserxid 缓冲区上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>wal_insert</TT
></TD
><TD
>正等待把 WAL 插入到一个内存缓冲区。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>buffer_content</TT
></TD
><TD
>正等待读取或者写入内存中的一个数据页。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>buffer_io</TT
></TD
><TD
>正等待一个数据页面上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>replication_origin</TT
></TD
><TD
>正等待读取或者更新复制进度。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>replication_slot_io</TT
></TD
><TD
>正等待一个复制槽上的 I/O。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>proc</TT
></TD
><TD
>正等待读取或者更新 fast-path 锁信息。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>buffer_mapping</TT
></TD
><TD
>正等待把一个数据块与缓冲池中的一个缓冲区关联。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>lock_manager</TT
></TD
><TD
>正等待增加或者检查用于后端的锁，或者正等待加入或者退出一个锁定组（并行查询使用）。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>predicate_lock_manager</TT
></TD
><TD
>正等待增加或者检查谓词锁信息。</TD
></TR
><TR
><TD
ROWSPAN="10"
><TT
CLASS="LITERAL"
>Lock</TT
></TD
><TD
><TT
CLASS="LITERAL"
>relation</TT
></TD
><TD
>正等待获得一个关系上的锁。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>extend</TT
></TD
><TD
>正等待扩展一个关系。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>page</TT
></TD
><TD
>正等待获得一个关系上的页面的锁。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>tuple</TT
></TD
><TD
>正等待获得一个元组上的锁。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>transactionid</TT
></TD
><TD
>正等待一个事务结束。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>virtualxid</TT
></TD
><TD
>正等待获得一个虚拟 xid 锁。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>speculative token</TT
></TD
><TD
>正等待获取一个  speculative insertion lock。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>object</TT
></TD
><TD
>正等待获得一个非关系数据库对象上的锁。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>userlock</TT
></TD
><TD
>正等待获得一个用户锁。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>advisory</TT
></TD
><TD
>正等待获得一个咨询用户锁。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>BufferPin</TT
></TD
><TD
><TT
CLASS="LITERAL"
>BufferPin</TT
></TD
><TD
>正等待在一个缓冲区上加 pin。</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>     对于扩展安装的切片（tranche），这个名称由扩展指定并且会被<TT
CLASS="STRUCTFIELD"
>wait_event</TT
>显示出来。很有可能在其他后端不知道的情况下，用户在其中一个后端中注册了切片（通过在动态共享内存中分配），那么我们对这种情况会显示<TT
CLASS="LITERAL"
>extension</TT
>。
    </P
></BLOCKQUOTE
></DIV
><P
>     下面的例子展示了如何查看等待事件

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type |  wait_event
------+-----------------+---------------
 2540 | Lock            | relation
 6644 | LWLockNamed     | ProcArrayLock
(2 rows)</PRE
><P>
   </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-REPLICATION-VIEW"
></A
><P
><B
>&#34920; 28-5. <TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
> 视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>pid</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>一个 WAL 发送进程的进程 ID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usesysid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>登录到这个 WAL 发送进程的用户的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>usename</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>登录到这个 WAL 发送进程的用户的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>application_name</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>连接到这个 WAL 发送进程的应用的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_addr</TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>连接到这个 WAL 发送进程的客户端的 IP 地址。
     如果这个域为空，它表示该客户端通过服务器机器上的一个
     Unix 套接字连接。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_hostname</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>连接上的客户端的主机名，由一次对<TT
CLASS="STRUCTFIELD"
>client_addr</TT
>
     的逆向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有在
     <A
HREF="runtime-config-logging.html#GUC-LOG-HOSTNAME"
>log_hostname</A
>被启用时非空
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>client_port</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>客户端用来与这个 WAL 发送进程通讯的 TCP 端口号，
     如果使用 Unix 套接字则为<TT
CLASS="LITERAL"
>-1</TT
>
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>backend_start</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>这个进程开始的时间，即客户端是何时连接到这个
     WAL 发送进程的
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>backend_xmin</TT
></TD
><TD
><TT
CLASS="TYPE"
>xid</TT
></TD
><TD
>由<A
HREF="runtime-config-replication.html#GUC-HOT-STANDBY-FEEDBACK"
>hot_standby_feedback</A
>报告
     的这个后备机的<TT
CLASS="LITERAL"
>xmin</TT
>水平线。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>state</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>当前的 WAL 发送进程状态</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>sent_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>在这个连接上发送的最后一个事务日志的位置</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>write_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>被这个后备服务器写入到磁盘的最后一个事务日志的位置</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>flush_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>被这个后备服务器刷入到磁盘的最后一个事务日志的位置</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>replay_location</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>被重放到这个后备服务器上的数据库中的最后一个事务日志的位置</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>sync_priority</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>这个后备服务器被选中为同步后备服务器的优先级</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>sync_state</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>这个后备服务器的同步状态</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
>视图中将为每一个 WAL
   发送进程包含一行，用来显示与该发送进程连接的后备服务器的复制统计信息。
   这个视图中只会列出直接连接的后备机，下游后备服务器的信息不包含在此。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-WAL-RECEIVER-VIEW"
></A
><P
><B
>&#34920; 28-6. <TT
CLASS="STRUCTNAME"
>pg_stat_wal_receiver</TT
> 视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>pid</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>WAL 接收器进程的进程 ID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>status</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>WAL 接收器进程的活动状态</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>receive_start_lsn</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>WAL 接收器启动时使用的第一个事务日志位置</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>receive_start_tli</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>WAL 接收器启动时使用的第一个时间线编号</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>received_lsn</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>已经接收到并且已经被杀入磁盘的最后一个事务日志的位置，这个域的初始值是 WAL 接收器启动时使用的第一个日志位置</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>received_tli</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>已经接收到并且已经被杀入磁盘的最后一个事务日志的时间线编号，这个域的初始值是 WAL 接收器启动时使用的第一个日志所在的时间线编号
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_msg_send_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>从源头 WAL 发送器接收到的最后一个消息的发送时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_msg_receipt_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>从源头 WAL 发送器接收到的最后一个消息的接收时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>latest_end_lsn</TT
></TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>报告给源头 WAL 发送器的最后一个事务日志位置</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>latest_end_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>报告给源头 WAL 发送器最后一个事务日志位置的时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>slot_name</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>这个 WAL 接收器使用的复制槽的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>conninfo</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>      这个 WAL 接收器使用的连接串，安全相关的域会被隐去。
     </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_wal_receiver</TT
>事务只包含一行，它显示了从 WAL 接收器所连接的服务器得到的有关该接收器的统计信息。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-SSL-VIEW"
></A
><P
><B
>&#34920; 28-7. <TT
CLASS="STRUCTNAME"
>pg_stat_ssl</TT
> 视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>pid</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>一个后端或者 WAL 发送进程的进程 ID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>ssl</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>如果在这个连接上使用了 SSL 则为真</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>version</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>在用的 SSL 版本，如果这个连接上没有使用 SSL 则为 NULL</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>cipher</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>在用的 SSL 密码的名称，如果这个连接上没有使用 SSL 则为 NULL</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>bits</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>使用的加密算法中的位数，如果这个连接上没有使用 SSL 则为 NULL</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>compression</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>如果使用了 SSL 压缩则为真，否则为假，
     如果这个连接上没有使用 SSL 则为 NULL</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>clientdn</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>来自所使用的客户端证书的识别名（DN）域，
     如果没有提供客户端证书或者这个连接上没有使用 SSL 
     则为 NULL。如果 DN 域长度超过
     <TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>（标准编译
     中是 64 个字符），则它会被截断。
     </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_ssl</TT
>视图将为每一个后端或者 WAL 发送进程
   包含一行，用来显示这个连接上的 SSL 使用情况。可以把它与
   <TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>或者
   <TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
>通过
   <TT
CLASS="STRUCTFIELD"
>pid</TT
>列连接来得到更多有关该连接的细节。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ARCHIVER-VIEW"
></A
><P
><B
>&#34920; 28-8. <TT
CLASS="STRUCTNAME"
>pg_stat_archiver</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>archived_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>已被成功归档的 WAL 文件数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_archived_wal</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>最后一个被成功归档的 WAL 文件名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_archived_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>最后一次成功归档操作的时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>failed_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>失败的归档 WAL 文件尝试的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_failed_wal</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>最后一次失败的归档操作的 WAL 文件名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_failed_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>最后一次失败的归档操作的时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>stats_reset</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>这些统计信息最后一次被重置的时间</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   The <TT
CLASS="STRUCTNAME"
>pg_stat_archiver</TT
>视图将总是一个单一的行，
   该行包含着有关集簇的归档进程的数据。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-BGWRITER-VIEW"
></A
><P
><B
>&#34920; 28-9. <TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoints_timed</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>已经被执行的计划中检查点的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoints_req</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>已经被执行的请求检查点的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoint_write_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>在文件被写入磁盘的检查点处理部分花费的总时间，以毫秒计
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>checkpoint_sync_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>在文件被同步到磁盘中的检查点处理部分花费的总时间，以毫秒计
      </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_checkpoint</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在检查点期间被写的缓冲区数目</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_clean</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被后台写进程写的缓冲区数目</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>maxwritten_clean</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>后台写进程由于已经写了太多缓冲区而停止清洁扫描的次数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_backend</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被一个后端直接写的缓冲区数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_backend_fsync</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>一个后端不得不自己执行<CODE
CLASS="FUNCTION"
>fsync</CODE
>调用的次数（通常即使后端自己进行写操作，后台写进程也会处理这些）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>buffers_alloc</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被分配的缓冲区数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>stats_reset</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>这些统计信息上次被重置的时间</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
>视图将总是只有单独的一行，它包含集簇的全局数据。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-DATABASE-VIEW"
></A
><P
><B
>&#34920; 28-10. <TT
CLASS="STRUCTNAME"
>pg_stat_database</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>一个数据库的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个数据库的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>numbackends</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>当前连接到这个数据库的后端数量。这是在这个视图中唯一一个返回反映当前状态值的列。所有其他列返回从上次重置以来积累的值。</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>xact_commit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中已经被提交的事务的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>xact_rollback</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中已经被回滚的事务的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被读取的磁盘块的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>磁盘块被发现已经在缓冲区中的次数，这样不需要一次读取（这只包括 PostgreSQL 缓冲区中的命中，而不包括在操作系统文件系统缓冲区中的命中）
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_returned</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被查询返回的行数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_fetched</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被查询取出的行数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_inserted</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被查询插入的行数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_updated</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被查询更新的行数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tup_deleted</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被查询删除的行数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>conflicts</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>由于与恢复冲突而在这个数据库中被取消的查询的数目（冲突只发生在后备服务器上，详见<A
HREF="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW"
>pg_stat_database_conflicts</A
>）。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>temp_files</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被查询创建的临时文件的数量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<A
HREF="runtime-config-logging.html#GUC-LOG-TEMP-FILES"
>log_temp_files</A
>设置。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>temp_bytes</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被查询写到临时文件中的数据总量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<A
HREF="runtime-config-logging.html#GUC-LOG-TEMP-FILES"
>log_temp_files</A
>设置。
     </TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>deadlocks</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个数据库中被检测到的死锁数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blk_read_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>在这个数据库中后端花费在读取数据文件块的时间，以毫秒计</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blk_write_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>在这个数据库中后端花费在写数据文件块的时间，以毫秒计</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>stats_reset</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>这些统计信息上次被重置的时间</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_database</TT
>视图将为集簇中的每一个数据库包含有一行，每一行显示数据库范围的统计信息。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-DATABASE-CONFLICTS-VIEW"
></A
><P
><B
>&#34920; 28-11. <TT
CLASS="STRUCTNAME"
>pg_stat_database_conflicts</TT
> 视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>一个数据库的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>datname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个数据库的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_tablespace</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个数据库中由于表空间被删掉而取消的查询数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_lock</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个数据库中由于锁超时而取消的查询数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_snapshot</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个数据库中由于旧快照而取消的查询数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_bufferpin</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个数据库中由于被占用的缓冲区而取消的查询数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>confl_deadlock</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个数据库中由于死锁而取消的查询数量</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_database_conflicts</TT
>视图为每一个
   数据库包含一行，用来显示数据库范围内由于与后备服务器上的恢复过程
   冲突而被取消的查询的统计信息。 这个视图将只包含后备服务器上的信息，
   因为冲突会不发生在主服务器上。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ALL-TABLES-VIEW"
></A
><P
><B
>&#34920; 28-12. <TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>一个表的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个表所在的模式的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个表的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>seq_scan</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个表上发起的顺序扫描的次数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>seq_tup_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被顺序扫描取得的活着的行的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_scan</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个表上发起的索引扫描的次数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被索引扫描取得的活着的行的数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_ins</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被插入的行数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_upd</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被更新的行数（包括 HOT 更新的行）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_del</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被删除的行数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_tup_hot_upd</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被更新的 HOT 行数（即不要求独立索引更新的行更新）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_live_tup</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>活着的行的估计数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_dead_tup</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>死亡行的估计数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>n_mod_since_analyze</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>从这个表最后一次被分析后备修改的行的估计数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_vacuum</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>上次这个表被手动清理的时间（不统计<TT
CLASS="COMMAND"
>VACUUM FULL</TT
>）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_autovacuum</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>上次这个表被自动清理守护进程清理的时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_analyze</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>上次这个表被手动分析的时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>last_autoanalyze</TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>上次这个表被自动清理守护进程分析的时间</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>vacuum_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个表已被手工清理的次数（不统计<TT
CLASS="COMMAND"
>VACUUM FULL</TT
>）</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>autovacuum_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个表已被自动清理守护进程清理的次数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>analyze_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个表已被手工分析的次数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>autoanalyze_count</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个表已被自动清理守护进程分析的次数</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。<TT
CLASS="STRUCTNAME"
>pg_stat_user_tables</TT
>和<TT
CLASS="STRUCTNAME"
>pg_stat_sys_tables</TT
>视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-ALL-INDEXES-VIEW"
></A
><P
><B
>&#34920; 28-13. <TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>这个索引的基表的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>这个索引的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个索引所在的模式的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个索引的基表的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个索引的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_scan</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个索引上发起的索引扫描次数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个索引上由扫描返回的索引项数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>被使用这个索引的简单索引扫描取得的活着的表行数量</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。<TT
CLASS="STRUCTNAME"
>pg_stat_user_indexes</TT
>和<TT
CLASS="STRUCTNAME"
>pg_stat_sys_indexes</TT
>视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。
  </P
><P
>   索引可以被简单索引扫描、<SPAN
CLASS="QUOTE"
>"位图"</SPAN
>索引扫描以及优化器使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的<TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>.<TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
>计数，并且为每个表增加<TT
CLASS="STRUCTNAME"
>pg_stat_all_tables</TT
>.<TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>计数，但是它不影响<TT
CLASS="STRUCTNAME"
>pg_stat_all_indexes</TT
>.<TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>。如果所提供的常量值不在优化器统计信息记录的范围之内，优化器也会访问索引来检查，因为优化器统计信息可能已经“不新鲜”了。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>    即使不用位图扫描，<TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
>和<TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>计数也可能不同，因为<TT
CLASS="STRUCTFIELD"
>idx_tup_read</TT
>统计从该索引取得的索引项而<TT
CLASS="STRUCTFIELD"
>idx_tup_fetch</TT
>统计从表取得的或者的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="PG-STATIO-ALL-TABLES-VIEW"
></A
><P
><B
>&#34920; 28-14. <TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>一个表的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个表所在的模式的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个表的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>heap_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>从这个表读取的磁盘块数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>heap_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个表中的缓冲区命中数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>从这个表上所有索引中读取的磁盘块数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个表上的所有索引中的缓冲区命中数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>toast_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>从这个表的 TOAST 表（如果有）读取的磁盘块数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>toast_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tidx_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>tidx_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_all_tables</TT
>视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。<TT
CLASS="STRUCTNAME"
>pg_statio_user_tables</TT
>和<TT
CLASS="STRUCTNAME"
>pg_statio_sys_tables</TT
>视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STATIO-ALL-INDEXES-VIEW"
></A
><P
><B
>&#34920; 28-15. <TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>这个索引的基表的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>这个索引的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个索引所在的模式的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个索引的基表的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>indexrelname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个索引的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>从这个索引读取的磁盘块数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>idx_blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个索引中的缓冲区命中数量</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_all_indexes</TT
>视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。<TT
CLASS="STRUCTNAME"
>pg_statio_user_indexes</TT
>和<TT
CLASS="STRUCTNAME"
>pg_statio_sys_indexes</TT
>视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STATIO-ALL-SEQUENCES-VIEW"
></A
><P
><B
>&#34920; 28-16. <TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>一个序列的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个序列所在的模式的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>relname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个序列的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_read</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>从这个序列中读取的磁盘块数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>blks_hit</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>在这个序列中的缓冲区命中数量</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_statio_all_sequences</TT
>视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PG-STAT-USER-FUNCTIONS-VIEW"
></A
><P
><B
>&#34920; 28-17. <TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
>视图</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>列</TH
><TH
>类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>funcid</TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>一个函数的 OID</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>schemaname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个函数所在的模式的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>funcname</TT
></TD
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
>这个函数的名称</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>calls</TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>这个函数已经被调用的次数</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>total_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</TD
></TR
><TR
><TD
><TT
CLASS="STRUCTFIELD"
>self_time</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <TT
CLASS="STRUCTNAME"
>pg_stat_user_functions</TT
>视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。<A
HREF="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS"
>track_functions</A
>参数控制到底哪些函数被跟踪。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MONITORING-STATS-FUNCTIONS"
>28.2.3. 统计函数</A
></H2
><P
>   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。如要了解如函数名等细节，可参考标准视图的定义（例如，在<SPAN
CLASS="APPLICATION"
>psql</SPAN
>中你可以发出<TT
CLASS="LITERAL"
>\d+ pg_stat_activity</TT
>）。针对每一个数据库统计信息的访问函数把一个数据库 OID 作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、索引和函数才能被这些函数看到。
  </P
><P
>   与统计收集相关的额外函数被列举在<A
HREF="monitoring-stats.html#MONITORING-STATS-FUNCS-TABLE"
>&#34920; 28-18</A
>中。
  </P
><DIV
CLASS="TABLE"
><A
NAME="MONITORING-STATS-FUNCS-TABLE"
></A
><P
><B
>&#34920; 28-18. 额外统计函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>函数</TH
><TH
>返回类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_backend_pid()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>       处理当前会话的服务器进程的进程 ID
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_activity</CODE
>(<TT
CLASS="TYPE"
>integer</TT
>)</TT
></TD
><TD
><TT
CLASS="TYPE"
>setof record</TT
></TD
><TD
>       返回具有指定 PID 的后端相关的一个记录，或者在指定<TT
CLASS="SYMBOL"
>NULL</TT
>的情况下为系统中每一个活动后端返回一个记录。被返回的域是<TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>视图中的那些域的一个子集。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_snapshot_timestamp()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>带时区的时间戳</TT
></TD
><TD
>       返回当前统计信息快照的时间戳
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_clear_snapshot()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       抛弃当前的统计快照
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       把用于当前数据库的所有统计计数器重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset_shared</CODE
>(text)</TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       把某些集簇范围的统计计数器重置为零，具体哪些取决于参数（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
       调用<TT
CLASS="LITERAL"
>pg_stat_reset_shared('bgwriter')</TT
>把<TT
CLASS="STRUCTNAME"
>pg_stat_bgwriter</TT
>
       视图中显示的所有计数器清零。调用<TT
CLASS="LITERAL"
>pg_stat_reset_shared('archiver')</TT
>
       将会把<TT
CLASS="STRUCTNAME"
>pg_stat_archiver</TT
>视图中展示的所有计数器清零。
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset_single_table_counters</CODE
>(oid)</TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       把当前数据库中用于单个表或索引的统计数据重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_reset_single_function_counters</CODE
>(oid)</TT
></TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>       把当前数据库中用于单个函数的统计信息重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </TD
></TR
></TBODY
></TABLE
></DIV
><P
>   <CODE
CLASS="FUNCTION"
>pg_stat_get_activity</CODE
>是<TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>视图的底层函数，它返回一个行集合，其中包含有关每个后端进程所有可用的信息。有时只获得该信息的一个子集可能会更方便。在那些情况中，可以使用一组更老的针对每个后端的统计访问函数，这些显示在<A
HREF="monitoring-stats.html#MONITORING-STATS-BACKEND-FUNCS-TABLE"
>&#34920; 28-19</A
>中。这些访问函数使用一个后端 ID 号，范围从 1 到当前活动后端数目。函数<CODE
CLASS="FUNCTION"
>pg_stat_get_backend_idset</CODE
>提供了一种方便的方法为每个活动后端产生一行来调用这些函数。例如，要显示<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>以及所有后端当前的查询：

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;</PRE
><P>
  </P
><DIV
CLASS="TABLE"
><A
NAME="MONITORING-STATS-BACKEND-FUNCS-TABLE"
></A
><P
><B
>&#34920; 28-19. 针对每个后端的统计函数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>函数</TH
><TH
>返回类型</TH
><TH
>描述</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_idset()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>setof integer</TT
></TD
><TD
>当前活动后端 ID 号的集合（从 1 到活动后端数目）</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_activity(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>这个后端最近查询的文本</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_activity_start(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>最近查询被开始的时间</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_client_addr(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>inet</TT
></TD
><TD
>该客户端连接到这个后端的 IP 地址</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_client_port(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>该客户端用来通信的 TCP 端口号</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_dbid(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>这个后端连接到的数据库的 OID</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_pid(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>这个后端的进程 ID</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_start(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>这个进程被开始的时间</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_userid(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>登录到这个后端的用户的 OID</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_wait_event_type(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>如果后端正在等待，则是等待事件类型的名称，否则为 NULL。详见<A
HREF="monitoring-stats.html#WAIT-EVENT-TABLE"
>&#34920; 28-4</A
>。
        </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_wait_event(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>如果后端正在等待，则是等待事件的名称，否则为 NULL。详见<A
HREF="monitoring-stats.html#WAIT-EVENT-TABLE"
>&#34920; 28-4</A
>。
       </TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_get_backend_xact_start(integer)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>当前事务被开始的时间</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="monitoring-ps.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="monitoring-locks.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>标准 Unix 工具</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="monitoring.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>查看锁</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
