<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CLUSTER</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="SQL 命令"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CLOSE"
HREF="sql-close.html"><LINK
REL="NEXT"
TITLE="COMMENT"
HREF="sql-comment.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="REFENTRY"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/ref/cluster.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CLOSE"
HREF="sql-close.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="COMMENT"
HREF="sql-comment.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CLUSTER"
></A
>CLUSTER</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN76844"
></A
><H2
>&#21517;&#31216;</H2
>CLUSTER&nbsp;--&nbsp;根据一个索引聚簇一个表</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN76847"
></A
><H2
>&#22823;&#32434;</H2
><PRE
CLASS="SYNOPSIS"
>CLUSTER [VERBOSE] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ USING <TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
> ]
CLUSTER [VERBOSE]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN76851"
></A
><H2
>描述</H2
><P
>   <TT
CLASS="COMMAND"
>CLUSTER</TT
>指示<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
   基于<TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
>
   所指定的索引来聚簇
   <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>
   所指定的表。该索引必须已经定义在
   <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>上。
  </P
><P
>   当一个表被聚簇时，会基于索引信息对它进行物理上的排序。聚簇是一种
   一次性的操作：当表后续被更新时，更改没有被聚簇。也就是说，不会尝
   试根据新行或者被更新行的索引顺序来存储它们（如果想这样做，可以周
   期性地通过发出该命令重新聚簇。还有，把表的
   <TT
CLASS="LITERAL"
>fillfactor</TT
>存储参数设置为小于 100% 有助于在更
   新期间保持聚簇顺序，因为如果空间足够会把被更新行保留在同一个页面
   中）。
  </P
><P
>   当一个表被更新时，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
   会记住它是按照哪个索引聚簇的。形式
   <TT
CLASS="COMMAND"
>CLUSTER <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></TT
>
   会使用前面所用的同一个索引对表重新聚簇。你也可以使用
   <TT
CLASS="LITERAL"
>CLUSTER</TT
>或者<A
HREF="sql-altertable.html"
>ALTER TABLE</A
>
   的<TT
CLASS="LITERAL"
>SET WITHOUT CLUSTER</TT
>形式把索引设置为可用于
   未来的聚簇操作，或者清除任何之前的设置。
  </P
><P
>   不带任何参数的<TT
CLASS="COMMAND"
>CLUSTER</TT
>会重新聚簇调用用
   户所拥有的当前数据库中已经被聚簇过的表（如果是超级用户调用，则是
   所有已被聚簇过的表）。这种形式的
   <TT
CLASS="COMMAND"
>CLUSTER</TT
>不能在一个事务块内执行。
  </P
><P
>   当一个表被聚簇时，会在其上要求一个<TT
CLASS="LITERAL"
>ACCESS
   EXCLUSIVE</TT
>锁。这会阻止任何其他数据库操作（包括读和写）
   在<TT
CLASS="COMMAND"
>CLUSTER</TT
>结束前在该表上操作。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN76874"
></A
><H2
>参数</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></DT
><DD
><P
>      一个表的名称（可能是模式限定的）。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
></DT
><DD
><P
>      一个索引的名称。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>VERBOSE</TT
></DT
><DD
><P
>      在每一个表被聚簇时打印一个进度报告。
     </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN76892"
></A
><H2
>注解</H2
><P
>    在随机访问一个表中的行时，表中数据的实际顺序是无关紧要的。
    不过，如果你想要更多地访问其中一些数据，并且有一个索引把它
    们分组在一起，使用<TT
CLASS="COMMAND"
>CLUSTER</TT
>就会带
    来好处。如果你从一个表中要求一个范围的被索引值或者多行都匹
    配的一个单一值，<TT
CLASS="COMMAND"
>CLUSTER</TT
>就会有所
    帮助，因为一旦该索引标识出了第一个匹配行所在的表页，所有其
    他匹配行很可能就在同一个表页中，并且因此节省了磁盘访问并且
    提高了查询速度。
   </P
><P
>    <TT
CLASS="COMMAND"
>CLUSTER</TT
>可以使用指定索引上的一次索引扫描
    或者遵循排序的一次顺序扫描（如果索引是 B 树）对表重新排序。
    它将会基于规划器代价参数以及可用的统计信息来选择较快的方法。
   </P
><P
>    在使用索引扫描时，会创建该表的一份临时拷贝，其中包含按索引顺序
    排列的表数据。该表上每一个索引的临时拷贝也会被创建。因此，在磁
    盘上需要至少等于表尺寸加上索引尺寸的综合的空闲空间。
   </P
><P
>    在使用顺序扫描以及排序时，也会创建一个临时排序文件，因此临时空
    间需求的峰值也就是表尺寸的两倍外加索引尺寸。这种方法通常比索引
    扫描方法更快，但是如果磁盘空间需求是不能接受的，你可以通过临时
    地把<A
HREF="runtime-config-query.html#GUC-ENABLE-SORT"
>enable_sort</A
>设置为<TT
CLASS="LITERAL"
>off</TT
>来禁
    用这种选择。
   </P
><P
>    建议在聚簇前把<A
HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"
>maintenance_work_mem</A
>设
    置为一个合理地比较大的值（但是不能超过你可以用于
    <TT
CLASS="COMMAND"
>CLUSTER</TT
>操作的 RAM 容量）。
   </P
><P
>    因为规划器会记录有关表顺序的统计信息，建议在新近被聚簇的表上
    运行<A
HREF="sql-analyze.html"
>ANALYZE</A
>。否则，规划器可能会产生很差
    的查询计划。
   </P
><P
>    因为<TT
CLASS="COMMAND"
>CLUSTER</TT
>会记住哪些索引被聚簇，
    我们可以第一次手动聚簇想要聚簇的表，然后设置一个定期运行的维护
    脚本，其中执行不带任何参数的<TT
CLASS="COMMAND"
>CLUSTER</TT
>，这样那些
    表就会被周期性地重新聚簇。
   </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN76911"
></A
><H2
>示例</H2
><P
>   基于索引<TT
CLASS="LITERAL"
>employees_ind</TT
>聚簇表
   <TT
CLASS="LITERAL"
>employees</TT
>：
</P><PRE
CLASS="PROGRAMLISTING"
>CLUSTER employees USING employees_ind;</PRE
><P>
  </P
><P
>   使用之前用过的同一个索引聚簇<TT
CLASS="LITERAL"
>employees</TT
>表：
</P><PRE
CLASS="PROGRAMLISTING"
>CLUSTER employees;</PRE
><P>
  </P
><P
>   对数据库中以前被聚簇过的所有表进行聚簇：
</P><PRE
CLASS="PROGRAMLISTING"
>CLUSTER;</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN76922"
></A
><H2
>兼容性</H2
><P
>   在 SQL 标准中没有<TT
CLASS="COMMAND"
>CLUSTER</TT
>语句。
  </P
><P
>   为了兼容 8.3 之前的<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>版本，
</P><PRE
CLASS="SYNOPSIS"
>CLUSTER <TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
> ON <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></PRE
><P>语法也被支持。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN76931"
></A
><H2
>另见</H2
><A
HREF="app-clusterdb.html"
><SPAN
CLASS="APPLICATION"
>clusterdb</SPAN
></A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-close.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-comment.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CLOSE</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>COMMENT</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
