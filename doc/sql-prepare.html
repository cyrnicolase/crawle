<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>PREPARE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="SQL 命令"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="NOTIFY"
HREF="sql-notify.html"><LINK
REL="NEXT"
TITLE="PREPARE TRANSACTION"
HREF="sql-prepare-transaction.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="REFENTRY"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/ref/prepare.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="NOTIFY"
HREF="sql-notify.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="PREPARE TRANSACTION"
HREF="sql-prepare-transaction.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-PREPARE"
></A
>PREPARE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN88926"
></A
><H2
>&#21517;&#31216;</H2
>PREPARE&nbsp;--&nbsp;为执行准备一个语句</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN88929"
></A
><H2
>&#22823;&#32434;</H2
><PRE
CLASS="SYNOPSIS"
>PREPARE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [, ...] ) ] AS <TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
></PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88934"
></A
><H2
>描述</H2
><P
>   <TT
CLASS="COMMAND"
>PREPARE</TT
>创建一个预备语句。预备语句是一种服务器端对象，它可以被用来优化性能。当<TT
CLASS="COMMAND"
>PREPARE</TT
>语句被执行时，指定的语句会被解析、分析并且重写。当后续发出一个<TT
CLASS="COMMAND"
>EXECUTE</TT
>命令时，该预备语句会被规划并且执行。这种工作的划分避免了重复性的解析分析工作，不过允许执行计划依赖所提供的特定参数值。
  </P
><P
>   预备语句可以接受参数：在执行时会被替换到语句中的值。在创建预备语句时，可以用位置引用参数，如<TT
CLASS="LITERAL"
>$1</TT
>、<TT
CLASS="LITERAL"
>$2</TT
>等。也可以选择性地指定参数数据类型的一个列表。当一个参数的数据类型没有被指定或者被声明为<TT
CLASS="LITERAL"
>unknown</TT
>时，其类型会从该参数被使用的环境中推知（如果可能）。在执行该语句时，在<TT
CLASS="COMMAND"
>EXECUTE</TT
>语句中为这些参数指定实际值。更多有关于此的信息可参考<A
HREF="sql-execute.html"
>EXECUTE</A
>。
  </P
><P
>   预备语句只在当前数据库会话期间存在。当会话结束时，预备语句会消失，因此在重新使用之前必须重新建立它。这也意味着一个预备语句不能被多个数据库客户端同时使用。不过，每一个客户端可以创建它们自己的预备语句来使用。预备语句可以用<A
HREF="sql-deallocate.html"
>DEALLOCATE</A
>命令手工清除。
  </P
><P
>   当一个会话要执行大量类似语句时，预备语句可能会有最大性能优势。如果该语句很复杂（难于规划或重写），例如，如果查询涉及很多表的连接或者要求应用多个规则，性能差异将会特别明显。如果语句相对比较容易规划和重写，但是执行起来开销相对较大，那么预备语句的性能优势就不那么显著了。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88949"
></A
><H2
>参数</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>      给这个特定预备语句的任意名称。它在一个会话中必须唯一并且后续将被用来执行或者清除一个之前准备好的语句。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
></DT
><DD
><P
>      预备语句一个参数的数据类型。如果一个特定参数的数据类型没有被指定或者被指定为<TT
CLASS="LITERAL"
>unknown</TT
>，将从该参数被使用的环境中推得。要在预备语句本身中引用参数，可以使用
      <TT
CLASS="LITERAL"
>$1</TT
>、<TT
CLASS="LITERAL"
>$2</TT
>等。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
></DT
><DD
><P
>      任何<TT
CLASS="COMMAND"
>SELECT</TT
>、<TT
CLASS="COMMAND"
>INSERT</TT
>、<TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>或者<TT
CLASS="COMMAND"
>VALUES</TT
>语句。
     </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-PREPARE-NOTES"
></A
><H2
>注解</H2
><P
>   对每一组提供的<TT
CLASS="COMMAND"
>EXECUTE</TT
>值，预备语句可以使用通用计划而不是重新做计划。对于没有参数的预备语句马上就会这样做，否则只有五次或者更多次执行产生的计划的估计代价平均值（包括规划开销）比通用计划的代价估计更昂贵时才会这样做。一旦选中一个通用计划，在该预备语句剩余的生存时间内都将使用它。使用在重复值很多的列中很少出现的<TT
CLASS="COMMAND"
>EXECUTE</TT
>值可以产生比通用计划更加廉价的定制计划（即使加上规划开销），这样通用计划将不会被使用。
  </P
><P
>   通用计划假定每一个提供给<TT
CLASS="COMMAND"
>EXECUTE</TT
>的值都是该列的可区分值并且列值是均匀分布的。例如，如果统计信息记录了三个可区分的列值，通用计划会假定一个列等值比较将匹配被处理行中的 33%。列统计值也允许通用计划准确地计算唯一列的选择度。如果一个通用计划被选中时，在非均匀分布列上的比较以及制定不存在的值都会影响平均计划代价。
  </P
><P
>   要检查<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>为一个预备语句使用的查询计划，可以使用<A
HREF="sql-explain.html"
>EXPLAIN</A
>，例如<TT
CLASS="COMMAND"
>EXPLAIN EXECUTE</TT
>。如果使用的是一个通用计划，它将包含参数符号<TT
CLASS="LITERAL"
>$<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></TT
>，而一个定制计划则会把提供的参数值替换进去。通用计划中的行估计值反映了这些参数计算出来的选择度。
  </P
><P
>   更多关于查询规划以及<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>为此所收集的统计信息的内容，请见<A
HREF="sql-analyze.html"
>ANALYZE</A
>文档。
  </P
><P
>   尽管预备语句主要是为了避免重复对语句进行解析分析以及规划，但是只要上一次使用该预备语句后该语句中用到的数据库对象发生了定义性（DDL）改变，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>将会对该语句强制进行重新分析和重新规划。还有，如果<A
HREF="runtime-config-client.html#GUC-SEARCH-PATH"
>search_path</A
>的值发生变化，也将使用新的<TT
CLASS="VARNAME"
>search_path</TT
>重新解析该语句（后一种行为是从<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.3 开始的新行为）。这些规则让预备语句的使用在语义上几乎等效于反复提交相同的查询文本，但是能在性能上获利（如果没有对象定义被改变，特别是如果最优计划保持不变时）。该语义等价性不完美的一个例子是：如果语句用一个未限定的名称引用表，并且之后在<TT
CLASS="VARNAME"
>search_path</TT
>中更靠前的模式中创建了一个新的同名表，则不会发生自动的重解析，因为该语句使用的对象没有被改变。不过，如果某些其他更改造成了重解析，后续使用中都会引用新表。
  </P
><P
>   可以通过查询<A
HREF="view-pg-prepared-statements.html"
><TT
CLASS="STRUCTNAME"
>pg_prepared_statements</TT
></A
>系统视图来看到会话中所有可用的预备语句。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-PREPARE-EXAMPLES"
></A
><H2
>例子</H2
><P
>   为一个<TT
CLASS="COMMAND"
>INSERT</TT
>语句创建一个预备语句，然后执行它：
</P><PRE
CLASS="PROGRAMLISTING"
>PREPARE fooplan (int, text, bool, numeric) AS
    INSERT INTO foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, 'Hunter Valley', 't', 200.00);</PRE
><P>
  </P
><P
>   为一个<TT
CLASS="COMMAND"
>SELECT</TT
>语句创建一个预备语句，然后执行它：
</P><PRE
CLASS="PROGRAMLISTING"
>PREPARE usrrptplan (int) AS
    SELECT * FROM users u, logs l WHERE u.usrid=$1 AND u.usrid=l.usrid
    AND l.date = $2;
EXECUTE usrrptplan(1, current_date);</PRE
><P>

   注意第二个参数的数据类型没有被指定，因此会从使用<TT
CLASS="LITERAL"
>$2</TT
>的环境中推知。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89009"
></A
><H2
>兼容性</H2
><P
>   SQL 标准包括一个<TT
CLASS="COMMAND"
>PREPARE</TT
>语句，但是它只用于嵌入式 SQL。这个版本的<TT
CLASS="COMMAND"
>PREPARE</TT
>语句也使用了一种有些不同的语法。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89014"
></A
><H2
>另见</H2
><A
HREF="sql-deallocate.html"
>DEALLOCATE</A
>, <A
HREF="sql-execute.html"
>EXECUTE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-notify.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-prepare-transaction.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>NOTIFY</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>PREPARE TRANSACTION</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
