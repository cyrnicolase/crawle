<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>数字类型</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="数据类型"
HREF="datatype.html"><LINK
REL="PREVIOUS"
TITLE="数据类型"
HREF="datatype.html"><LINK
REL="NEXT"
TITLE="货币类型"
HREF="datatype-money.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/datatype.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="数据类型"
HREF="datatype.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 8. 数据类型</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="货币类型"
HREF="datatype-money.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DATATYPE-NUMERIC"
>8.1. 数字类型</A
></H1
><P
>    数字类型由2、4或8字节的整数以及4或8字节的浮点数和可选精度小数组成。<A
HREF="datatype-numeric.html#DATATYPE-NUMERIC-TABLE"
>&#34920; 8-2</A
>列出了所有可用类型。
   </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-NUMERIC-TABLE"
></A
><P
><B
>&#34920; 8-2. 数字类型</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>名字</TH
><TH
>存储尺寸</TH
><TH
>描述</TH
><TH
>范围</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="TYPE"
>smallint</TT
></TD
><TD
>2字节</TD
><TD
>小范围整数</TD
><TD
>-32768 to +32767</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>4字节</TD
><TD
>整数的典型选择</TD
><TD
>-2147483648 to +2147483647</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>8字节</TD
><TD
>大范围整数</TD
><TD
>-9223372036854775808 to +9223372036854775807</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>decimal</TT
></TD
><TD
>可变</TD
><TD
>用户指定精度，精确</TD
><TD
>最高小数点前131072位，以及小数点后16383位</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>numeric</TT
></TD
><TD
>可变</TD
><TD
>用户指定精度，精确</TD
><TD
>最高小数点前131072位，以及小数点后16383位</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>real</TT
></TD
><TD
>4字节</TD
><TD
>可变精度，不精确</TD
><TD
>6位十进制精度</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>8字节</TD
><TD
>可变精度，不精确</TD
><TD
>15位十进制精度</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>smallserial</TT
></TD
><TD
>2字节</TD
><TD
>自动增加的小整数</TD
><TD
>1到32767</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>serial</TT
></TD
><TD
>4字节</TD
><TD
>自动增加的整数</TD
><TD
>1到2147483647</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>bigserial</TT
></TD
><TD
>8字节</TD
><TD
>自动增长的大整数</TD
><TD
>1到9223372036854775807</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    数字类型常量的语法在<A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS"
>第 4.1.2 &#33410;</A
>里描述。数字类型有一整套对应的数学操作符和函数。相关信息请参考 <A
HREF="functions.html"
>第 9 &#31456;</A
>。下面的几节详细描述这些类型。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-INT"
>8.1.1. 整数类型</A
></H2
><P
>     类型<TT
CLASS="TYPE"
>smallint</TT
>、<TT
CLASS="TYPE"
>integer</TT
>和<TT
CLASS="TYPE"
>bigint</TT
>存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的值将导致一个错误。
    </P
><P
>     常用的类型是<TT
CLASS="TYPE"
>integer</TT
>，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用 <TT
CLASS="TYPE"
>smallint</TT
>类型。而只有在<TT
CLASS="TYPE"
>integer</TT
>的范围不够的时候才使用<TT
CLASS="TYPE"
>bigint</TT
>。
    </P
><P
>     <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>只声明了整数类型<TT
CLASS="TYPE"
>integer</TT
>（或<TT
CLASS="TYPE"
>int</TT
>）、<TT
CLASS="TYPE"
>smallint</TT
>和<TT
CLASS="TYPE"
>bigint</TT
>。类型<TT
CLASS="TYPE"
>int2</TT
>、<TT
CLASS="TYPE"
>int4</TT
>和<TT
CLASS="TYPE"
>int8</TT
>都是扩展，也在许多其它<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>数据库系统中使用。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-NUMERIC-DECIMAL"
>8.1.2. 任意精度数字</A
></H2
><P
>     类型<TT
CLASS="TYPE"
>numeric</TT
>可以存储非常多位的数字。我们特别建议将它用于货币金额和其它要求计算准确的数量。<TT
CLASS="TYPE"
>numeric</TT
>值的计算在可能的情况下会得到准确的结果，例如加法、减法、乘法。不过，<TT
CLASS="TYPE"
>numeric</TT
>类型上的算术运算比整数类型或者下一节描述的浮点数类型要慢很多。
    </P
><P
>     在随后的内容里，我们使用了下述术语：一个<TT
CLASS="TYPE"
>numeric</TT
>的<I
CLASS="FIRSTTERM"
>比例</I
>是到小数部分的位数，<TT
CLASS="TYPE"
>numeric</TT
>的<I
CLASS="FIRSTTERM"
>精度</I
>是整个数字里全部位的数目，也就是小数点两边的位数目。因此数字 23.5141 的精度为6而比例为4。你可以认为整数的比例为零。
    </P
><P
>     <TT
CLASS="TYPE"
>numeric</TT
>列的最大精度和最大比例都是可以配置的。要声明一个类型为<TT
CLASS="TYPE"
>numeric</TT
>的列，你可以用下面的语法：
</P><PRE
CLASS="PROGRAMLISTING"
>NUMERIC(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>scale</I
></TT
>)</PRE
><P>
     精度必须为正数，比例可以为零或者正数。另外：
</P><PRE
CLASS="PROGRAMLISTING"
>NUMERIC(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)</PRE
><P>
     选择比例为 0 。如果使用
</P><PRE
CLASS="PROGRAMLISTING"
>NUMERIC</PRE
><P>
     创建一个列时不使用精度或比例，则该列可以存储任何精度和比例的数字值，并且值的范围最多可以到实现精度的上限。一个这种列将不会把输入值转化成任何特定的比例，而带有比例声明的<TT
CLASS="TYPE"
>numeric</TT
>列将把输入值转化为该比例（<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>标准要求缺省的比例是 0，即转化成整数精度。我们觉得这样做有点没用。如果你关心移植性，那你最好总是显式声明精度和比例）。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      显式指定类型精度时的最大允许精度为 1000，没有指定精度的<TT
CLASS="TYPE"
>NUMERIC</TT
>受到<A
HREF="datatype-numeric.html#DATATYPE-NUMERIC-TABLE"
>&#34920; 8-2</A
>中描述的限制所控制。
     </P
></BLOCKQUOTE
></DIV
><P
>     如果一个要存储的值的比例比列声明的比例高，那么系统将尝试圆整（四舍五入）该值到指定的分数位数。 然后，如果小数点左边的位数超过了声明的精度减去声明的比例，那么抛出一个错误。
    </P
><P
>     数字值在物理上是以不带任何前导或者后缀零的形式存储。 因此，列上声明的精度和比例都是最大值，而不是固定分配的 （在这个方面，<TT
CLASS="TYPE"
>numeric</TT
>类型更类似于<TT
CLASS="TYPE"
>varchar(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</TT
>， 而不像<TT
CLASS="TYPE"
>char(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</TT
>）。 实际存储要求是每四个十进制位组用两个字节，
     plus three to eight bytes overhead.
    </P
><P
>     除了普通的数字值之外，<TT
CLASS="TYPE"
>numeric</TT
>类型允许特殊值<TT
CLASS="LITERAL"
>NaN</TT
>， 表示<SPAN
CLASS="QUOTE"
>"不是一个数字"</SPAN
>。任何在 <TT
CLASS="LITERAL"
>NaN</TT
>上面的操作都生成另外一个<TT
CLASS="LITERAL"
>NaN</TT
>。 如果在 SQL 命令里把这些值当作一个常量写，你必须在其周围放上单引号，例如<TT
CLASS="LITERAL"
>UPDATE table SET x = 'NaN'</TT
>。在输入时，字串<TT
CLASS="LITERAL"
>NaN</TT
>被识别为大小写无关。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      在<SPAN
CLASS="QUOTE"
>"不是一个数字"</SPAN
>概念的大部分实现中，<TT
CLASS="LITERAL"
>NaN</TT
>被认为不等于任何其他数字值（包括<TT
CLASS="LITERAL"
>NaN</TT
>）。为了允许<TT
CLASS="TYPE"
>numeric</TT
>值可以被排序和使用基于树的索引，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>把<TT
CLASS="LITERAL"
>NaN</TT
>值视为相等，并且比所有非<TT
CLASS="LITERAL"
>NaN</TT
>值都要大。
     </P
></BLOCKQUOTE
></DIV
><P
>     类型<TT
CLASS="TYPE"
>decimal</TT
>和<TT
CLASS="TYPE"
>numeric</TT
>是等效的。两种类型都是<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>标准的一部分。
    </P
><P
>     在对值进行圆整时，<TT
CLASS="TYPE"
>numeric</TT
>类型会圆到远离零的整数，而（在大部分机器上）<TT
CLASS="TYPE"
>real</TT
>和<TT
CLASS="TYPE"
>double precision</TT
>类型会圆到最近的偶数上。例如：

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-FLOAT"
>8.1.3. 浮点类型</A
></H2
><P
>     数据类型<TT
CLASS="TYPE"
>real</TT
>和<TT
CLASS="TYPE"
>double precision</TT
>是不准确的、变精度的数字类型。实际上，这些类型是<ACRONYM
CLASS="ACRONYM"
>IEEE</ACRONYM
>标准 754 二进制浮点算术（分别对应单精度和双精度）的一般实现， 一直到下层处理器、操作系统和编译器对它的支持。
    </P
><P
>     不准确意味着一些值不能准确地转换成内部格式并且是以近似的形式存储的，因此存储和检索一个值可能出现一些缺失。 处理这些错误以及这些错误是如何在计算中传播的主题属于数学和计算机科学的一个完整的分支， 我们不会在这里进一步讨论它，这里的讨论仅限于如下几点：
     <P
></P
></P><UL
><LI
><P
>        如果你要求准确的存储和计算（例如计算货币金额），应使用<TT
CLASS="TYPE"
>numeric</TT
>类型。
       </P
></LI
><LI
><P
>        如果你想用这些类型做任何重要的复杂计算，尤其是那些你对范围情况（无穷、下溢）严重依赖的事情，那你应该仔细评诂你的实现。
       </P
></LI
><LI
><P
>        用两个浮点数值进行等值比较不可能总是按照期望地进行。
       </P
></LI
></UL
><P>
    </P
><P
>     在大部分平台上，<TT
CLASS="TYPE"
>real</TT
>类型的范围是至少 -1E+37 到 +1E+37，精度至少是 6 位小数。<TT
CLASS="TYPE"
>double precision</TT
>类型通常有 -1E+308 到 +1E+308 的范围，精度是至少 15 位数字。太大或者太小的值都会导致错误。 如果输入数字的精度太高，那么可能发生园整。太接近零的数字，如果无法与零值的表现形式相区分就会产生下溢错误。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      <A
HREF="runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS"
>extra_float_digits</A
>设置控制当一个浮点值被转换为文本输出时要包括的额外有效数字的数目。其默认值为<TT
CLASS="LITERAL"
>0</TT
>，在每一个PostgreSQL支持的平台上输出都相同。增加该设置将产生能更精确表示存储值的输出，但是可能无法移植。
     </P
></BLOCKQUOTE
></DIV
><P
>     除了普通的数字值之外，浮点类型还有几个特殊值：
<P
CLASS="LITERALLAYOUT"
><TT
CLASS="LITERAL"
>Infinity</TT
><br>
<TT
CLASS="LITERAL"
>-Infinity</TT
><br>
<TT
CLASS="LITERAL"
>NaN</TT
></P
>
     这些值分别表示 IEEE 754 特殊值<SPAN
CLASS="QUOTE"
>"正无穷大"</SPAN
>、<SPAN
CLASS="QUOTE"
>"负无穷大"</SPAN
>以及<SPAN
CLASS="QUOTE"
>"不是一个数字"</SPAN
>（在不遵循 IEEE 754 浮点算术的机器上，这些值的含义可能不是预期的）。如果在 SQL 命令里把这些数值当作常量写，你必须在它们周围放上单引号，例如<TT
CLASS="LITERAL"
>UPDATE table SET x = 'Infinity'</TT
>。 在输入时，这些串是以大小写无关的方式识别的。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      IEEE754指定<TT
CLASS="LITERAL"
>NaN</TT
>不应该与任何其他浮点值（包括<TT
CLASS="LITERAL"
>NaN</TT
>）相等。为了允许浮点值被排序或者在基于树的索引中使用，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>将<TT
CLASS="LITERAL"
>NaN</TT
>值视为相等，并且比所有非<TT
CLASS="LITERAL"
>NaN</TT
>值要更大。
     </P
></BLOCKQUOTE
></DIV
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>还支持 SQL 标准表示法<TT
CLASS="TYPE"
>float</TT
>和<TT
CLASS="TYPE"
>float(<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>)</TT
>用于声明非精确的数字类型。在这里，<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>指定以<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>二进制</I
></SPAN
>位表示的最低可接受精度。 在选取<TT
CLASS="TYPE"
>real</TT
>类型的时候，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>接受<TT
CLASS="TYPE"
>float(1)</TT
>到<TT
CLASS="TYPE"
>float(24)</TT
>，在选取<TT
CLASS="TYPE"
>double precision</TT
>的时候，接受<TT
CLASS="TYPE"
>float(25)</TT
>到<TT
CLASS="TYPE"
>float(53)</TT
>。在允许范围之外的<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>值将导致一个错误。没有指定精度的<TT
CLASS="TYPE"
>float</TT
>将被当作是<TT
CLASS="TYPE"
>double precision</TT
>。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      认为<TT
CLASS="TYPE"
>real</TT
>和<TT
CLASS="TYPE"
>double precision</TT
>分别有 24 和 53 个二进制位的假设对 IEEE 标准的浮点实现来说是正确的。在非 IEEE 平台上，这个数值可能略有偏差，但是为了简化，我们在所有平台上都用了同样的<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>值范围。
     </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-SERIAL"
>8.1.4. 序数类型</A
></H2
><P
>     <TT
CLASS="TYPE"
>smallserial</TT
>、<TT
CLASS="TYPE"
>serial</TT
>和<TT
CLASS="TYPE"
>bigserial</TT
>类型不是真正的类型，它们只是为了创建唯一标识符列而存在的方便符号（类似其它一些数据库中支持的<TT
CLASS="LITERAL"
>AUTO_INCREMENT</TT
>属性）。 在目前的实现中，下面一个语句：

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
> (
    <TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
> SERIAL
);</PRE
><P>

     等价于以下语句：

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE SEQUENCE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
>_<TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
>_seq;
CREATE TABLE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
> (
    <TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
> integer NOT NULL DEFAULT nextval('<TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
>_<TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
>_seq')
);
ALTER SEQUENCE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
>_<TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
>_seq OWNED BY <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
>;</PRE
><P>

     因此，我们就创建了一个整数列并且把它的缺省值安排为从一个序列发生器取值。应用了一个<TT
CLASS="LITERAL"
>NOT NULL</TT
>约束以确保空值不会被插入（在大多数情况下你可能还希望附加一个<TT
CLASS="LITERAL"
>UNIQUE</TT
>或者<TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>约束避免意外地插入重复的值，但这个不是自动发生的）。最后，该序列被标记为<SPAN
CLASS="QUOTE"
>"属于"</SPAN
>该列，这样当列或表被删除时该序列也会被删除。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>        因为<TT
CLASS="TYPE"
>smallserial</TT
>、<TT
CLASS="TYPE"
>serial</TT
>和<TT
CLASS="TYPE"
>bigserial</TT
>是用序列实现的，所以即使没有删除过行，在出现在列中的序列值可能有“空洞”或者间隙。如果一个从序列中分配的值被用在一行中，即使该行最终没有被成功地插入到表中，该值也被“用掉”了。例如，当插入事务回滚时就会发生这种情况。更多信息参见<A
HREF="functions-sequence.html"
>第 9.16 &#33410;</A
>中的<TT
CLASS="LITERAL"
>nextval()</TT
>。
      </P
></BLOCKQUOTE
></DIV
><P
>     要使用<TT
CLASS="TYPE"
>serial</TT
>列插入序列的下一个数值到表中， 请指定<TT
CLASS="TYPE"
>serial</TT
>列应该被赋予其缺省值。我们可以通过在<TT
CLASS="COMMAND"
>INSERT</TT
>语句中把该列排除在列列表之外来实现，也可以通过使用<TT
CLASS="LITERAL"
>DEFAULT</TT
>关键字来实现。
    </P
><P
>     类型名<TT
CLASS="TYPE"
>serial</TT
>和<TT
CLASS="TYPE"
>serial4</TT
>是等效的： 两个都创建<TT
CLASS="TYPE"
>integer</TT
>列。类型名<TT
CLASS="TYPE"
>bigserial</TT
>和<TT
CLASS="TYPE"
>serial8</TT
>也一样，只不过它们创建一个 <TT
CLASS="TYPE"
>bigint</TT
>列。如果你预计在表的生存期中使用的标识符数目超过 2<SUP
>31</SUP
> 个，那么你应该使用<TT
CLASS="TYPE"
>bigserial</TT
>。类型名<TT
CLASS="TYPE"
>smallserial</TT
>和<TT
CLASS="TYPE"
>serial2</TT
>也以相同方式工作，只不过它们创建一个<TT
CLASS="TYPE"
>smallint</TT
>列。
    </P
><P
>     为一个<TT
CLASS="TYPE"
>serial</TT
>列创建的序列在所属的列被删除的时候自动删除。你可以在不删除列的情况下删除序列，但是这会强制删除该列的默认值表达式。
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="datatype-money.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>数据类型</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>货币类型</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
