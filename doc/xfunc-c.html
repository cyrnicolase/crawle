<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>C 语言函数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="扩展 SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="内部函数"
HREF="xfunc-internal.html"><LINK
REL="NEXT"
TITLE="用户定义的聚集"
HREF="xaggr.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/xfunc.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="内部函数"
HREF="xfunc-internal.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 36. 扩展 <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="用户定义的聚集"
HREF="xaggr.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-C"
>36.9. C 语言函数</A
></H1
><P
>    用户定义的函数可以用 C 编写（或者可以与 C 兼容的语言，例如 C++）。
    这类函数被编译成动态载入对象（也被称为共享库）并且由服务器在
    需要时载入。动态载入是把<SPAN
CLASS="QUOTE"
>"C 语言"</SPAN
>函数和
    <SPAN
CLASS="QUOTE"
>"内部"</SPAN
>函数区分开的特性 &mdash; 两者真正的编码习惯
    实际上是一样的（因此，标准的内部函数库是用户定义的 C 函数很好
    的源代码实例）。
   </P
><P
>    当前 C 函数使用了两种不同的调用规范。较新的<SPAN
CLASS="QUOTE"
>"版本 1"</SPAN
>
    调用规范需要通过为该函数写一个
    <TT
CLASS="LITERAL"
>PG_FUNCTION_INFO_V1()</TT
>宏调用来指示（如下文所示）。
    如果没有这样一个宏，则表示旧风格（<SPAN
CLASS="QUOTE"
>"版本 0"</SPAN
>）的函数。
    在两种情况中<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>指定的语言
    名都是<TT
CLASS="LITERAL"
>C</TT
>。由于移植性问题以及功能较弱的问题，旧风格
    的函数目前已经被废弃，但是出于兼容性的原因仍支持这种形式。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-DYNLOAD"
>36.9.1. 动态载入</A
></H2
><P
>    在一个会话中第一次调用一个特定可载入对象文件中的用户定义函数时，
    动态载入器会把那个对象文件载入到内存以便该函数被调用。因此用户
    定义的 C 函数的<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>必须
    为该函数指定两块信息：可载入对象文件的名称，以及要在该对象文件中
    调用的特定函数的 C 名称（链接符号）。如果没有显式指定 C 名称，则
    它被假定为和 SQL 函数名相同。
   </P
><P
>    下面的算法被用来基于<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
    命令中给定的名称来定位共享对象文件：

    <P
></P
></P><OL
TYPE="1"
><LI
><P
>       如果名称是一个绝对路径，则载入给定的文件。
      </P
></LI
><LI
><P
>       如果该名称以字符串<TT
CLASS="LITERAL"
>$libdir</TT
>开始，那么这一部分会被
       <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>包的库目录名（在编译时确定）替换。
       
      </P
></LI
><LI
><P
>       如果该名称不包含目录部分，会在配置变量
       <A
HREF="runtime-config-client.html#GUC-DYNAMIC-LIBRARY-PATH"
>dynamic_library_path</A
>指定的路径中搜索该
       文件。
      </P
></LI
><LI
><P
>       否则（在该路径中没找到该文件，或者它包含一个非绝对目录），
       动态载入器将尝试接受给定的名称，这大部分会导致失败（依赖
       当前工作目录是不可靠的）。
      </P
></LI
></OL
><P>

    如果这个序列不起作用，会把平台相关的共享库文件名扩展（通常是
    <TT
CLASS="FILENAME"
>.so</TT
>）追加到给定的名称并且再次尝试上述
    的过程。如果还是失败，则载入失败。
   </P
><P
>    我们推荐相对于<TT
CLASS="LITERAL"
>$libdir</TT
>或者通过动态库路径来
    定位共享库。如果升级版本时新的安装在一个不同的位置，则可以
    简化升级过程。<TT
CLASS="LITERAL"
>$libdir</TT
>实际表示的目录可以用
    命令<TT
CLASS="LITERAL"
>pg_config --pkglibdir</TT
>来找到。
   </P
><P
>    用于运行<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>服务器的
    用户 ID 必须能够通过要载入文件的路径。常见的错误是把文件或
    更高层的目录变得对<SPAN
CLASS="SYSTEMITEM"
>postgres</SPAN
>用户
    不可读或者不可执行。
   </P
><P
>    在任何情况下，<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>命令
    中给定的文件名会被原封不动地记录在系统目录中，这样如果需要再次
    载入该文件则会应用同样的过程。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>不会自动编译 C 函数。在
     从<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>命令中引用对象文件
     之前，它必须先被编译好。更多信息请见<A
HREF="xfunc-c.html#DFUNC"
>第 36.9.6 &#33410;</A
>。
    </P
></BLOCKQUOTE
></DIV
><P
>    为了确保动态载入对象文件不会被载入到一个不兼容的服务器，
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>会检查该文件是否包含一个
    带有合适内容的<SPAN
CLASS="QUOTE"
>"magic block"</SPAN
>。这允许服务器检测到明显的不兼
    容，例如为不同<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>主版本编译
    的代码。从<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.2 开始，动态
    载入的函数要求有一个 magic block。要包括一个 magic block，在写上包括
    头文件<TT
CLASS="FILENAME"
>fmgr.h</TT
>的语句之后，在该模块的源文件之一（并且只
    能在其中一个）中写上这些：

</P><PRE
CLASS="PROGRAMLISTING"
>#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif</PRE
><P>

    如果代码不需要针对 8.2 之前的<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
    发行版进行编译，则<TT
CLASS="LITERAL"
>#ifdef</TT
>测试可以被省略。
   </P
><P
>    在被第一次使用后，动态载入对象文件会留在内存中。在同一个会话中
    对该函数未来的调用将只会消耗很小的负荷进行符号表查找。如果需要
    重新载入一个对象文件（例如重新编译以后），需要开始一个新的会话。
   </P
><P
>    可以选择让一个动态载入文件包含初始化和终止化函数。如果文件包含一个
    名为<CODE
CLASS="FUNCTION"
>_PG_init</CODE
>的函数，则文件被载入后会立刻调用该函数。
    该函数不接受参数并且应该返回 void。如果文件包括一个名为
    <CODE
CLASS="FUNCTION"
>_PG_fini</CODE
>的函数，则在卸载该文件之前会立即调用该函数。
    同样地，该函数不接受参数并且应该返回 void。注意将只在卸载文件的过程
    中会调用<CODE
CLASS="FUNCTION"
>_PG_fini</CODE
>，进程结束时不会调用它（当前，卸载被
    禁用并且从不发生，但是未来可能会改变）。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-BASETYPE"
>36.9.2. C 语言函数中的基本类型</A
></H2
><P
>     要了解如何编写 C 语言函数，你需要了解
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>如何在内部表达基本数据类型
     以及如何与函数传递它们。在内部，
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>把一个基本类型认为是
     <SPAN
CLASS="QUOTE"
>"一团内存"</SPAN
>。在类型上定义的用户定义函数说明了
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>在该类型上操作的方式。也就
     是说，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>将只负责把数据存在磁盘以
     及从磁盘检索数据，而使用你的用户定义函数来输入、处理和输出该数据。
    </P
><P
>     基本类型可以有三种内部格式之一：

     <P
></P
></P><UL
><LI
><P
>        传值，定长
       </P
></LI
><LI
><P
>        传引用，定长
       </P
></LI
><LI
><P
>        串引用，变长
       </P
></LI
></UL
><P>
    </P
><P
>     传值类型在长度上只能是 1、2 或 4 字节（如果你的机器上
     <TT
CLASS="LITERAL"
>sizeof(Datum)</TT
>是 8，则还有 8 字节）。你应当小心地
     定义你的类型以便它们在所有的架构上都是相同的尺寸（字节）。例如，
     <TT
CLASS="LITERAL"
>long</TT
>类型很危险，因为它在某些机器上是 4 字节但在
     另外一些机器上是 8 字节，而<TT
CLASS="TYPE"
>int</TT
>类型在大部分 Unix 机器
     上都是 4 字节。在 Unix 机器上<TT
CLASS="TYPE"
>int4</TT
>类型一种合理的实现
     可能是：

</P><PRE
CLASS="PROGRAMLISTING"
>/* 4 字节整数，传值 */
typedef int int4;</PRE
><P>

     （实际的 PostgreSQL C 代码会把这种类型称为<TT
CLASS="TYPE"
>int32</TT
>，因为
     C 中的习惯是<TT
CLASS="TYPE"
>int<TT
CLASS="REPLACEABLE"
><I
>XX</I
></TT
></TT
>
     表示<TT
CLASS="REPLACEABLE"
><I
>XX</I
></TT
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>位</I
></SPAN
>。注意
     因此还有尺寸为 1 字节的 C 类型<TT
CLASS="TYPE"
>int8</TT
>。SQL 类型
     <TT
CLASS="TYPE"
>int8</TT
>在 C 中被称为<TT
CLASS="TYPE"
>int64</TT
>。另见
     <A
HREF="xfunc-c.html#XFUNC-C-TYPE-TABLE"
>&#34920; 36-1</A
>）。
    </P
><P
>     在另一方面，任何尺寸的定长类型可以用传引用的方法传递。例如，这里有一种
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>类型的实现示例：

</P><PRE
CLASS="PROGRAMLISTING"
>/* 16 字节结构，传引用 */
typedef struct
{
    double  x, y;
} Point;</PRE
><P>

     在<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>函数中传进或传出这种
     类型时，只能使用指向这种类型的指针。要返回这样一种类型的值，用
     <TT
CLASS="LITERAL"
>palloc</TT
>分配正确的内存量，然后填充分配好的内存，
     并且返回一个指向该内存的指针（还有，如果只想返回与具有相同数据类型的
     一个输入参数相同的值，可以跳过额外的<TT
CLASS="LITERAL"
>palloc</TT
>并且返回
     指向该输入值的指针）。
    </P
><P
>     最后，所有变长类型必须也以引用的方式传递。所有变长类型必须用一个
     正好 4 字节的不透明长度域开始，该域会由<TT
CLASS="SYMBOL"
>SET_VARSIZE</TT
>
     设置，绝不要直接设置该域！所有要被存储在该类型中的数据必须在内存
     中接着该长度域的后面存储。长度域包含该结构的总长度，也就是包括长
     度域本身的尺寸。
    </P
><P
>     另一个重点是要避免在数据类型值中留下未被初始化的位。例如，要注意
     把可能存在于结构中的任何对齐填充字节置零。如果不这样做，你的数据
     类型的逻辑等价常量可能会被规划器认为是不等的，进而导致低效的（不过
     还是正确的）计划。
    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>&#35686;&#21578;</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>绝不要</I
></SPAN
>修改通过引用传递的输入值的内容。如果这样做
      很可能会破坏磁盘上的数据，因为给出的指针可能直接指向一个磁盘缓冲
      区。这条规则唯一的例外在<A
HREF="xaggr.html"
>第 36.10 &#33410;</A
>中有解释。
     </P
></TD
></TR
></TABLE
></DIV
><P
>     例如，我们可以这样定义类型<TT
CLASS="TYPE"
>text</TT
>：

</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;</PRE
><P>

     <TT
CLASS="LITERAL"
>[FLEXIBLE_ARRAY_MEMBER]</TT
>记号表示数据部分的实际
     长度不由该声明指定。
    </P
><P
>     在操纵变长字节时，我们必须小心地分配正确数量的内存并且正确地
     设置长度域。例如，如果我们想在一个<TT
CLASS="STRUCTNAME"
>text</TT
>结构
     中存储 40 字节，我们可以使用这样的代码片段：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination-&#62;data, buffer, 40);
...</PRE
><P>

     <TT
CLASS="LITERAL"
>VARHDRSZ</TT
>和<TT
CLASS="LITERAL"
>sizeof(int32)</TT
>一样，
     但是用宏<TT
CLASS="LITERAL"
>VARHDRSZ</TT
>来引用变长类型的载荷的
     尺寸被认为是比较好的风格。还有，<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>必须</I
></SPAN
>
     使用<TT
CLASS="LITERAL"
>SET_VARSIZE</TT
>宏来设置长度域，而不是用
     简单的赋值来设置。
    </P
><P
>     <A
HREF="xfunc-c.html#XFUNC-C-TYPE-TABLE"
>&#34920; 36-1</A
>指定在编写使用一种
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>内建类型的 C 语言函数时，
     哪一种 C 类型对应于哪一种 SQL 类型。
     <SPAN
CLASS="QUOTE"
>"定义文件"</SPAN
>列给出了要得到该类型定义需要
     包括的头文件（实际的定义可能在一个由列举文件包括的不同
     文件中。推荐用户坚持使用已定义的接口）。注意在任何源文
     件中应该总是首先包括<TT
CLASS="FILENAME"
>postgres.h</TT
>，
     因为它声明了很多你需要的东西。
    </P
><DIV
CLASS="TABLE"
><A
NAME="XFUNC-C-TYPE-TABLE"
></A
><P
><B
>&#34920; 36-1. 内建 SQL 类型等效的 C 类型</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>          SQL 类型
         </TH
><TH
>          C 类型
         </TH
><TH
>          定义文件
         </TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="TYPE"
>abstime</TT
></TD
><TD
><TT
CLASS="TYPE"
>AbsoluteTime</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>bigint</TT
> (<TT
CLASS="TYPE"
>int8</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>int64</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
>（可能是编译器内建）</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>box</TT
></TD
><TD
><TT
CLASS="TYPE"
>BOX*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
><TT
CLASS="TYPE"
>bytea*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>"char"</TT
></TD
><TD
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
>（编译器内建）</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>character</TT
></TD
><TD
><TT
CLASS="TYPE"
>BpChar*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>cid</TT
></TD
><TD
><TT
CLASS="TYPE"
>CommandId</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>date</TT
></TD
><TD
><TT
CLASS="TYPE"
>DateADT</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>smallint</TT
> (<TT
CLASS="TYPE"
>int2</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>int16</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>int2vector</TT
></TD
><TD
><TT
CLASS="TYPE"
>int2vector*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>integer</TT
> (<TT
CLASS="TYPE"
>int4</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>int32</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>real</TT
> (<TT
CLASS="TYPE"
>float4</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>float4*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>double precision</TT
> (<TT
CLASS="TYPE"
>float8</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>float8*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
><TT
CLASS="TYPE"
>Interval*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>datatype/timestamp.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>lseg</TT
></TD
><TD
><TT
CLASS="TYPE"
>LSEG*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
><TT
CLASS="TYPE"
>Name</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="TYPE"
>Oid</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>oidvector</TT
></TD
><TD
><TT
CLASS="TYPE"
>oidvector*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>path</TT
></TD
><TD
><TT
CLASS="TYPE"
>PATH*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>point</TT
></TD
><TD
><TT
CLASS="TYPE"
>POINT*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>reltime</TT
></TD
><TD
><TT
CLASS="TYPE"
>RelativeTime</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
><TT
CLASS="TYPE"
>text*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>tid</TT
></TD
><TD
><TT
CLASS="TYPE"
>ItemPointer</TT
></TD
><TD
><TT
CLASS="FILENAME"
>storage/itemptr.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>time</TT
></TD
><TD
><TT
CLASS="TYPE"
>TimeADT</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>time with time zone</TT
></TD
><TD
><TT
CLASS="TYPE"
>TimeTzADT</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
><TT
CLASS="TYPE"
>Timestamp*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>datatype/timestamp.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>tinterval</TT
></TD
><TD
><TT
CLASS="TYPE"
>TimeInterval</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>varchar</TT
></TD
><TD
><TT
CLASS="TYPE"
>VarChar*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>xid</TT
></TD
><TD
><TT
CLASS="TYPE"
>TransactionId</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>     现在我们已经复习了基本类型所有可能的结构，现在可以展示一些
     真实函数的例子了。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN60180"
>36.9.3. 版本 0 调用约定</A
></H2
><P
>     我们先介绍<SPAN
CLASS="QUOTE"
>"旧风格"</SPAN
>的调用规范 &mdash; 尽管
     这种方法已经被废弃，它对初学者更容易掌握。在版本-0 方法中，
     C 函数的参数和结果只是以不同的 C 风格声明，但是要小心使用
     上文所示的每种 SQL 数据类型的 C 表达。
    </P
><P
>     这里有一些例子：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &#60;string.h&#62;
#include "utils/geo_decls.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* 传值 */

int
add_one(int arg)
{
    return arg + 1;
}

/* 传引用，定长 */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;

    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;

    return new_point;
}

/* 传引用，变长 */

text *
copytext(text *t)
{
    /*
     * VARSIZE 是结构的总尺寸（字节）。
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    SET_VARSIZE(new_t, VARSIZE(t));
    /*
     * VARDATA 是指向结构的数据区域的指针。
     */
    memcpy((void *) VARDATA(new_t), /* 目标 */
           (void *) VARDATA(t),     /* 源 */
           VARSIZE(t) - VARHDRSZ);  /* 多少字节 */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    return new_text;
}</PRE
><P>
    </P
><P
>     假定上述代码已经在文件<TT
CLASS="FILENAME"
>funcs.c</TT
>中准备好
     并且已经被编译到一个共享对象中，我们可以用下面的命令在
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>中定义这些函数：

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- 注意这是重载名为 "add_one" 的 SQL 函数
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'concat_text'
     LANGUAGE C STRICT;</PRE
><P>
    </P
><P
>     这里，<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>表示共享库文件的
     目录（例如<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的教程目录，
     它包含这一节使用的例子的代码）。（更好的风格是在把
     <TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>增加到搜索路径后，只在
     <TT
CLASS="LITERAL"
>AS</TT
>子句中使用<TT
CLASS="LITERAL"
>'funcs'</TT
>。在很多情况下，我们
     可以省略共享库的系统相关的扩展，通常是<TT
CLASS="LITERAL"
>.so</TT
>或者
     <TT
CLASS="LITERAL"
>.sl</TT
>）。
    </P
><P
>     注意我们已经指定这些函数为<SPAN
CLASS="QUOTE"
>"严格的"</SPAN
>，表示如果任何
     输入值为空系统应该自动假定它们会得到空值结果。通过这样做，我们可
     以避免在函数代码中检测空值输入。如果不这样做，我们必须显式地检查
     空值，做法是对每一个传引用参数检查是不是空指针（对于传值参数，我
     们甚至没有方法来检查！）。
    </P
><P
>     尽管这种调用规范简单易用，它不太容易移植，某些架构上对于用这种方法
     传递小于<TT
CLASS="TYPE"
>int</TT
>的数据类型会有问题。还有，没有简单的方法
     返回空结果，也没有办法处理空值参数（除了让该函数变成严格的）。下文
     介绍的版本-1 规范克服了这些缺陷。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN60207"
>36.9.4. 版本 1 的调用约定</A
></H2
><P
>     版本-1 的调用规范依赖于宏来降低传参数和结果的复杂度。版本-1 函数的
     C 声明总是：
</P><PRE
CLASS="PROGRAMLISTING"
>Datum funcname(PG_FUNCTION_ARGS)</PRE
><P>
     此外，宏调用：
</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(funcname);</PRE
><P>
     必须出现在同一个源文件中（按惯例会正好写在该函数本身之前）。
     这种宏调用不是<TT
CLASS="LITERAL"
>内部</TT
>语言函数所需要的，因为
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>会假定所有内部函数都使用
     版本-1 规范。不过，对于动态载入函数是必需的。
    </P
><P
>     在版本-1 函数中，每一个实参都使用对应于该参数数据类型的
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     宏取得，并且结果要用对应于返回类型的
     <CODE
CLASS="FUNCTION"
>PG_RETURN_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     宏返回。
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     的参数是要取得的函数参数的编号，从零开始计。
     <CODE
CLASS="FUNCTION"
>PG_RETURN_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     的参数是实际要返回的值。
    </P
><P
>     这里展示的是和上述函数相同的函数，但是用版本-1 的风格编码：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &#60;string.h&#62;
#include "fmgr.h"
#include "utils/geo_decls.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* 传值 */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* 传引用，定长 */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* FLOAT8 的宏隐藏了它的传引用本质。 */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* 这里，Point 的传引用本质没有被掩盖。 */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;

    PG_RETURN_POINT_P(new_point);
}

/* 传引用，变长 */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);
    /*
     * VARSIZE 是结构的总尺寸（字节）。
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    SET_VARSIZE(new_t, VARSIZE(t));
    /*
     * VARDATA 是指向结构的数据区域的指针。
     */
    memcpy((void *) VARDATA(new_t), /* 目标 */
           (void *) VARDATA(t),     /* 源 */
           VARSIZE(t) - VARHDRSZ);  /* 多少字节 */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}</PRE
><P>
    </P
><P
>     版本-1 的<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>命令和版本-0 的相同。
    </P
><P
>     乍一看，版本-1 编码规范可能就是无意义的愚民政策。不过，它们确实提供了
     很多改进，因为那些宏可以隐藏不需要的细节。一个例子是在编码
     <CODE
CLASS="FUNCTION"
>add_one_float8</CODE
>时，我们不再需要关注
     <TT
CLASS="TYPE"
>float8</TT
>是一种传引用类型。另一个例子是变长类型的
     <TT
CLASS="LITERAL"
>GETARG</TT
>宏允许更方便地取得<SPAN
CLASS="QUOTE"
>"被 TOAST"</SPAN
>（压缩
     或者线外）的值。
    </P
><P
>     版本-1 函数中的一个大进步是对空值输入和结果更好的处理。宏
     <CODE
CLASS="FUNCTION"
>PG_ARGISNULL(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</CODE
>允许一个函数
     测试是否每一个输入为空（当然，只需要在没有声明为<SPAN
CLASS="QUOTE"
>"strict"</SPAN
>
     的函数中这样做）。和
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>宏
     一样，输入参数也是从零开始计数。注意应该在验证了一个参数不是空之后才执行
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>。要
     返回一个空结果，应执行<CODE
CLASS="FUNCTION"
>PG_RETURN_NULL()</CODE
>，它对
     严格的以及非严格的函数都有用。
    </P
><P
>     在新风格接口中提供的其他选项是
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>宏
     的两个变种。其中的第一种是
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</CODE
>，
     它确保返回的指定参数的拷贝可以被安全地写入（通常的宏有时会返回一个指向
     表中物理存储的值，它不能被写入。使用
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</CODE
>
     宏可以保证得到一个可写的结果）。第二种变种
    <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_SLICE()</CODE
>
    宏有三个参数。第一个是函数参数的编号（如上文）。第二个和第三个是要被返回的
    段的偏移量和长度。偏移量从零开始计算，而负值的长度则表示要求返回该值的剩余
    部分。当大型值的存储类型为<SPAN
CLASS="QUOTE"
>"external"</SPAN
>时，这些宏提供了访问这
    些大型值的更有效的方法（列的存储类型可以使用
    <TT
CLASS="LITERAL"
>ALTER TABLE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
> ALTER
    COLUMN <TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
> SET STORAGE
    <TT
CLASS="REPLACEABLE"
><I
>storagetype</I
></TT
></TT
>来指定。
    <TT
CLASS="REPLACEABLE"
><I
>storagetype</I
></TT
>取<TT
CLASS="LITERAL"
>plain</TT
>、
    <TT
CLASS="LITERAL"
>external</TT
>、<TT
CLASS="LITERAL"
>extended</TT
>或者
    <TT
CLASS="LITERAL"
>main</TT
>）。
    </P
><P
>     最后，版本-1 的函数调用规范可以返回集合结果（
     <A
HREF="xfunc-c.html#XFUNC-C-RETURN-SET"
>第 36.9.9 &#33410;</A
>）、实现触发器函数（
     <A
HREF="triggers.html"
>第 37 &#31456;</A
>）和过程语言调用处理器（<A
HREF="plhandler.html"
>第 54 &#31456;</A
>）。版本-1 的代码也比版本-0 的可移植性
     更好，因为它不会打破 C 标准中对函数调用协议上的限制。更多细节
     可见源代码发布中的
     <TT
CLASS="FILENAME"
>src/backend/utils/fmgr/README</TT
>。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN60265"
>36.9.5. 编写代码</A
></H2
><P
>     在开始更高级的话题之前，我们应该讨论一下用于
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> C 语言函数的编码规则。
     虽然可以把不是 C 编写的函数载入到
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>中，这通常是很困难的，
     因为其他语言（例如 C++、FORTRAN 或者 Pascal）通常不会遵循和 C
     相同的调用规范。也就是说，其他语言不会以同样的方式在函数之间传递
     参数以及返回值。由于这个原因，我们会假定你的 C 语言函数确实是用 C
     编写的。
    </P
><P
>     编写和编译 C 函数的基本规则如下：

     <P
></P
></P><UL
><LI
><P
>        使用<TT
CLASS="LITERAL"
>pg_config
        --includedir-server</TT
>
        找出<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>服务器头文件安装在
        系统的哪个位置。
       </P
></LI
><LI
><P
>        编译并且链接你的代码（这样它就能被动态载入到
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>中）总是
        要求特殊的标志。对特定的操作系统的做法详见
        <A
HREF="xfunc-c.html#DFUNC"
>第 36.9.6 &#33410;</A
>。
       </P
></LI
><LI
><P
>        记住为你的共享库按<A
HREF="xfunc-c.html#XFUNC-C-DYNLOAD"
>第 36.9.1 &#33410;</A
>中所述
        定义一个<SPAN
CLASS="QUOTE"
>"magic block"</SPAN
>。
       </P
></LI
><LI
><P
>        在分配内存时，使用
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>函数
        <CODE
CLASS="FUNCTION"
>palloc</CODE
>和 <CODE
CLASS="FUNCTION"
>pfree</CODE
>，
        而不是使用对应的 C 库函数
        <CODE
CLASS="FUNCTION"
>malloc</CODE
>和<CODE
CLASS="FUNCTION"
>free</CODE
>。
        在每个事务结束时会自动释放通过<CODE
CLASS="FUNCTION"
>palloc</CODE
>
        分配的内存，以免内存泄露。
       </P
></LI
><LI
><P
>        总是要使用<CODE
CLASS="FUNCTION"
>memset</CODE
>把你的结构中的字节置零（或者
        最开始就用<CODE
CLASS="FUNCTION"
>palloc0</CODE
>分配它们）。即使你对结构中的
        每个域都赋值，也可能有对齐填充（结构中的空洞）包含着垃圾值。
        如果不这样做，很难支持哈希索引或哈希连接，因为你必须选出数据
        结构中有意义的位进行哈希计算。规划器有时也依赖于用按位相等来
        比较常量，因此如果逻辑等价的值不是按位相等的会导致出现不想要
        的规划结果。
       </P
></LI
><LI
><P
>        大部分的内部<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>类型
        都声明在<TT
CLASS="FILENAME"
>postgres.h</TT
>中，不过函数管理器
        接口（<TT
CLASS="SYMBOL"
>PG_FUNCTION_ARGS</TT
>等）在
        <TT
CLASS="FILENAME"
>fmgr.h</TT
>中，因此你将需要包括至少这两个
        文件。为了移植性，最好在包括任何其他系统或者用户头文件之前，
        <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>先</I
></SPAN
>包括<TT
CLASS="FILENAME"
>postgres.h</TT
>。包
        括<TT
CLASS="FILENAME"
>postgres.h</TT
>也将会为你包括
        <TT
CLASS="FILENAME"
>elog.h</TT
>和<TT
CLASS="FILENAME"
>palloc.h</TT
>。
       </P
></LI
><LI
><P
>        对象文件中定义的符号名不能相互冲突或者与
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>服务器可执行程序中
        定义的符号冲突。如果出现有关于此的错误消息，你将必须重命名你的
        函数或者变量。
       </P
></LI
></UL
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DFUNC"
>36.9.6. 编译和链接动态载入的函数</A
></H2
><P
>  在使用 C 编写的<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>扩展函数之前，必须以一种特殊的方式编译并且链接它们，以便产生一个能被服务器动态载入的文件。简而言之，需要创建一个<I
CLASS="FIRSTTERM"
>共享库</I
>。

 </P
><P
>  超出本节所含内容之外的信息请参考你的操作系统文档，特别是 C 编译器（<TT
CLASS="COMMAND"
>cc</TT
>）和链接编辑器（<TT
CLASS="COMMAND"
>ld</TT
>）的手册页。另外，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>源代码的<TT
CLASS="FILENAME"
>contrib</TT
>目录中包含了一些可以工作的例子。但是，如果你依靠这些例子，也会使你的模块依赖于<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>源码的可用性。
 </P
><P
>  创建共享库通常与链接可执行文件相似：首先源文件被编译成对象文件，然后对象文件被链接起来。对象文件需要被创建为<I
CLASS="FIRSTTERM"
>独立位置代码</I
>（<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>），，这在概念上意味着当它们被可执行文件载入时，它们可以被放置在内存中的任意位置（用于可执行文件的对象文件通常不会以那种方式编译）。链接一个共享库的命令会包含特殊标志来把它与链接一个可执行文件区分开（至少在理论上 &mdash; 在某些系统上实际上很丑陋）。
 </P
><P
>  在下列例子中，我们假定你的源代码在一个文件<TT
CLASS="FILENAME"
>foo.c</TT
>中，并且我们将创建一个共享库<TT
CLASS="FILENAME"
>foo.so</TT
>。除非特别注明，中间的对象文件将被称为<TT
CLASS="FILENAME"
>foo.o</TT
>。一个共享库能包含多于一个对象文件，但是我们在这里只使用一个。
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>
    </DT
><DD
><P
>      用来创建<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>的编译器标志是<TT
CLASS="OPTION"
>-fpic</TT
>。要创建共享库，编译器标志是<TT
CLASS="OPTION"
>-shared</TT
>。
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
      这适用于<SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>从 3.0 开始的版本。
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
>
    </DT
><DD
><P
>      该系统编译器创建<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>的编译器标志是<TT
CLASS="OPTION"
>+z</TT
>。当使用<SPAN
CLASS="APPLICATION"
>GCC</SPAN
>自己的<TT
CLASS="OPTION"
>-fpic</TT
>时。用于共享库的链接器标志是<TT
CLASS="OPTION"
>-b</TT
>。因此：
</P><PRE
CLASS="PROGRAMLISTING"
>cc +z -c foo.c</PRE
><P>
      或者：
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c</PRE
><P>
      并且然后：
</P><PRE
CLASS="PROGRAMLISTING"
>ld -b -o foo.sl foo.o</PRE
><P>
      和大部分其他系统不同，<SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
>为共享库使用扩展<TT
CLASS="FILENAME"
>.sl</TT
>。
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
>
    </DT
><DD
><P
>      创建<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>的编译器标志是<TT
CLASS="OPTION"
>-fpic</TT
>。在某些平台上的某些情况下，如果<TT
CLASS="OPTION"
>-fpic</TT
>不起作用，那么必须使用<TT
CLASS="OPTION"
>-fPIC</TT
>。详情请参考 GCC 手册。创建一个共享库的编译器标志是<TT
CLASS="OPTION"
>-shared</TT
>。一个完整的例子看起来像：
</P><PRE
CLASS="PROGRAMLISTING"
>cc -fpic -c foo.c
cc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Mac OS X</SPAN
>
    </DT
><DD
><P
>      这里是一个例子。它假定安装了开发者工具。
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
>
    </DT
><DD
><P
>      创建<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>的编译器标志是<TT
CLASS="OPTION"
>-fpic</TT
>。对于<ACRONYM
CLASS="ACRONYM"
>ELF</ACRONYM
>系统，带着标志<TT
CLASS="OPTION"
>-shared</TT
>的编译器被用来链接共享库。在旧的非 ELF 系统上，<TT
CLASS="LITERAL"
>ld -Bshareable</TT
>会被使用。
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
>
    </DT
><DD
><P
>      创建<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>的编译器标志是<TT
CLASS="OPTION"
>-fpic</TT
>。<TT
CLASS="LITERAL"
>ld -Bshareable</TT
>被用来链接共享库。
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
ld -Bshareable -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
>
    </DT
><DD
><P
>      创建<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>的编译器标志是<TT
CLASS="OPTION"
>-KPIC</TT
>（用于 Sun 编译器）以及<TT
CLASS="OPTION"
>-fpic</TT
>（用于<SPAN
CLASS="APPLICATION"
>GCC</SPAN
>）。要链接共享库，编译器选项对几种编译器都是<TT
CLASS="OPTION"
>-G</TT
>或者是对<SPAN
CLASS="APPLICATION"
>GCC</SPAN
>使用<TT
CLASS="OPTION"
>-shared</TT
>。
</P><PRE
CLASS="PROGRAMLISTING"
>cc -KPIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -G -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>UnixWare</SPAN
>
    </DT
><DD
><P
>      创建<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>的编译器标志是<TT
CLASS="OPTION"
>-KPIC</TT
>（用于 SCO 编译器）以及<TT
CLASS="OPTION"
>-fpic</TT
>（用于<SPAN
CLASS="APPLICATION"
>GCC</SPAN
>）。要链接共享库，编译器选项是<TT
CLASS="OPTION"
>-G</TT
>（用于 SCO 编译器）以及<TT
CLASS="OPTION"
>-shared</TT
>（用于<SPAN
CLASS="PRODUCTNAME"
>GCC</SPAN
>）。
</P><PRE
CLASS="PROGRAMLISTING"
>cc -K PIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
></DL
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>   如果这对你来说太复杂，你应该考虑使用<A
HREF="http://www.gnu.org/software/libtool/"
TARGET="_top"
>   <SPAN
CLASS="PRODUCTNAME"
>GNU Libtool</SPAN
></A
>，它会用一个统一的接口隐藏平台差异。
  </P
></BLOCKQUOTE
></DIV
><P
>  结果的共享库文件接着就可以被载入到<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>。当把文件名指定给<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>命令时，必须把共享库文件的名字给它，而不是中间的对象文件。注意系统的标准共享库扩展（通常是<TT
CLASS="LITERAL"
>.so</TT
>或者<TT
CLASS="LITERAL"
>.sl</TT
>）在<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>命令中可以被忽略，并且通常为了最好的可移植性应该被忽略。
 </P
><P
>  服务器会期望在哪里寻找共享库文件请参考<A
HREF="xfunc-c.html#XFUNC-C-DYNLOAD"
>第 36.9.1 &#33410;</A
>。
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN60466"
>36.9.7. 组合类型参数</A
></H2
><P
>     组合类型没有像 C 结构那样的固定布局。组合类型的实例可能包含
     空值域。此外，继承层次中的组合类型可能具有和同一继承层次中
     其他成员不同的域。因此，
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>提供了函数接口
     来访问 C 的组合类型的域。
    </P
><P
>     假设我们想要写一个函数来回答查询：

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';</PRE
><P>

     如果使用调用规范版本 0，我们可以定义
     <CODE
CLASS="FUNCTION"
>c_overpaid</CODE
>为：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/executor.h"  /* 用于 GetAttributeByName() */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

bool
c_overpaid(HeapTupleHeader t, /* emp 的当前行 */
           int32 limit)
{
    bool isnull;
    int32 salary;

    salary = DatumGetInt32(GetAttributeByName(t, "salary", &#38;isnull));
    if (isnull)
        return false;
    return salary &#62; limit;
}</PRE
><P>

     在版本-1 编码中，上面的函数可能看起来是这样的：

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/executor.h"  /* 用于 GetAttributeByName() */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &#38;isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* 另外，我们可能更想对空 salary 用 PG_RETURN_NULL() 。*/

    PG_RETURN_BOOL(DatumGetInt32(salary) &#62; limit);
}</PRE
><P>
    </P
><P
>     <CODE
CLASS="FUNCTION"
>GetAttributeByName</CODE
>是返回指定行的属性的
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>系统函数。它有三个参数：
     类型为<TT
CLASS="TYPE"
>HeapTupleHeader</TT
>的传入参数、想要访问的函数名
     以及一个说明该属性是否为空的返回参数。
     <CODE
CLASS="FUNCTION"
>GetAttributeByName</CODE
>返回一个<TT
CLASS="TYPE"
>Datum</TT
>
     值，可以把它用合适的<CODE
CLASS="FUNCTION"
>DatumGet<TT
CLASS="REPLACEABLE"
><I
>XXX</I
></TT
>()</CODE
>
     宏转换成正确的数据类型。注意如果空值标志被设置，那么返回值是没有
     意义的，所以在对结果做任何事情之前应该先检查空值标志。
    </P
><P
>     也有<CODE
CLASS="FUNCTION"
>GetAttributeByNum</CODE
>函数，它可以用目标属性
     的属性号而不是属性名来选择目标属性。
    </P
><P
>     下面的命令声明 SQL 中的<CODE
CLASS="FUNCTION"
>c_overpaid</CODE
>：

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;</PRE
><P>

     注意我们用了<TT
CLASS="LITERAL"
>STRICT</TT
>，这样我们不需要检查输入参数是否
     为 NULL。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN60490"
>36.9.8. 返回行（组合类型）</A
></H2
><P
>     要从一个 C 语言函数中返回一个行或者组合类型值，你可以使用一种
     特殊的 API，它提供的宏和函数隐藏了大部分的构建组合数据类型的
     复杂性。要使用这种 API，源文件中必须包括：
</P><PRE
CLASS="PROGRAMLISTING"
>#include "funcapi.h"</PRE
><P>
    </P
><P
>     有两种方式可以构建一个组合数据值（以后就叫一个<SPAN
CLASS="QUOTE"
>"元组"</SPAN
>）：
     可以从一个 Datum 值的数组构造，或者从一个 C 字符串（可被传递给该元组
     各列的数据类型的输入转换函数）的数组构造。在两种情况下，都首先需要为
     该元组的结构获得或者构造一个<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>描述符。在处
     理 Datum 时，需要把该<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>传递给
     <CODE
CLASS="FUNCTION"
>BlessTupleDesc</CODE
>，接着为每一行调用
     <CODE
CLASS="FUNCTION"
>heap_form_tuple</CODE
>。在处理 C 字符串时，需要把该
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>传递给
     <CODE
CLASS="FUNCTION"
>TupleDescGetAttInMetadata</CODE
>，接着为每一行调用
     <CODE
CLASS="FUNCTION"
>BuildTupleFromCStrings</CODE
>。对于返回一个元组集合的函数，
     这些设置步骤可以在第一次调用该函数时一次性完成。
    </P
><P
>     有一些助手函数可以用来设置所需的<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>。在大部分
     返回组合值的函数中推荐的方式是调用：
</P><PRE
CLASS="PROGRAMLISTING"
>TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)</PRE
><P>
     传递传给调用函数本身的同一个<TT
CLASS="LITERAL"
>fcinfo</TT
>结构（这当然要求使用的
     是版本-1 的调用规范）。<TT
CLASS="VARNAME"
>resultTypeId</TT
>可以被指定为
     <TT
CLASS="LITERAL"
>NULL</TT
>或者一个本地变量的地址以接收该函数的结果类型 OID。
     <TT
CLASS="VARNAME"
>resultTupleDesc</TT
>应该是一个本地
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>变量的地址。检查结果是不是
     <TT
CLASS="LITERAL"
>TYPEFUNC_COMPOSITE</TT
>，如果是则
     <TT
CLASS="VARNAME"
>resultTupleDesc</TT
>已经被用所需的
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>填充（如果不是，你可以报告一个错误，并且
     返回<SPAN
CLASS="QUOTE"
>"function returning record called in context that
     cannot accept type record"</SPAN
>字样的消息）。
    </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>&#25552;&#31034;: </B
>      <CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
>能够解析一个多态函数结果的实际类型，
      因此不仅在返回组合类型的函数中，在返回标量多态结果的函数中它也是非常
      有用的。<TT
CLASS="VARNAME"
>resultTypeId</TT
>输出主要用于返回多态标量的函数。
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>      <CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
>有一个兄弟
      <CODE
CLASS="FUNCTION"
>get_expr_result_type</CODE
>，它被用来解析被表示为一棵表达式
      树的函数调用的输出类型。在尝试确定来自函数外部的结果类型时可以用它。
      也有一个<CODE
CLASS="FUNCTION"
>get_func_result_type</CODE
>，当只有函数的 OID 可用时
      可以用它。不过这些函数无法处理被声明为返回<TT
CLASS="STRUCTNAME"
>record</TT
>的
      函数，并且<CODE
CLASS="FUNCTION"
>get_func_result_type</CODE
>无法解析多态类型，因此你
      应该优先使用<CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
>。
     </P
></BLOCKQUOTE
></DIV
><P
>     比较老的，现在已经被废弃的获得<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>的函数是：
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc RelationNameGetTupleDesc(const char *relname)</PRE
><P>
     它可以为一个提到的关系的行类型得到<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>，
     还有：
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)</PRE
><P>
     可以基于一个类型 OID 得到<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>。这可以被用来
     为一种基础或者组合类型获得<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>。不过，对于
     返回<TT
CLASS="STRUCTNAME"
>record</TT
>的函数它不起作用，并且它无法解析多态类型。
    </P
><P
>     一旦有了一个<TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>，如果计划处理 Datum可以调用：
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc BlessTupleDesc(TupleDesc tupdesc)</PRE
><P>
     如果计划处理 C 字符串，可调用：
</P><PRE
CLASS="PROGRAMLISTING"
>AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)</PRE
><P>
     如果正在编写一个返回集合的函数，你可以把这些函数的结果保存在
     <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>结构中 &mdash; 分别使用
     <TT
CLASS="STRUCTFIELD"
>tuple_desc</TT
>或者<TT
CLASS="STRUCTFIELD"
>attinmeta</TT
>域。
    </P
><P
>     在处理 Datum 时，使用
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)</PRE
><P>
     来用 Datum 形式的用户数据构建一个<TT
CLASS="STRUCTNAME"
>HeapTuple</TT
>。
    </P
><P
>     在处理 C 字符串时，使用
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)</PRE
><P>
     来用 C 字符串形式的用户数据构建一个<TT
CLASS="STRUCTNAME"
>HeapTuple</TT
>。
     <TT
CLASS="PARAMETER"
>values</TT
>是一个 C 字符串数组，每一个元素是返回行
     的一个属性。每一个 C 字符串应该是该属性数据类型的输入函数所期望
     的格式。为了对一个属性返回空值，<TT
CLASS="PARAMETER"
>values</TT
>数组中对
     应的指针应该被设置为<TT
CLASS="SYMBOL"
>NULL</TT
>。对于你返回的每一行都将
     再次调用这个函数。
    </P
><P
>     一旦已经构建了一个要从函数中返回的元组，它必须被转换成一个
     <TT
CLASS="TYPE"
>Datum</TT
>。使用
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTupleGetDatum(HeapTuple tuple)</PRE
><P>
     可把一个<TT
CLASS="STRUCTNAME"
>HeapTuple</TT
>转换成合法的 Datum。如果你
     只想返回一行，那么这个<TT
CLASS="TYPE"
>Datum</TT
>可以被直接返回，在一个
     集合返回函数中它也可以被当做当前的返回值。
    </P
><P
>     下一节中会有一个例子。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-RETURN-SET"
>36.9.9. 返回集合</A
></H2
><P
>     也提供了一种特殊的 API 来支持从 C 语言函数中返回集合（多个行）。
     集合返回函数必须遵循版本-1 的调用规范。如上文所述，源文件中还
     必须包括<TT
CLASS="FILENAME"
>funcapi.h</TT
>。
    </P
><P
>     对返回的每一个项，一个集合返回函数（<ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>）都会
     被调用一次。因此，这个<ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>必须保存足够的状态来
     记住它正在做什么并且在每次调用时返回下一个项。结构
     <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>被提供来帮助控制这个过程。在
     一个函数中，<TT
CLASS="LITERAL"
>fcinfo-&gt;flinfo-&gt;fn_extra</TT
>被用来在
     多次调用中保持指向<TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>的指针。
</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct
{
    /*
     * 本次调用以前已经被调用过多少次
     *
     * SRF_FIRSTCALL_INIT() 会为你把 call_cntr 初始化为 0，
     * 并且在每次调用 SRF_RETURN_NEXT() 时增加。
     */
    uint32 call_cntr;

    /*
     * 可选：最大调用次数
     *
     * 这里的 max_calls 只是为了方便，设置它是可选的。
     * 如果没有设置，你必须提供替代的方法来了解函数什么时候做完。
     */
    uint32 max_calls;

    /*
     * 可选：指向结果槽的指针
     *
     * 这已经被废弃并且只为向后兼容而存在，也就是那些使用被废弃的
     * TupleDescGetSlot() 的用户定义 SRF。.
     */
    TupleTableSlot *slot;

    /*
     * 可选：指向用户提供的上下文信息的指针
     *
     * user_fctx 是一个指向你自己的数据的指针，它可用来在函数的多次
     * 调用之间保存任意的上下文信息。
     */
    void *user_fctx;

    /*
     * 可选：指向包含属性类型输入元数据的结构的指针
     *
     * attinmeta 被用在返回元组（即组合数据类型）时，在返回基本数据类型
     * 时不会使用。只有想用BuildTupleFromCStrings()创建返回元组时才需要它。
     */
    AttInMetadata *attinmeta;

    /*
     * 用于保存必须在多次调用间都存在的结构的内存上下文
     *
     * SRF_FIRSTCALL_INIT() 会为你设置 multi_call_memory_ctx，并且由
     * SRF_RETURN_DONE() 来清理。对于任何需要在 SRF 的多次调用间都
     * 存在的内存来说，它是最合适的内存上下文。
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * 可选：指向包含元组描述的结构的指针
     *
     * tuple_desc 被用在返回元组（即组合数据类型）时，并且只有在用
     * heap_form_tuple() 而不是 BuildTupleFromCStrings() 构建元组时才需要它。
     * 注意这里存储的 TupleDesc 指针通常已经被先运行过 BlessTupleDesc()。
     */
    TupleDesc tuple_desc;

} FuncCallContext;</PRE
><P>
    </P
><P
>     <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>使用一些自动操纵<TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>
     （并且期望通过<TT
CLASS="LITERAL"
>fn_extra</TT
>找到它）的函数和宏。可使用：
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_IS_FIRSTCALL()</PRE
><P>
     来判断你的函数是否是第一次被调用。在第一次调用时（只能在第一次调用时）使用：
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_FIRSTCALL_INIT()</PRE
><P>
     可初始化<TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>。在每一次函数调用时（包括第一次）
     可使用：
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_PERCALL_SETUP()</PRE
><P>
     为使用<TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>做适当的设置并且清除上一次
     留下来的任何已返回的数据。
    </P
><P
>     如果你的函数有数据要返回，可使用：
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_NEXT(funcctx, result)</PRE
><P>
     把它返回给调用者（<TT
CLASS="LITERAL"
>result</TT
>必须是类型<TT
CLASS="TYPE"
>Datum</TT
>，
     可以是一个单一值或者按上文所述准备好的元组）。最后，当函数完成了
     数据返回后，可使用：
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_DONE(funcctx)</PRE
><P>
     来清理并且结束<ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>。
    </P
><P
>     <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>被调用时的当前内存上下文被称作一个瞬时上下文，
     在两次调用之间会清除它。这意味着你不必对用<CODE
CLASS="FUNCTION"
>palloc</CODE
>
     分配的所有东西调用<CODE
CLASS="FUNCTION"
>pfree</CODE
>，它们将自动被释放。不过，
     如果你想要分配任何需要在多次调用间都存在的数据结构，需要把它们
     放在其他地方。对于任何需要在<ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>结束运行之前都存
     在的数据来说，<TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
>引用的内存
     上下文是一个合适的位置。在大部分情况中，这意味着应该在做第一次
     调用设置时就切换到<TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
>中。
    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>&#35686;&#21578;</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>      虽然函数的实参在多次调用之间保持不变，但如果在瞬时上下文中
      反 TOAST 了参数（通常由
      <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
></CODE
>
      宏完成），那么被反 TOAST 的拷贝将在每次循环中被释放。相应地，
      如果你把这些值的引用保存在<TT
CLASS="STRUCTFIELD"
>user_fctx</TT
>中，你也必
      须在反 TOAST 之后把它们拷贝到
      <TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
>中，或者确保你只在那个
      上下文中反 TOAST 这些值。
     </P
></TD
></TR
></TABLE
></DIV
><P
>     一个完整的伪代码例子：
</P><PRE
CLASS="PROGRAMLISTING"
>Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <TT
CLASS="REPLACEABLE"
><I
>further declarations as needed</I
></TT
>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* 这里是一次性设置代码： */
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>if returning composite</I
></TT
>
            <TT
CLASS="REPLACEABLE"
><I
>build TupleDesc, and perhaps AttInMetadata</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>endif returning composite</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        MemoryContextSwitchTo(oldcontext);
    }

    /* 这里是每一次都要做的设置代码： */
    <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
    funcctx = SRF_PERCALL_SETUP();
    <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>

    /* 这里只是一种测试是否执行完的方法： */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* 这里返回另一个项： */
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>obtain result Datum</I
></TT
>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* 这里已经完成了项的返回并且需要进行清理： */
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        SRF_RETURN_DONE(funcctx);
    }
}</PRE
><P>
    </P
><P
>     一个返回组合类型的简单<ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>的完整例子：
</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

    /* 只在第一次函数调用时做的事情 */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* 创建一个函数上下文，让它在多次调用间都保持存在 */
        funcctx = SRF_FIRSTCALL_INIT();

        /* 切换到适合多次函数调用的内存上下文 */
        oldcontext = MemoryContextSwitchTo(funcctx-&#62;multi_call_memory_ctx);

        /* 要返回的元组总数 */
        funcctx-&#62;max_calls = PG_GETARG_UINT32(0);

        /* 为结果类型构造一个元组描述符 */
        if (get_call_result_type(fcinfo, NULL, &#38;tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * 生成后面需要用来从原始 C 字符串产生元组的属性元数据
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&#62;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* 在每一次函数调用都要完成的事情 */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&#62;call_cntr;
    max_calls = funcctx-&#62;max_calls;
    attinmeta = funcctx-&#62;attinmeta;

    if (call_cntr &#60; max_calls)    /* 如果还有要发送的 */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * 为构建返回元组准备一个值数组。这应该是一个 C
         * 字符串数组，之后类型输入函数会处理它。
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* 构建一个元组 */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* 把元组变成 datum */
        result = HeapTupleGetDatum(tuple);

        /* 清理（实际并不必要） */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* 如果没有要发送的 */
    {
        SRF_RETURN_DONE(funcctx);
    }
}</PRE
><P>

     在 SQL 中声明这个函数的一种方法是：
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE
><P>
     一种不同的方法是使用 OUT 参数：
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE
><P>
     注意在这种方法中，函数的输出类型在形式上是一种匿名的
     <TT
CLASS="STRUCTNAME"
>record</TT
>类型。
    </P
><P
>     源码中的目录<A
HREF="tablefunc.html"
>contrib/tablefunc</A
>
     下的模块包含集合返回函数更加复杂的例子。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN60619"
>36.9.10. 多态参数和返回类型</A
></H2
><P
>     C 语言函数可以被声明为接受和返回多态类型
     <TT
CLASS="TYPE"
>anyelement</TT
>、<TT
CLASS="TYPE"
>anyarray</TT
>、
     <TT
CLASS="TYPE"
>anynonarray</TT
>、
     <TT
CLASS="TYPE"
>anyenum</TT
>以及<TT
CLASS="TYPE"
>anyrange</TT
>。
     关于多态函数的详细介绍请见
     <A
HREF="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC"
>第 36.2.5 &#33410;</A
>。当函数参数或者返回
     类型被定义为多态类型时，函数的编写者无法提前知道会用什么数据类型
     调用该函数或者该函数需要返回什么数据类型。在<TT
CLASS="FILENAME"
>fmgr.h</TT
>
     中提供了两种例程来允许版本-1 的 C 函数发现其参数的实际数据类型以及
     它要返回的类型。这些例程被称为
     <TT
CLASS="LITERAL"
>get_fn_expr_rettype(FmgrInfo *flinfo)</TT
>和
     <TT
CLASS="LITERAL"
>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</TT
>。它们
     返回结果或者参数的类型的 OID，或者当该信息不可用时返回
     <TT
CLASS="SYMBOL"
>InvalidOid</TT
>。结构<TT
CLASS="LITERAL"
>flinfo</TT
>通常被当做
     <TT
CLASS="LITERAL"
>fcinfo-&gt;flinfo</TT
>访问。参数<TT
CLASS="LITERAL"
>argnum</TT
>则是从零
     开始计。<CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
>也可被用作
     <CODE
CLASS="FUNCTION"
>get_fn_expr_rettype</CODE
>的一种替代品。还有
     <CODE
CLASS="FUNCTION"
>get_fn_expr_variadic</CODE
>，它可以被用来找出 variadic 参数
     是否已经被合并到了一个数组中。这主要用于
     <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>函数，因为对于接收普通数组类型的
     variadic 函数来说总是会发生这类合并。
    </P
><P
>     例如，假设我们想要写一个接收一个任意类型元素并且返回一个该类型的一维
     数组的函数：

</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* 得到提供的元素，小心它为 NULL 的情况 */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* 只有一个维度 */
    ndims = 1;
    /* 和一个元素 */
    dims[0] = 1;
    /* 且下界是 1 */
    lbs[0] = 1;

    /* 得到该元素类型所需的信息 */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* 现在构建数组 */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}</PRE
><P>
    </P
><P
>     下面的命令在 SQL 中声明函数<CODE
CLASS="FUNCTION"
>make_array</CODE
>：

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;</PRE
><P>
    </P
><P
>     有一种只对 C 语言函数可用的多态变体：它们可以被声明为接受类型为
     <TT
CLASS="LITERAL"
>"any"</TT
>的参数（注意这种类型名必须用双引号引用，因为它也
     是一个 SQL 保留字）。这和<TT
CLASS="TYPE"
>anyelement</TT
>相似，不过它不约束
     不同的<TT
CLASS="LITERAL"
>"any"</TT
>参数为同一种类型，它们也不会帮助确定函数的
     结果类型。C 语言函数也能声明它的第一个参数为
     <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>。这可以匹配一个或者多个任意类型的实参（
     不需要是同一种类型）。这些参数<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>不会</I
></SPAN
>像普通 variadic 函
     数那样被收集到一个数组中，它们将被单独传递给该函数。使用这种特性时，
     必须用<CODE
CLASS="FUNCTION"
>PG_NARGS()</CODE
>宏以及上述方法来判断实参的个数和类
     型。还有，这种函数的用户可能希望在他们的函数调用中使用
     <TT
CLASS="LITERAL"
>VARIADIC</TT
>关键词，以期让该函数将数组元素作为单独的参数
     对待。如果想要这样，在使用<CODE
CLASS="FUNCTION"
>get_fn_expr_variadic</CODE
>检测被
     标记为<TT
CLASS="LITERAL"
>VARIADIC</TT
>的实参之后，函数本身必须实现这种行为。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-TRANSFORM-FUNCTIONS"
>36.9.11. 转换函数</A
></H2
><P
>     一些函数调用可以在规划期间基于该函数的特定的属性被简化。例如，
     <TT
CLASS="LITERAL"
>int4mul(n, 1)</TT
>可以被简化为<TT
CLASS="LITERAL"
>n</TT
>。要定义这种
     与函数相关的优化，可以写一个<I
CLASS="FIRSTTERM"
>转换函数</I
>并且将其 OID
     放在主函数的<TT
CLASS="STRUCTNAME"
>pg_proc</TT
>项的
     <TT
CLASS="STRUCTFIELD"
>protransform</TT
>域中。该转换函数必须具有 SQL 式样
     <TT
CLASS="LITERAL"
>protransform(internal) RETURNS internal</TT
>。其参数（实
     际是<TT
CLASS="TYPE"
>FuncExpr *</TT
>）是一个表示对主函数调用的伪节点。如果
     该转换函数对表达式树的研究证明一个简化的表达式树能够替代所有可能
     的具体调用，则会构造并且返回简化的表达式。否则会返回一个
     <TT
CLASS="LITERAL"
>NULL</TT
>指针（<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>不是</I
></SPAN
>一个 SQL 空值）。
    </P
><P
>     我们不保证<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>在转换函数可以进行简化的
     情况下绝不会调用主函数。要保证简化后的表达式和对主函数的一次实际
     调用是严格等价的。
    </P
><P
>     当前，由于安全性的考虑，这种功能没有在 SQL 层面上显示给用户。因此，
     这种功能实际只用于优化内建函数。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN60670"
>36.9.12. 共享内存和 LWLock</A
></H2
><P
>     外接程序可以在服务器启动时保留 LWLock 和共享内存。
     必须通过在<A
HREF="runtime-config-client.html#GUC-SHARED-PRELOAD-LIBRARIES"
>shared_preload_libraries</A
>
     中
     指定外接程序的共享库来预先载入它。从<CODE
CLASS="FUNCTION"
>_PG_init</CODE
>
     函数中调用
</P><PRE
CLASS="PROGRAMLISTING"
>void RequestAddinShmemSpace(int size)</PRE
><P>
     可以保留共享内存。
    </P
><P
>     通过从<CODE
CLASS="FUNCTION"
>_PG_init</CODE
>中调用
</P><PRE
CLASS="PROGRAMLISTING"
>void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)</PRE
><P>
     可以保留 LWLock。这将确保一个名为<TT
CLASS="LITERAL"
>tranche_name</TT
>
     的 LWLock 数组可用，该数组的长度为<TT
CLASS="LITERAL"
>num_lwlocks</TT
>。
     使用<CODE
CLASS="FUNCTION"
>GetNamedLWLockTranche</CODE
>可得到该数组的指针。
    </P
><P
>     为了避免可能的竞争情况，在连接并且初始化共享内存时，每一个
     后端应该使用 LWLock
     <CODE
CLASS="FUNCTION"
>AddinShmemInitLock</CODE
>，如下所示：
</P><PRE
CLASS="PROGRAMLISTING"
>static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr-&#62;locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="EXTEND-CPP"
>36.9.13. 把 C++ 用于可扩展性</A
></H2
><P
>     尽管<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>后端是用 C 编写的，
     只要遵循下面的指导方针也可以用 C++ 编写扩展：

     <P
></P
></P><UL
><LI
><P
>         所有被后端访问的函数必须对后端呈现一种 C 接口，然后这些 C 函数
         调用 C++ 函数。例如，对后端访问的函数要求<TT
CLASS="LITERAL"
>extern C</TT
>
         链接。对需要在后端和 C++ 代码之间作为指针传递的任何函数也要
         这样做。
       </P
></LI
><LI
><P
>        使用合适的释放方法释放内存。例如，大部分后端内存是通过
        <CODE
CLASS="FUNCTION"
>palloc()</CODE
>分配的，所以应使用<CODE
CLASS="FUNCTION"
>pfree()</CODE
>
        来释放。在这种情况中使用 C++ 的<CODE
CLASS="FUNCTION"
>delete</CODE
>会失败。
       </P
></LI
><LI
><P
>        防止异常传播到 C 代码中（在所有<TT
CLASS="LITERAL"
>extern C</TT
>函数的顶层
        使用一个捕捉全部异常的块）。即使 C++ 代码不会显式地抛出任何
        异常也需要这样做，因为类似内存不足等事件仍会抛出异常。任何异常
        都必须被捕捉并且用适当的错误传回给 C 接口。如果可能，用
        <TT
CLASS="OPTION"
>-fno-exceptions</TT
> 来编译 C++ 以完全消灭异常。在这种
        情况下，你必须在 C++ 代码中检查失败，例如检查<CODE
CLASS="FUNCTION"
>new()</CODE
>
        返回的 NULL。
       </P
></LI
><LI
><P
>        如果从 C++ 代码调用后端函数，确定 C++ 调用栈值包含传统 C 风格
        的数据结构（<ACRONYM
CLASS="ACRONYM"
>POD</ACRONYM
>）。这是必要的，因为后端错误会
        产生远距离的<CODE
CLASS="FUNCTION"
>longjmp()</CODE
>，它无法正确的退回具有非
        POD 对象的 C++ 调用栈。
       </P
></LI
></UL
><P>
    </P
><P
>     总之，最好把 C++ 代码放在与后端交互的<TT
CLASS="LITERAL"
>extern C</TT
>函数之后，
     并且避免异常、内存和调用栈泄露。
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-internal.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xaggr.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>内部函数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>用户定义的聚集</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
