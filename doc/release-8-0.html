<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>版本 8.0.0</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="版本说明"
HREF="release.html"><LINK
REL="PREVIOUS"
TITLE="版本 8.0.1"
HREF="release-8-0-1.html"><LINK
REL="NEXT"
TITLE="版本 7.4.30"
HREF="release-7-4-30.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/release-8.0.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="版本 8.0.1"
HREF="release-8-0-1.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="release.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#38468;&#24405; E. 版本说明</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="版本 7.4.30"
HREF="release-7-4-30.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RELEASE-8-0"
>E.220. 版本 8.0.0</A
></H1
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>发布日期: </B
>2005-01-19</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN167444"
>E.220.1. 概述</A
></H2
><P
>在这个版本中主要的修改是：</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Microsoft Windows 本地服务器</DT
><DD
><P
>这是第一个作为一个服务器在<SPAN
CLASS="TRADEMARK"
>Microsoft Windows</SPAN
>&reg;
上本地运行的<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>版本。
它可以作为一个<SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>服务运行。这个版本支持基于NT的Windows版本，
像<SPAN
CLASS="PRODUCTNAME"
>Windows 2000 SP4</SPAN
>、<SPAN
CLASS="PRODUCTNAME"
>Windows XP</SPAN
>
和<SPAN
CLASS="PRODUCTNAME"
>Windows 2003</SPAN
>。老的版本像<SPAN
CLASS="PRODUCTNAME"
>Windows 95</SPAN
>、
<SPAN
CLASS="PRODUCTNAME"
>Windows 98</SPAN
>和<SPAN
CLASS="PRODUCTNAME"
>Windows ME</SPAN
>是不支持的，
因为这些操作系统没有支持<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的基础结构。
已经创建了一个单独的安装项目简化在<SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>上的安装&mdash;
参阅<A
HREF="http://www.postgresql.org/ftp/win32/"
TARGET="_top"
>http://www.postgresql.org/ftp/win32/</A
>。</P
><P
>尽管测试贯穿了我们的发布周期，但是Windows端口并没有得到多年在生产环境中使用的益处，
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>在Unix平台上所拥有的。
因此它应该和一个新产品一样被看做相同级别的警告。</P
><P
>以前的版本需要Unix仿真工具箱<SPAN
CLASS="PRODUCTNAME"
>Cygwin</SPAN
>，
以便在Windows操作系统上运行服务器。<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
在Windows上支持本地客户端已经很多年了。</P
></DD
><DT
>检查点</DT
><DD
><P
>检查点允许一个事务的特定部分在不影响该事务剩余部分的情况下中止。
以前的版本没有这种能力；没有办法从事务中的语句失败中恢复，
除了中止整个事务。这个特性对于需要从复杂事务中错误恢复的应用程序写是有价值的。</P
></DD
><DT
>时间点恢复</DT
><DD
><P
>在以前的版本中，没有办法从磁盘驱动的失败中恢复，
除了从一个以前的备份中还原或者使用一个备用应用服务器。
时间点恢复允许服务器的继续备份。你可以恢复到失败点或者到以前的一些事物。</P
></DD
><DT
>表空间</DT
><DD
><P
>表空间允许管理员为单独表、索引和数据库的存储选择不同的文件系统。
这提高了性能并且控制了磁盘空间的使用。
以前的版本为这样的任务使用<SPAN
CLASS="APPLICATION"
>initlocation</SPAN
>和人工符号连接管理。</P
></DD
><DT
>改进了缓冲区管理、<TT
CLASS="COMMAND"
>CHECKPOINT</TT
>、<TT
CLASS="COMMAND"
>VACUUM</TT
></DT
><DD
><P
>这个版本有一个更加智能的缓冲区替代策略，这将更好的利用可用的共享缓冲区和提高性能。
vacuum和检查点的性能影响也将减少。</P
></DD
><DT
>更改字段类型</DT
><DD
><P
>字段的数据类型现在可以使用<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>来更改。</P
></DD
><DT
>新增Perl服务器端语言</DT
><DD
><P
>一个新的<SPAN
CLASS="APPLICATION"
>plperl</SPAN
>服务器端语言版本现在支持一个持久的共享存储区域、
触发器、返回记录和记录的数组、和SPI调用访问数据库。</P
></DD
><DT
><TT
CLASS="COMMAND"
>COPY</TT
>支持逗号分隔的值(CSV)</DT
><DD
><P
><TT
CLASS="COMMAND"
>COPY</TT
>现在可以读取和写入逗号分隔的值的文件。
它也能灵活的解释非标准的引用和单独的字符。</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN167504"
>E.220.2. 迁移到版本 8.0.0</A
></H2
><P
>想要从任何以前的版本迁移数据的用户需要使用<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>转储/恢复。</P
><P
>观察下面的不兼容性：</P
><P
></P
><UL
><LI
><P
>在<TT
CLASS="OPTION"
>READ COMMITTED</TT
>序列化模式中，
不稳定的函数现在看到并发事务提交的结果一直到该函数中每个语句的开始，
而不是一直到调用该函数的交互命令的开始。</P
></LI
><LI
><P
>声明<TT
CLASS="OPTION"
>STABLE</TT
>或<TT
CLASS="OPTION"
>IMMUTABLE</TT
>的函数总是使用调用查询的快照，
并且因此看不到在该调用查询开始之后采取的动作的影响，
不管是在它们自己的事务中还是其他事务中。这样一个函数也必须是只读的，
意味着它不能使用任何SQL命令除了<TT
CLASS="COMMAND"
>SELECT</TT
>。</P
></LI
><LI
><P
>非延迟的<TT
CLASS="OPTION"
>AFTER</TT
>触发器现在在触发器查询完成之后立即触发，
而不是基于当前交互命令的完成。这使得触发器查询发生在一个函数内部时有所不同：
触发器在函数继续它的下一个操作之前被调用。</P
></LI
><LI
><P
>服务器配置参数<TT
CLASS="VARNAME"
>virtual_host</TT
>和<TT
CLASS="VARNAME"
>tcpip_socket</TT
>
已经用一个更加一般的参数<TT
CLASS="VARNAME"
>listen_addresses</TT
>替代了。另外，
服务器现在缺省监听<TT
CLASS="LITERAL"
>localhost</TT
>，
消除了在很多情节中对<TT
CLASS="LITERAL"
>-i</TT
>参数开关的需要。</P
></LI
><LI
><P
>服务器配置参数<TT
CLASS="VARNAME"
>SortMem</TT
>和<TT
CLASS="VARNAME"
>VacuumMem</TT
>
已经被重命名为<TT
CLASS="VARNAME"
>work_mem</TT
>和<TT
CLASS="VARNAME"
>maintenance_work_mem</TT
>，
以更好的反映它们的使用。原始的名字在<TT
CLASS="COMMAND"
>SET</TT
>和
<TT
CLASS="COMMAND"
>SHOW</TT
>中仍然支持。</P
></LI
><LI
><P
>服务器配置参数<TT
CLASS="VARNAME"
>log_pid</TT
>、<TT
CLASS="VARNAME"
>log_timestamp</TT
>和
<TT
CLASS="VARNAME"
>log_source_port</TT
>已经用一个更加一般的参数<TT
CLASS="VARNAME"
>log_line_prefix</TT
>替代。</P
></LI
><LI
><P
>服务器配置参数<TT
CLASS="VARNAME"
>syslog</TT
>已经用一个更加合理的<TT
CLASS="VARNAME"
>log_destination</TT
>
变量替代，以控制日志输出目的地。</P
></LI
><LI
><P
>服务器配置参数<TT
CLASS="VARNAME"
>log_statement</TT
>已经被改变了，
所以它可以有选择的只记录数据库修改或数据定义语句。
服务器配置参数<TT
CLASS="VARNAME"
>log_duration</TT
>现在只在<TT
CLASS="VARNAME"
>log_statement</TT
>
输出该查询时输出。</P
></LI
><LI
><P
>服务器配置参数<TT
CLASS="VARNAME"
>max_expr_depth</TT
>已经用<TT
CLASS="VARNAME"
>max_stack_depth</TT
>替换了，
<TT
CLASS="VARNAME"
>max_stack_depth</TT
>测量物理堆栈大小，而不是表达式嵌套深度。
这帮助了防止会话由于递归函数引起堆栈溢出而终止。</P
></LI
><LI
><P
><CODE
CLASS="FUNCTION"
>length()</CODE
>函数不再计数<TT
CLASS="TYPE"
>CHAR(n)</TT
>值中的尾随空白。</P
></LI
><LI
><P
>转换一个整数到<TT
CLASS="TYPE"
>BIT(N)</TT
>，选取该整数的最右边的N位，不是像以前那样选择最左边的N位。</P
></LI
><LI
><P
>更新一个NULL数组值的元素或部分现在产生非空的数组结果，
也就是一个数组只包含分配到的位置。</P
></LI
><LI
><P
>数组输入值的语法检查已经被大大的收紧了。以前允许垃圾在一些奇怪的地方带有奇怪的结果，
现在导致一个错误。空字符串元素值现在必须被写为<TT
CLASS="LITERAL"
>""</TT
>，而不是什么都不写。
还改变了关于围绕着数组元素的空格的行为：现在忽略尾随的空白，
为了对称带有前导的空白（也总是被忽略）。</P
></LI
><LI
><P
>现在检测整数算术操作符的溢出并且报告为一个错误。</P
></LI
><LI
><P
>与单字节<TT
CLASS="TYPE"
>"char"</TT
>数据类型有关的算术操作符已经被删除了。</P
></LI
><LI
><P
><CODE
CLASS="FUNCTION"
>extract()</CODE
>函数（也称为<CODE
CLASS="FUNCTION"
>date_part</CODE
>）
现在为BC日期返回适当的年份，它以前的返回比正确的年份少一。
该函数现在也为千年和世纪返回适当的值。</P
></LI
><LI
><P
><TT
CLASS="TYPE"
>CIDR</TT
>值现在必须有它们的非标记位为0。例如，我们不再允许
<TT
CLASS="LITERAL"
>204.248.199.1/31</TT
>作为<TT
CLASS="TYPE"
>CIDR</TT
>值。
这样的值应该决不被<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>接受并且将是拒绝的。</P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>EXECUTE</TT
>现在返回一个完成标签匹配执行的语句。</P
></LI
><LI
><P
><SPAN
CLASS="APPLICATION"
>psql</SPAN
>的<TT
CLASS="COMMAND"
>\copy</TT
>命令现在读取或写入到查询的
<TT
CLASS="LITERAL"
>stdin/stdout</TT
>，而不是<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的<TT
CLASS="LITERAL"
>stdin/stdout</TT
>。
以前的行为可以通过新的<TT
CLASS="OPTION"
>pstdin</TT
>/<TT
CLASS="OPTION"
>pstdout</TT
>参数访问。</P
></LI
><LI
><P
>JDBC客户端接口已经从内核分配中删除，
现在托管在<A
HREF="http://jdbc.postgresql.org"
TARGET="_top"
>http://jdbc.postgresql.org</A
>。</P
></LI
><LI
><P
>Tcl客户端接口也被删除了。有几个Tcl接口现在托管在
<A
HREF="http://gborg.postgresql.org"
TARGET="_top"
>http://gborg.postgresql.org</A
>。</P
></LI
><LI
><P
>服务器现在使用它自己的时区数据库，而不是操作系统提供的那个。
这将在所有平台上提供一致的行为。在大多数情况下，
这应该在时区行为上没有明显的不同，除了<TT
CLASS="COMMAND"
>SET</TT
>/<TT
CLASS="COMMAND"
>SHOW</TT
> 
<TT
CLASS="VARNAME"
>TimeZone</TT
>使用的时区名可能与您的平台提供的不同。</P
></LI
><LI
><P
><SPAN
CLASS="APPLICATION"
>Configure</SPAN
>的线程选项不再需要用户运行测试或编辑配置文件；
线程选项现在是自动检测的。</P
></LI
><LI
><P
>请注意，表空间已经实现，<SPAN
CLASS="APPLICATION"
>initlocation</SPAN
>已经被删除。</P
></LI
><LI
><P
>用户定义的GiST索引的API已经被改变了。
Union和PickSplit方法现在传递一个指针到一个特殊
<TT
CLASS="STRUCTNAME"
>GistEntryVector</TT
>结构，而不是<TT
CLASS="TYPE"
>bytea</TT
>。</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN167616"
>E.220.3. 废弃的特性</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>行为的一些方面已经被认定为是次优的。
为了向后兼容，这些在8.0中还没有被删除，但是他们已经被认为是废弃的，
并且将在下一个主版本中删除。</P
><P
></P
><UL
><LI
><P
>8.1版本将为间隔删除<CODE
CLASS="FUNCTION"
>to_char()</CODE
>函数。</P
></LI
><LI
><P
>服务器现在警告传递到<TT
CLASS="TYPE"
>oid</TT
>/<TT
CLASS="TYPE"
>float4</TT
>/<TT
CLASS="TYPE"
>float8</TT
>
数据类型的空字符串，但是仍然像以前一样将它们解释为0。
在下一个主版本中，这些数据类型的空字符串将被认为是无效的输入。</P
></LI
><LI
><P
>缺省的，在<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.0和以前的版本中表是带有
<TT
CLASS="TYPE"
>OID</TT
>创建的。在下一个版本中，将<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>不会</I
></SPAN
>是这样情况了：
要创建一个包含<TT
CLASS="TYPE"
>OID</TT
>的表，必须指定<TT
CLASS="OPTION"
>WITH OIDS</TT
>子句，
或者必须设置<TT
CLASS="VARNAME"
>default_with_oids</TT
>配置参数。
如果用户的表需要OID与<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的未来版本兼容，
那么鼓励用户明确的指定<TT
CLASS="OPTION"
>WITH OIDS</TT
>。</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN167639"
>E.220.4. 修改列表</A
></H2
><P
>下面你将看到一个版本8.0和以前的主版本之间的修改的清单。</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN167642"
>E.220.4.1. 性能提升</A
></H3
><P
></P
><UL
><LI
><P
>支持交叉数据类型索引的使用 (Tom)</P
><P
>在这个修改以前，如果数据类型不正好匹配那么许多查询不使用索引。
这次改进使得索引的使用更加直观和一致。</P
></LI
><LI
><P
>新的提高缓存的缓冲区置换策略 (Jan)</P
><P
>以前的版本使用一个最近最少使用的(LRU)缓存在内存中保存最近引用的页面。
LRU算法不考虑一个特定缓存条目被访问的次数，所以大表扫描可能会占用有用的缓存页面。
新的缓存算法使用四个单独的列表追踪最近使用的和最频繁使用的缓存页面，
并且动态的基于工作负载优化他们的替换。这会导致更加有效的使用共享的缓冲区缓存。
在以前测试过共享缓冲区大小的管理员应该用这个新的缓存替换策略重新测试。</P
></LI
><LI
><P
>添加子进程定期的写脏的缓冲区，以减少检查点的写入 (Jan)</P
><P
>在以前的版本中，检查点进程，每几分钟运行一次，
将所有的脏缓冲区写到操作系统的缓冲区缓存，然后刷新所有脏的操作系统缓冲区到磁盘。
这导致磁盘使用的一个定期的高峰经常伤害性能。
新的代码使用一个后端书写器以一个平稳的速度慢慢的磁盘写入，
这样检查点有少得多的脏页面写入到磁盘。另外，新的代码不发出一个全局的
<CODE
CLASS="FUNCTION"
>sync()</CODE
>调用，但是只<CODE
CLASS="FUNCTION"
>fsync()</CODE
>自最后一个检查点以来的文件写入。
这会提高性能并最小化检查点期间的降级。</P
></LI
><LI
><P
>添加延长vacuum以减少性能影响的能力 (Jan)</P
><P
>在忙碌的系统上，<TT
CLASS="COMMAND"
>VACUUM</TT
>执行许多I/O请求，
这会影响其他用户的性能。这个版本允许你放缓<TT
CLASS="COMMAND"
>VACUUM</TT
>
的速度以减少它对其他用户的影响，虽然这样会增加<TT
CLASS="COMMAND"
>VACUUM</TT
>
的总的存续时间。</P
></LI
><LI
><P
>为重复的键提高B-tree索引性能 (Dmitry Tkach, Tom)</P
><P
>当许多重复的值存在于索引当中时，这改进了扫描索引的方式。</P
></LI
><LI
><P
>在规划时使用动态生成的表大小估计 (Tom)</P
><P
>以前规划器估算表的大小使用最后一个<TT
CLASS="COMMAND"
>VACUUM</TT
>或
<TT
CLASS="COMMAND"
>ANALYZE</TT
>看到的值，都是关于物理表大小（页数）和行数。
现在，当前物理表大小从内核中获得，行数是通过表大小乘以最后一个
<TT
CLASS="COMMAND"
>VACUUM</TT
>或<TT
CLASS="COMMAND"
>ANALYZE</TT
>看到的行密度
（每页的行数）估计的。这会产生更加可靠的估计，
以防表大小自最后一个内务工作命令之后发生了重大的变化。</P
></LI
><LI
><P
>用<TT
CLASS="LITERAL"
>OR</TT
>子句提高索引的使用 (Tom)</P
><P
>这允许优化器在语句中使用索引，带有许多过去没有被索引的OR子句。
也可以在第一个字段是指定的、第二个字段是一个<TT
CLASS="LITERAL"
>OR</TT
>
子句的一部分的地方使用多字段索引。</P
></LI
><LI
><P
>提高部分索引子句的匹配 (Tom)</P
><P
>服务器现在在包含复杂<TT
CLASS="OPTION"
>WHERE</TT
>子句的查询中使用部分索引更加智能。</P
></LI
><LI
><P
>提高GEQO优化器的性能 (Tom)</P
><P
>GEQO优化器用来规划包含许多表（缺省的，12个或更多）的查询。
这个版本加速了分析查询的方式，以减少花费在优化上的时间。</P
></LI
><LI
><P
>其他优化器改进</P
><P
>这里没有列出所有小的改进，但是很多特殊情况比以前的版本运行的更好了。</P
></LI
><LI
><P
>提高C函数的查找速度 (Tom)</P
><P
>这个版本为动态加载的C函数使用一个哈希表查找信息。
这提高了它们的速度，所以它们执行起来就和服务器可执行的内建函数一样快。</P
></LI
><LI
><P
>添加类型特定的<TT
CLASS="COMMAND"
>ANALYZE</TT
>统计能力 (Mark Cave-Ayland)</P
><P
>这个特性允许在为非标准的数据类型产生统计信息时有更大的灵活性。</P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>ANALYZE</TT
>现在为表达式索引收集统计信息 (Tom)</P
><P
>表达式索引（也称作功能性索引）允许用户不只是索引字段，还有表达式的结果和函数调用。
用这个版本，优化器可以收集和使用关于表达式索引内容的统计信息。
这可以大大的提高表达式索引相关的查询的规划的质量。</P
></LI
><LI
><P
>为<TT
CLASS="COMMAND"
>ANALYZE</TT
>新增两阶段抽样方法 (Manfred Koizar)</P
><P
>当有效行的密度与表的不同区域的密度非常不同时，这给出了更好的统计。</P
></LI
><LI
><P
>加速<TT
CLASS="COMMAND"
>TRUNCATE</TT
> (Tom)</P
><P
>这找回了一些在7.4中观察到的性能丢失，而仍然保持<TT
CLASS="COMMAND"
>TRUNCATE</TT
>事务安全。</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN167707"
>E.220.4.2. 服务器的变化</A
></H3
><P
></P
><UL
><LI
><P
>添加WAL文件归档和时间点恢复 (Simon Riggs)</P
></LI
><LI
><P
>添加表空间，这样管理员可以控制磁盘布局 (Gavin)</P
></LI
><LI
><P
>添加一个内建的日志循环程序 (Andreas Pflug)</P
><P
>现在可以不用依赖于<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>或外部日志循环程序就可以方便的记录服务器信息了。</P
></LI
><LI
><P
>添加新的只读服务器配置参数以显示服务器兼容的时间设置：
<TT
CLASS="VARNAME"
>block_size</TT
>、<TT
CLASS="VARNAME"
>integer_datetimes</TT
>、<TT
CLASS="VARNAME"
>max_function_args</TT
>、
<TT
CLASS="VARNAME"
>max_identifier_length</TT
>、<TT
CLASS="VARNAME"
>max_index_keys</TT
>  (Joe)</P
></LI
><LI
><P
>让<TT
CLASS="LITERAL"
>sameuser</TT
>、<TT
CLASS="LITERAL"
>samegroup</TT
>和<TT
CLASS="LITERAL"
>all</TT
>
的引用删除<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>中这些术语的特殊含义 (Andrew)</P
></LI
><LI
><P
>在缺省的<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>中为<TT
CLASS="LITERAL"
>localhost</TT
>
使用更加清楚的IPv6名字<TT
CLASS="LITERAL"
>::1/128</TT
> (Andrew)</P
></LI
><LI
><P
>在<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>示例中使用CIDR格式 (Andrew)</P
></LI
><LI
><P
>重命名服务器配置参数<TT
CLASS="VARNAME"
>SortMem</TT
>和<TT
CLASS="VARNAME"
>VacuumMem</TT
>
为<TT
CLASS="VARNAME"
>work_mem</TT
>和<TT
CLASS="VARNAME"
>maintenance_work_mem</TT
>（仍然支持老的名字） (Tom)</P
><P
>这个修改是用来弄清楚批量操作，比如用<TT
CLASS="VARNAME"
>maintenance_work_mem</TT
>创建的索引和外键，
而<TT
CLASS="VARNAME"
>work_mem</TT
>是在查询执行期间使用的工作空间。</P
></LI
><LI
><P
>允许使用服务器配置<TT
CLASS="VARNAME"
>log_disconnections</TT
>记录会话断开 (Andrew)</P
></LI
><LI
><P
>添加新的服务器配置参数<TT
CLASS="VARNAME"
>log_line_prefix</TT
>，
以允许控制在每个日志行里发出的信息 (Andrew)</P
><P
>可用的信息包括用户名、数据库名、远程IP地址和会话启动时间。</P
></LI
><LI
><P
>删除服务器配置参数<TT
CLASS="VARNAME"
>log_pid</TT
>、<TT
CLASS="VARNAME"
>log_timestamp</TT
>、
<TT
CLASS="VARNAME"
>log_source_port</TT
>；功能性上被<TT
CLASS="VARNAME"
>log_line_prefix</TT
>取代 (Andrew)</P
></LI
><LI
><P
>用一个统一的<TT
CLASS="VARNAME"
>listen_addresses</TT
>参数替代<TT
CLASS="VARNAME"
>virtual_host</TT
>
和<TT
CLASS="VARNAME"
>tcpip_socket</TT
>参数 (Andrew, Tom)</P
><P
><TT
CLASS="VARNAME"
>virtual_host</TT
>只能指定要监听的单个IP地址。
<TT
CLASS="VARNAME"
>listen_addresses</TT
>允许指定多个地址。</P
></LI
><LI
><P
>默认监听localhost，减少了在很多情况下对<TT
CLASS="OPTION"
>-i</TT
>主进程开关的需要 (Andrew)</P
><P
>监听localhost (<TT
CLASS="LITERAL"
>127.0.0.1</TT
>)不会打开新的安全漏洞，
但是允许像Windows和JDBC那样配置，不支持本地套接字，不用特殊的调整就能工作。</P
></LI
><LI
><P
>删除<TT
CLASS="VARNAME"
>syslog</TT
>服务器配置参数，并且添加更多逻辑的<TT
CLASS="VARNAME"
>log_destination</TT
>
变量来控制日志输出位置 (Magnus)</P
></LI
><LI
><P
>修改服务器配置参数<TT
CLASS="VARNAME"
>log_statement</TT
>接受值<TT
CLASS="VARNAME"
>all</TT
>、
<TT
CLASS="VARNAME"
>mod</TT
>、<TT
CLASS="VARNAME"
>ddl</TT
>或<TT
CLASS="VARNAME"
>none</TT
>，以便选择记录哪条查询 (Bruce)</P
><P
>这允许管理员只记录数据定义修改或只记录数据修改语句。</P
></LI
><LI
><P
>一些日志相关的配置参数以前可以通过普通用户调整，但是只能是在<SPAN
CLASS="QUOTE"
>"更详细的"</SPAN
>方向。
现在对待它们更加严格了：只有超级用户可以设置它们。不过，
超级用户可以使用<TT
CLASS="COMMAND"
>ALTER USER</TT
>为非超级用户提供这些值的每用户设置。
还有，现在超级用户可以通过<TT
CLASS="LITERAL"
>PGOPTIONS</TT
>设置仅超级用户的配置参数值了。</P
></LI
><LI
><P
>允许配置文件放在数据目录的外面 (mlw)</P
><P
>缺省的，配置文件保存在集群的顶级目录中。有了这个添加，
配置文件可以放置在该数据目录的外面，宽松了管理。</P
></LI
><LI
><P
>只有在第一次执行常量可以用于统计时计划预备查询 (Oliver Jowett)</P
><P
>预备语句规划查询一次执行多次。虽然预备查询避免了每次使用时重新规划的开支，
但是规划的质量不知道在该查询中要使用的准确参数。在这个版本中，
未命名的预备语句的规划被推迟直到第一次执行，执行的实际参数值用作优化提示。
这允许使用行外传递参数，而不会导致性能损失。</P
></LI
><LI
><P
>允许<TT
CLASS="COMMAND"
>DECLARE CURSOR</TT
>接受参数 (Oliver Jowett)</P
><P
>在<CODE
CLASS="FUNCTION"
>Parse</CODE
>消息中用参数发出<TT
CLASS="COMMAND"
>DECLARE CURSOR</TT
>现在是有用的。
在<CODE
CLASS="FUNCTION"
>Bind</CODE
>时发送参数值将被取代为游标查询的执行。</P
></LI
><LI
><P
>修复<TT
CLASS="TYPE"
>inet</TT
>和<TT
CLASS="TYPE"
>cidr</TT
>数据类型的哈希连接和聚合 (Tom)</P
><P
>版本7.4正确的处理了混合<TT
CLASS="TYPE"
>inet</TT
>和<TT
CLASS="TYPE"
>cidr</TT
>值的哈希。
（这个bug在以前的版本中不存在，因为他们不会尝试哈希任何一个数据类型。）</P
></LI
><LI
><P
>让<TT
CLASS="VARNAME"
>log_duration</TT
>只在<TT
CLASS="VARNAME"
>log_statement</TT
>输出查询时输出 (Ed L.)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN167815"
>E.220.4.3. 查询的变化</A
></H3
><P
></P
><UL
><LI
><P
>添加了保存点（嵌套的事务） (Alvaro)</P
></LI
><LI
><P
>现在接受不支持的隔离级别了并且提升为最近支持的级别 (Peter)</P
><P
>SQL规范声明如果一个数据库不支持一个特定的隔离级别，它应该使用下一个更加限制的级别。
这个修改符合那个建议。</P
></LI
><LI
><P
>允许<TT
CLASS="COMMAND"
>BEGIN WORK</TT
>像<TT
CLASS="COMMAND"
>START TRANSACTION</TT
>
那样指定事务隔离级别 (Bruce)</P
></LI
><LI
><P
>修复规则产生的查询类型和原始提交的查询类型不同时的表的权限检查 (Tom)</P
></LI
><LI
><P
>实现美元的引用以简化单引号的使用 (Andrew, Tom, David Fetter)</P
><P
>在以前的版本中，因为单引号必须被用来引用一个函数体，
在函数文本的内部使用单引号需要使用两个单引号或其他易于出错的符号。
在这个版本中，我们添加了使用“美元引用”来引用一个文本块的能力。
在不同的嵌套界别使用不同的引用分隔符的能力大大的简化了恰当引用的工作，
尤其是在复杂的函数中。美元引用可以用在任何需要引用文本的地方。</P
></LI
><LI
><P
>让<TT
CLASS="LITERAL"
>CASE val WHEN compval1 THEN ...</TT
>只评估<TT
CLASS="LITERAL"
>val</TT
>一次 (Tom)</P
><P
><TT
CLASS="OPTION"
>CASE</TT
>不再多次评估测试的表达式。这在表达式是复杂的或不稳定时有益。</P
></LI
><LI
><P
>在计算一个聚合查询的目标列表之前测试<TT
CLASS="OPTION"
>HAVING</TT
> (Tom)</P
><P
>修复不正确的失败案例，如<TT
CLASS="LITERAL"
>SELECT SUM(win)/SUM(lose) ... GROUP BY ... HAVING SUM(lose) &gt; 0</TT
>。
这应该能工作但是以前可能会有被零除而失败。</P
></LI
><LI
><P
>用<TT
CLASS="VARNAME"
>max_stack_depth</TT
>参数替换<TT
CLASS="VARNAME"
>max_expr_depth</TT
>参数，
以堆栈大小的千字节测量 (Tom)</P
><P
>这给出了一个相当严密的防御，针对由于转义递归函数引起的崩溃。
代替测量表达式嵌套的深度，我们现在直接测量执行堆栈的大小。</P
></LI
><LI
><P
>允许任意行的表达式 (Tom)</P
><P
>这个版本允许SQL表达式包含任意的符合类型，也就是说，行值。
也允许函数更容易的接受行作为参数和返回行值。</P
></LI
><LI
><P
>允许<TT
CLASS="OPTION"
>LIKE</TT
>/<TT
CLASS="OPTION"
>ILIKE</TT
>在行和子查询比较中用作操作符 (Fabien Coelho)</P
></LI
><LI
><P
>避免特定于语言环境的情况下在标识符和关键字中转换基本的ASCII字符 (Tom)</P
><P
>这解决了单词包含<TT
CLASS="LITERAL"
>I</TT
>和<TT
CLASS="LITERAL"
>i</TT
>的识别编码的<SPAN
CLASS="QUOTE"
>"Turkish 问题"</SPAN
>。
在7位ASCII设置之外折叠字符仍然是环境敏感的。</P
></LI
><LI
><P
>改进语法错误报告 (Fabien, Tom)</P
><P
>语法错误报告比以前更加有用。</P
></LI
><LI
><P
>修改<TT
CLASS="COMMAND"
>EXECUTE</TT
>，返回一个完成标签匹配执行语句 (Kris Jurka)</P
><P
>以前的版本为任何<TT
CLASS="COMMAND"
>EXECUTE</TT
>调用返回一个<TT
CLASS="COMMAND"
>EXECUTE</TT
>标签。
在这个版本中，返回的标签将反应执行的命令。</P
></LI
><LI
><P
>避免在规则列表中发出<TT
CLASS="OPTION"
>NATURAL CROSS JOIN</TT
> (Tom)</P
><P
>这样一个条款在逻辑上说不通，但是在某些情况下该规则反编译以前生成的这种语法。</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN167874"
>E.220.4.4. 对象操作的变化</A
></H3
><P
></P
><UL
><LI
><P
>为cast、转换、语言、操作符类和大对象添加<TT
CLASS="COMMAND"
>COMMENT ON</TT
> (Christopher)</P
></LI
><LI
><P
>添加新的服务器配置参数<TT
CLASS="VARNAME"
>default_with_oids</TT
>，
控制表缺省是不是带有<TT
CLASS="TYPE"
>OID</TT
>创建 (Neil)</P
><P
>这允许管理员控制<TT
CLASS="COMMAND"
>CREATE TABLE</TT
>命令缺省是否带有<TT
CLASS="TYPE"
>OID</TT
>
字段创建表。（注意：目前<TT
CLASS="VARNAME"
>default_with_oids</TT
>的出厂默认设置是<TT
CLASS="LITERAL"
>TRUE</TT
>，
但是该缺省将在将来的版本中变成<TT
CLASS="LITERAL"
>FALSE</TT
>。）</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>WITH</TT
> / <TT
CLASS="OPTION"
>WITHOUT OIDS</TT
>子句到<TT
CLASS="COMMAND"
>CREATE TABLE AS</TT
> (Neil)</P
></LI
><LI
><P
>允许<TT
CLASS="COMMAND"
>ALTER TABLE DROP COLUMN</TT
>删除<TT
CLASS="TYPE"
>OID</TT
>字段
（<TT
CLASS="COMMAND"
>ALTER TABLE SET WITHOUT OIDS</TT
>仍然工作） (Tom)</P
></LI
><LI
><P
>允许复合类型作为表字段 (Tom)</P
></LI
><LI
><P
>允许<TT
CLASS="COMMAND"
>ALTER ... ADD COLUMN</TT
>带有缺省和<TT
CLASS="OPTION"
>NOT NULL</TT
>约束；
在每个SQL规范上工作 (Rod)</P
><P
><TT
CLASS="OPTION"
>ADD COLUMN</TT
>创建一个最初不是填充为NULL的字段现在是可能的了，
但是会带有一个指定的缺省值。</P
></LI
><LI
><P
>添加<TT
CLASS="COMMAND"
>ALTER COLUMN TYPE</TT
>改变字段的类型 (Rod)</P
><P
>现在不用删除然后重新添加该字段来修改一个字段的数据类型是可能的了。</P
></LI
><LI
><P
>允许多个<TT
CLASS="COMMAND"
>ALTER</TT
>在一个<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>命令中动作 (Rod)</P
><P
>这对于重写表的<TT
CLASS="COMMAND"
>ALTER</TT
>命令尤其有用（包括<TT
CLASS="OPTION"
>ALTER COLUMN TYPE</TT
>
和带有一个缺省的<TT
CLASS="OPTION"
>ADD COLUMN</TT
> ）。通过一起分组<TT
CLASS="COMMAND"
>ALTER</TT
>命令，
该表只需要重写一次。</P
></LI
><LI
><P
>允许<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>添加<TT
CLASS="TYPE"
>SERIAL</TT
>字段 (Tom)</P
><P
>这来自为新的字段指定缺省的新能力。</P
></LI
><LI
><P
>允许修改聚合、转换、数据库、函数、操作符、操作符类、模式、类型和表空间的所有者
(Christopher, Euler Taveira de Oliveira)</P
><P
>以前这些需要直接修改系统表。</P
></LI
><LI
><P
>允许临时对象的创建局限于<TT
CLASS="OPTION"
>SECURITY DEFINER</TT
>函数 (Sean Chittenden)</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>ALTER TABLE ... SET WITHOUT CLUSTER</TT
> (Christopher)</P
><P
>在该版本以前，没有方法清空一个自动群集的规范，除了修改系统表。</P
></LI
><LI
><P
>约束/索引/<TT
CLASS="TYPE"
>SERIAL</TT
>名字现在是<TT
CLASS="REPLACEABLE"
><I
>table_column_type</I
></TT
>，
附加上编号以保证在模式中的唯一性 (Tom)</P
><P
>SQL规范声明这样的名字应该在一个模式中唯一。</P
></LI
><LI
><P
>添加<CODE
CLASS="FUNCTION"
>pg_get_serial_sequence()</CODE
>来返回一个<TT
CLASS="TYPE"
>SERIAL</TT
>
字段的序列名 (Christopher)</P
><P
>这允许自动化的脚本可靠的找到<TT
CLASS="TYPE"
>SERIAL</TT
>序列名。</P
></LI
><LI
><P
>当主键/外键数据类型不匹配需要昂贵的查找时警告</P
></LI
><LI
><P
>新增<TT
CLASS="COMMAND"
>ALTER INDEX</TT
>命令允许删除表空间之间的索引 (Gavin)</P
></LI
><LI
><P
>让<TT
CLASS="COMMAND"
>ALTER TABLE OWNER</TT
>修改依赖的序列所有权 (Alvaro)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN167955"
>E.220.4.5. 工具命令的变化</A
></H3
><P
></P
><UL
><LI
><P
>允许<TT
CLASS="COMMAND"
>CREATE SCHEMA</TT
>创建触发器、索引和序列 (Neil)</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>ALSO</TT
>关键字到<TT
CLASS="COMMAND"
>CREATE RULE</TT
> (Fabien Coelho)</P
><P
>这允许<TT
CLASS="OPTION"
>ALSO</TT
>被添加到规则创建，与<TT
CLASS="OPTION"
>INSTEAD</TT
>规则对比。</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>NOWAIT</TT
>选项到<TT
CLASS="COMMAND"
>LOCK</TT
> (Tatsuo)</P
><P
>这允许<TT
CLASS="COMMAND"
>LOCK</TT
>命令在它必须等待请求的锁时失败。</P
></LI
><LI
><P
>允许<TT
CLASS="COMMAND"
>COPY</TT
>读写逗号分隔值(CSV)的文件 (Andrew, Bruce)</P
></LI
><LI
><P
>如果<TT
CLASS="COMMAND"
>COPY</TT
>分隔符和NULL字符串冲突则产生错误 (Bruce)</P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>GRANT</TT
>/<TT
CLASS="COMMAND"
>REVOKE</TT
>行为更加符合SQL规范</P
></LI
><LI
><P
>避免<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>和<TT
CLASS="COMMAND"
>CHECKPOINT</TT
>
之间的锁冲突 (Tom)</P
><P
>在7.3和7.4中，一个长期运行的B-tree索引建立会阻止并发的<TT
CLASS="COMMAND"
>CHECKPOINT</TT
>完成，
因此导致WAL膨胀，因为WAL日志不能重复利用。</P
></LI
><LI
><P
>数据库范围的<TT
CLASS="COMMAND"
>ANALYZE</TT
>不在表上持有锁 (Tom)</P
><P
>这减少了其他后端想要在表上的排他锁时死锁的可能性。要获取这个修改的益处，
不要在一个事务块(<TT
CLASS="COMMAND"
>BEGIN</TT
> 块)中执行数据库范围的<TT
CLASS="COMMAND"
>ANALYZE</TT
>；
必须能够为每个表提交和启动一个新事务。</P
></LI
><LI
><P
><TT
CLASS="COMMAND"
>REINDEX</TT
>不再完全锁住索引的父表</P
><P
>索引本身仍然是完全锁住的，但是该表的读者可以继续，如果他们不使用被重建的特定索引。</P
></LI
><LI
><P
>当一个用户重命名了时，擦除MD5用户口令 (Bruce)</P
><P
>当通过MD5解密口令时，<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
使用用户的名字作为盐。当改变了一个用户的名字时，盐将不再匹配存储的MD5口令，
所以存储的口令变得无用了。在这个版本中生成一个通知并且清除口令。
如果该用户能够使用一个口令登录，那么一个新的口令必须被分配。</P
></LI
><LI
><P
>为Windows新建<SPAN
CLASS="APPLICATION"
>pg_ctl</SPAN
> <TT
CLASS="OPTION"
>kill</TT
>选项 (Andrew)</P
><P
>Windows没有<TT
CLASS="LITERAL"
>kill</TT
>命令发送信号到后端，所以这个能力添加到了<SPAN
CLASS="APPLICATION"
>pg_ctl</SPAN
>。</P
></LI
><LI
><P
>信息模式改善</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>--pwfile</TT
>选项到<SPAN
CLASS="APPLICATION"
>initdb</SPAN
>，
这样初始口令可以通过GUI工具设置 (Magnus)</P
></LI
><LI
><P
>检测<SPAN
CLASS="APPLICATION"
>initdb</SPAN
>中的本地环境/编码错误匹配 (Peter)</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>register</TT
>命令到<SPAN
CLASS="APPLICATION"
>pg_ctl</SPAN
>，
以注册Windows操作系统服务 (Dave Page)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN168024"
>E.220.4.6. 数据类型和函数的变化</A
></H3
><P
></P
><UL
><LI
><P
>对复合类型（行类型）更加完整的支持 (Tom)</P
><P
>复合值可以用在以前只能是标量值的许多地方。</P
></LI
><LI
><P
>作为错误拒绝非矩形的数组值 (Joe)</P
><P
>以前，<CODE
CLASS="FUNCTION"
>array_in</CODE
>将默默地建立一个令人惊讶的结果。</P
></LI
><LI
><P
>现在检测到了整数算术运算符的溢出 (Tom)</P
></LI
><LI
><P
>与单字节<TT
CLASS="TYPE"
>"char"</TT
>数据类型相关的算术操作符已经删除了。</P
><P
>以前，解析器将在许多情况下选择这些操作符，而一个<SPAN
CLASS="QUOTE"
>"不能选择一个操作符"</SPAN
>
错误应该更加合适，比如<TT
CLASS="LITERAL"
>null * null</TT
>。如果你真的想要在一个<TT
CLASS="TYPE"
>"char"</TT
>
字段上做算术，你可以将它明确的转换为整型。</P
></LI
><LI
><P
>数组输入值的语法检查明显的严格了 (Joe)</P
><P
>以前允许在旧的位置的带有旧的结果的垃圾现在导致一个<TT
CLASS="LITERAL"
>ERROR</TT
>，
例如，紧跟着右括号后面的非空白。</P
></LI
><LI
><P
>空字符串数组元素值现在必须写为<TT
CLASS="LITERAL"
>""</TT
>，而不是什么都不写 (Joe)</P
><P
>以前，两种书写空字符串元素值的方法都是允许的，但是现在要求用带有引号的空字符串。
在一些未来的版本中，什么都不出现的情况可以考虑为一个NULL元素值。</P
></LI
><LI
><P
>现在忽略数组元素的尾随空白 (Joe)</P
><P
>以前忽略前导的空白，但是元素值和分隔符或右括号之间的尾随的空白是有效的。
现在尾随的空白也忽略了。</P
></LI
><LI
><P
>当下界不是1时，用明确的数组界限发出数组值 (Joe)</P
></LI
><LI
><P
>作为日期字符串接受<TT
CLASS="LITERAL"
>YYYY-monthname-DD</TT
> (Tom)</P
></LI
><LI
><P
>让<CODE
CLASS="FUNCTION"
>netmask</CODE
>和<CODE
CLASS="FUNCTION"
>hostmask</CODE
>函数返回最大长度标记的长度 (Tom)</P
></LI
><LI
><P
>修改阶乘函数以返回<TT
CLASS="TYPE"
>numeric</TT
> (Gavin)</P
><P
>返回的<TT
CLASS="TYPE"
>numeric</TT
>允许阶乘函数为更大范围的输入值工作。</P
></LI
><LI
><P
><CODE
CLASS="FUNCTION"
>to_char</CODE
>/<CODE
CLASS="FUNCTION"
>to_date()</CODE
>日期转换的改善 (Kurt Roeckx, Fabien Coelho)</P
></LI
><LI
><P
>让<CODE
CLASS="FUNCTION"
>length()</CODE
>忽视<TT
CLASS="TYPE"
>CHAR(n)</TT
>中尾随的空白 (Gavin)</P
><P
>这个修改是为了提高一致性：<TT
CLASS="TYPE"
>CHAR(n)</TT
>数据中尾随的空白在语义上是无关紧要的，
所以它们不应该被<CODE
CLASS="FUNCTION"
>length()</CODE
>计数。</P
></LI
><LI
><P
>警告空字符串被传递到<TT
CLASS="TYPE"
>OID</TT
>/<TT
CLASS="TYPE"
>float4</TT
>/<TT
CLASS="TYPE"
>float8</TT
>数据类型 (Neil)</P
><P
>8.1中将抛出一个错误。</P
></LI
><LI
><P
>允许前导或尾随的空白在<TT
CLASS="TYPE"
>int2</TT
>/<TT
CLASS="TYPE"
>int4</TT
>/<TT
CLASS="TYPE"
>int8</TT
>/<TT
CLASS="TYPE"
>float4</TT
>/<TT
CLASS="TYPE"
>float8</TT
>
输入例程中 (Neil)</P
></LI
><LI
><P
>在<TT
CLASS="TYPE"
>float4</TT
>/<TT
CLASS="TYPE"
>float8</TT
>中更好的支持IEEE <TT
CLASS="LITERAL"
>Infinity</TT
>
和<TT
CLASS="LITERAL"
>NaN</TT
>值 (Neil)</P
><P
>这些应该在所有支持IEEE兼容浮点运算的平台上工作。</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>week</TT
>选项到<CODE
CLASS="FUNCTION"
>date_trunc()</CODE
> (Robert Creager)</P
></LI
><LI
><P
>为<TT
CLASS="LITERAL"
>1 BC</TT
>修复<CODE
CLASS="FUNCTION"
>to_char</CODE
>（以前它返回<TT
CLASS="LITERAL"
>1 AD</TT
>）(Bruce) </P
></LI
><LI
><P
>为BC日期修复<CODE
CLASS="FUNCTION"
>date_part(year)</CODE
>（以前它返回的比正确的年份少1） (Bruce)</P
></LI
><LI
><P
>修复<CODE
CLASS="FUNCTION"
>date_part()</CODE
>以返回正确的千年和世纪 (Fabien Coelho)</P
><P
>在以前的版本中，与标准比较计算，世纪和千年的结果有一个错误的数值，
并且是以错误的年份开始的。</P
></LI
><LI
><P
>为了符合标准，添加<CODE
CLASS="FUNCTION"
>ceiling()</CODE
>作为<CODE
CLASS="FUNCTION"
>ceil()</CODE
>的一个别名，
<CODE
CLASS="FUNCTION"
>power()</CODE
>作为<CODE
CLASS="FUNCTION"
>pow()</CODE
>的一个别名 (Neil)</P
></LI
><LI
><P
>修改<CODE
CLASS="FUNCTION"
>ln()</CODE
>、<CODE
CLASS="FUNCTION"
>log()</CODE
>、<CODE
CLASS="FUNCTION"
>power()</CODE
>和<CODE
CLASS="FUNCTION"
>sqrt()</CODE
>，
就像SQL:2003中指定的那样，为确定的错误条件发出正确的<TT
CLASS="LITERAL"
>SQLSTATE</TT
>错误代码 (Neil)</P
></LI
><LI
><P
>像SQL:2003中定义的那样添加<CODE
CLASS="FUNCTION"
>width_bucket()</CODE
>函数 (Neil)</P
></LI
><LI
><P
>添加<CODE
CLASS="FUNCTION"
>generate_series()</CODE
>函数简化数字集的工作 (Joe)</P
></LI
><LI
><P
>修复<CODE
CLASS="FUNCTION"
>upper/lower/initcap()</CODE
>函数以与多字节编码一起工作 (Tom)</P
></LI
><LI
><P
>添加布尔和按位整数<TT
CLASS="OPTION"
>AND</TT
>/<TT
CLASS="OPTION"
>OR</TT
>聚合 (Fabien Coelho)</P
></LI
><LI
><P
>新增会话信息函数，为客户端和服务器返回网络地址 (Sean Chittenden)</P
></LI
><LI
><P
>添加函数确定闭合路径的区域 (Sean Chittenden)</P
></LI
><LI
><P
>添加函数发送取消请求到其他后端 (Magnus)</P
></LI
><LI
><P
>添加<TT
CLASS="TYPE"
>datetime</TT
>加<TT
CLASS="TYPE"
>datetime</TT
>操作符 (Tom)</P
><P
>相反的顺序，<TT
CLASS="TYPE"
>datetime</TT
>加<TT
CLASS="TYPE"
>interval</TT
>，早已支持了，
但是SQL标准两种都需要。</P
></LI
><LI
><P
>转换一个整数到<TT
CLASS="TYPE"
>BIT(N)</TT
>，选取该整数的最右侧的N位 (Tom)</P
><P
>在以前的版本中，选择最左侧的N位，但是这被认为是没有帮助的，
更不用说与从位转换到整数的不一致。</P
></LI
><LI
><P
>需要<TT
CLASS="TYPE"
>CIDR</TT
>值让所有非标记的位为0 (Kevin Brintnall)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN168161"
>E.220.4.7. 服务器端语言的变化</A
></H3
><P
></P
><UL
><LI
><P
>在<TT
CLASS="LITERAL"
>READ COMMITTED</TT
>序列化模式中，
不稳定的函数现在看到并发事务提交的结果直到该函数中每个语句的开始，
而不是直到调用该函数的交互命令的开始。</P
></LI
><LI
><P
>声明为<TT
CLASS="LITERAL"
>STABLE</TT
>或<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>的函数总是使用调用查询的快照，
并且因此不能看到调用查询开始之后采取的动作的影响，
不管是在它们自己的事务中还是在其他事务中。这样一个函数必须也是只读的，
意味着它不能使用任何SQL命令，除了<TT
CLASS="COMMAND"
>SELECT</TT
>。
声明一个函数<TT
CLASS="LITERAL"
>STABLE</TT
>或<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>而不是<TT
CLASS="LITERAL"
>VOLATILE</TT
>
有相当大的性能增益。</P
></LI
><LI
><P
>非延迟的<TT
CLASS="OPTION"
>AFTER</TT
>触发器现在在触发器查询完成之后立即触发，
而不是根据当前交互命令的完成。这在触发查询发生在一个函数中时有所不同：
触发器在该函数进行它的下一个操作之前被调用。例如，
如果一个函数插入了一个新行到一个表中，任何非延迟的外键检查在处理该函数之前发生。</P
></LI
><LI
><P
>允许函数参数用名字声明 (Dennis Bj&ouml;rklund)</P
><P
>这允许更好的记录函数。名字实际上是否做任何事情依赖于使用的特定的函数语言。</P
></LI
><LI
><P
>允许PL/pgSQL参数名在函数中引用 (Dennis Bj&ouml;rklund)</P
><P
>这基本上为每个命名的参数都创建了一个自动的别名。</P
></LI
><LI
><P
>在创建时做最少的PL/pgSQL函数的语法检查 (Tom)</P
><P
>这允许我们快速的捕捉简单的语法错误。</P
></LI
><LI
><P
>在PL/pgSQL中更加支持复合类型（行和记录变量）</P
><P
>例如，现在可以将行类型变量作为单个变量传递到另一个函数了。</P
></LI
><LI
><P
>PL/pgSQL变量的缺省变量现在可以引用以前声明的变量。</P
></LI
><LI
><P
>为循环改善PL/pgSQL的解析 (Tom)</P
><P
>解析现在是通过<TT
CLASS="LITERAL"
>".."</TT
>的存在来驱动的，而不是<TT
CLASS="OPTION"
>FOR</TT
>变量的数据类型。
这对于正确的函数来说没什么差别，但是当有一个错误时，会导致更容易理解的错误消息。</P
></LI
><LI
><P
>主要检修了PL/Perl服务器端语言 (Command Prompt, Andrew Dunstan)</P
></LI
><LI
><P
>在PL/Tcl中，SPI命令现在在子事务中运行。如果发生了一个错误，
该子事务被清理并且该错误被作为一个普通Tcl错误报告，
可以使用<TT
CLASS="LITERAL"
>catch</TT
>捕获。以前，捕获这样的错误是没有可能的。</P
></LI
><LI
><P
>在PL/pgSQL中接受<TT
CLASS="COMMAND"
>ELSEIF</TT
> (Neil)</P
><P
>以前PL/pgSQL只允许<TT
CLASS="COMMAND"
>ELSIF</TT
>，但是许多人习惯拼写<TT
CLASS="COMMAND"
>ELSEIF</TT
>关键字。</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN168208"
>E.220.4.8. <SPAN
CLASS="APPLICATION"
>psql</SPAN
> 的变化</A
></H3
><P
></P
><UL
><LI
><P
>改善<SPAN
CLASS="APPLICATION"
>psql</SPAN
>关于数据库对象的信息显示 (Christopher)</P
></LI
><LI
><P
>允许<SPAN
CLASS="APPLICATION"
>psql</SPAN
>在<TT
CLASS="COMMAND"
>\du</TT
>和<TT
CLASS="COMMAND"
>\dg</TT
>
中显示组成员 (Markus Bertheau)</P
></LI
><LI
><P
>阻止<SPAN
CLASS="APPLICATION"
>psql</SPAN
> <TT
CLASS="COMMAND"
>\dn</TT
>显示临时模式 (Bruce)</P
></LI
><LI
><P
>允许<SPAN
CLASS="APPLICATION"
>psql</SPAN
>为文件名处理波浪符用户扩展 (Zach Irmen)</P
></LI
><LI
><P
>允许<SPAN
CLASS="APPLICATION"
>psql</SPAN
>显示提示，包括颜色，通过<SPAN
CLASS="APPLICATION"
>readline</SPAN
> (Reece Hart, Chet Ramey)</P
></LI
><LI
><P
>让<SPAN
CLASS="APPLICATION"
>psql</SPAN
> <TT
CLASS="COMMAND"
>\copy</TT
>完全匹配<TT
CLASS="COMMAND"
>COPY</TT
>命令语法 (Tom)</P
></LI
><LI
><P
>显示语法错误的位置 (Fabien Coelho, Tom)</P
></LI
><LI
><P
>添加<TT
CLASS="COMMAND"
>CLUSTER</TT
>信息到<SPAN
CLASS="APPLICATION"
>psql</SPAN
> <TT
CLASS="COMMAND"
>\d</TT
>显示 (Bruce)</P
></LI
><LI
><P
>修改<SPAN
CLASS="APPLICATION"
>psql</SPAN
> <TT
CLASS="COMMAND"
>\copy stdin/stdout</TT
>，
以便从命令输入/输出中读取 (Bruce)</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>pstdin</TT
>/<TT
CLASS="OPTION"
>pstdout</TT
>，以便从<SPAN
CLASS="APPLICATION"
>psql</SPAN
>
的<TT
CLASS="LITERAL"
>stdin</TT
>/<TT
CLASS="LITERAL"
>stdout</TT
>读取 (Mark Feit)</P
></LI
><LI
><P
>添加全局<SPAN
CLASS="APPLICATION"
>psql</SPAN
>配置文件，<TT
CLASS="FILENAME"
>psqlrc.sample</TT
> (Bruce)</P
><P
>这允许一个可以存储全局<SPAN
CLASS="APPLICATION"
>psql</SPAN
>启动命令的中心文档。</P
></LI
><LI
><P
>让<SPAN
CLASS="APPLICATION"
>psql</SPAN
> <TT
CLASS="COMMAND"
>\d+</TT
>表明表是否有一个<TT
CLASS="TYPE"
>OID</TT
>字段 (Neil)</P
></LI
><LI
><P
>在Windows上，当读取文件时使用二进制模式，这样control-Z不会被看做文件的结尾。</P
></LI
><LI
><P
>让<TT
CLASS="COMMAND"
>\dn+</TT
>显示模式的权限和描述 (Dennis Bj&ouml;rklund)</P
></LI
><LI
><P
>提高选项卡完成支持 (Stefan Kaltenbrunn, Greg Sabino Mullane)</P
></LI
><LI
><P
>允许布尔设置使用大写或小写 (Michael Paesold)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN168274"
>E.220.4.9. <SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
> 的变化</A
></H3
><P
></P
><UL
><LI
><P
>使用依赖关系信息提高<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>的可靠性 (Tom)</P
><P
>这应该解决了相关的对象有时会以错误的顺序转储的长期存在的问题。</P
></LI
><LI
><P
>如果可能，让<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>以字母顺序输出对象 (Tom)</P
><P
>这将使得它更容易的识别出转储文件间的变化。</P
></LI
><LI
><P
>允许<SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
>忽略一些SQL错误 (Fabien Coelho)</P
><P
>这使得<SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
>的行为类似于输出<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>
输出脚本到<SPAN
CLASS="APPLICATION"
>psql</SPAN
>的结果。在大多数情况下，
忽略错误和向前进行是最有用的事情。
还添加了一个pg_restore选项给老的行为在遇到错误时退出。</P
></LI
><LI
><P
><SPAN
CLASS="APPLICATION"
>pg_restore</SPAN
> <TT
CLASS="OPTION"
>-l</TT
>显示现在包括了对象的模式名</P
></LI
><LI
><P
>在<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>文本输出中新增开始/结束标记(Bruce)</P
></LI
><LI
><P
>在详细模式为<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>/<SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>添加开始/结束时间 (Bruce)</P
></LI
><LI
><P
>在<SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>中允许大部分<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>选项 (Christopher)</P
></LI
><LI
><P
>让<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>默认使用<TT
CLASS="COMMAND"
>ALTER OWNER</TT
>而不是
<TT
CLASS="COMMAND"
>SET SESSION AUTHORIZATION</TT
> (Christopher)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN168313"
>E.220.4.10. libpq的变化</A
></H3
><P
></P
><UL
><LI
><P
>让libpq的<TT
CLASS="OPTION"
>SIGPIPE</TT
>处理线程安全 (Bruce)</P
></LI
><LI
><P
>添加<CODE
CLASS="FUNCTION"
>PQmbdsplen()</CODE
>，返回一个字符的显示长度 (Tatsuo)</P
></LI
><LI
><P
>添加线程锁到<SPAN
CLASS="APPLICATION"
>SSL</SPAN
>和<SPAN
CLASS="APPLICATION"
>Kerberos</SPAN
>连接 (Manfred Spraul)</P
></LI
><LI
><P
>允许<CODE
CLASS="FUNCTION"
>PQoidValue()</CODE
>、<CODE
CLASS="FUNCTION"
>PQcmdTuples()</CODE
>和<CODE
CLASS="FUNCTION"
>PQoidStatus()</CODE
>
在<TT
CLASS="COMMAND"
>EXECUTE</TT
>命令上工作 (Neil)</P
></LI
><LI
><P
>添加<CODE
CLASS="FUNCTION"
>PQserverVersion()</CODE
>，添加更多到服务器版本号的方便的访问 (Greg Sabino Mullane)</P
></LI
><LI
><P
>添加<CODE
CLASS="FUNCTION"
>PQprepare/PQsendPrepared()</CODE
>函数支持预备语句，
没有必要指定它们的参数的数据类型 (Abhijit Menon-Sen)</P
></LI
><LI
><P
>许多ECPG改善，包括<TT
CLASS="COMMAND"
>SET DESCRIPTOR</TT
> (Michael)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN168341"
>E.220.4.11. 源代码的变化</A
></H3
><P
></P
><UL
><LI
><P
>允许数据库服务器在Windows上本地运行 (Claudio, Magnus, Andrew)</P
></LI
><LI
><P
>为了Windows支持，Shell脚本命令转换为C版本 (Andrew)</P
></LI
><LI
><P
>创建一个扩展makefile框架 (Fabien Coelho, Peter)</P
><P
>这简化了在源代码树的外面建立扩展的任务。</P
></LI
><LI
><P
>支持重新定位安装 (Bruce)</P
><P
>安装文件的目录路径（比如<TT
CLASS="FILENAME"
>/share</TT
>目录）现在是和可执行文件的实际位置相关的，
所以一个安装树可以移动到另外一个地方而不用重新配置和重新建立。</P
></LI
><LI
><P
>使用<TT
CLASS="OPTION"
>--with-docdir</TT
>选择文档的安装位置；也允许<TT
CLASS="OPTION"
>--infodir</TT
> (Peter)</P
></LI
><LI
><P
>添加<TT
CLASS="OPTION"
>--without-docdir</TT
>，阻止文档的安装 (Peter)</P
></LI
><LI
><P
>升级到<SPAN
CLASS="APPLICATION"
>DocBook</SPAN
> V4.2 SGML (Peter)</P
></LI
><LI
><P
>新增<TT
CLASS="LITERAL"
>PostgreSQL</TT
> <SPAN
CLASS="APPLICATION"
>CVS</SPAN
>标签 (Marc)</P
><P
>这样做是为了使它更简单的组织管理它们自己的<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 
<SPAN
CLASS="APPLICATION"
>CVS</SPAN
>仓库。主仓库的文件版本邮票将不会通过检查进出一个复制的存储库而加上参数。
（File version stamps from the master repository will not get munged by checking into 
or out of a copied repository.）</P
></LI
><LI
><P
>明确锁定代码 (Manfred Koizar)</P
></LI
><LI
><P
>缓冲区管理器清理 (Neil)</P
></LI
><LI
><P
>从CPU自旋锁代码解耦平台测试 (Bruce, Tom)</P
></LI
><LI
><P
>在PA-RISC上为<SPAN
CLASS="APPLICATION"
>gcc</SPAN
>添加在线测试和设置代码 (ViSolve, Tom)</P
></LI
><LI
><P
>改善i386自旋锁代码 (Manfred Spraul)</P
></LI
><LI
><P
>清理自旋锁汇编代码，以避免来自新的<SPAN
CLASS="APPLICATION"
>gcc</SPAN
>版本的警告 (Tom)</P
></LI
><LI
><P
>从源码树中删除JDBC；JDBC现在是一个单独的项目</P
></LI
><LI
><P
>删除libpgtcl客户端接口；它现在是一个单独的项目</P
></LI
><LI
><P
>更准确的估计内存和文件描述符的使用 (Tom)</P
></LI
><LI
><P
>提高到Mac OS X启动脚本 (Ray A.)</P
></LI
><LI
><P
>新增<CODE
CLASS="FUNCTION"
>fsync()</CODE
>测试程序 (Bruce)</P
></LI
><LI
><P
>主要文档的改进 (Neil, Peter)</P
></LI
><LI
><P
>删除<SPAN
CLASS="APPLICATION"
>pg_encoding</SPAN
>;不再需要了</P
></LI
><LI
><P
>删除<SPAN
CLASS="APPLICATION"
>pg_id</SPAN
>;不再需要了</P
></LI
><LI
><P
>删除<SPAN
CLASS="APPLICATION"
>initlocation</SPAN
>;不再需要了</P
></LI
><LI
><P
>自动检测线程标志（不再手动检测） (Bruce)</P
></LI
><LI
><P
>使用Olson的公共域<SPAN
CLASS="APPLICATION"
>timezone</SPAN
>库 (Magnus)</P
></LI
><LI
><P
>启用了线程，在Unixware上为后端可执行文件使用线程标志 (Bruce)</P
><P
>Unixware在相同的可执行文件中不能混合线程的和非线程的对象文件，
所以每个都必须编译为线程的。</P
></LI
><LI
><P
><SPAN
CLASS="APPLICATION"
>psql</SPAN
>现在使用一个<SPAN
CLASS="APPLICATION"
>flex</SPAN
>产生的词法分析器处理命令字符串</P
></LI
><LI
><P
>重装整个后台使用的链表数据结构 (Neil)</P
><P
>这通过允许附加列表和长度操作符更加高效提高了性能。</P
></LI
><LI
><P
>允许动态加载的模块创建它们自己的服务器配置参数 (Thomas Hallgren)</P
></LI
><LI
><P
>新增FAQ的Brazilian版本 (Euler Taveira de Oliveira)</P
></LI
><LI
><P
>添加French FAQ (Guillaume Lelarge)</P
></LI
><LI
><P
>为Windows登录新增<SPAN
CLASS="APPLICATION"
>pgevent</SPAN
></P
></LI
><LI
><P
>让libpq和ECPG在OS X上作为适当共享的库建立 (Tom)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN168434"
>E.220.4.12. 贡献版的变化</A
></H3
><P
></P
><UL
><LI
><P
>彻底检查<TT
CLASS="FILENAME"
>contrib/dblink</TT
> (Joe)</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>contrib/dbmirror</TT
>改善 (Steven Singer)</P
></LI
><LI
><P
>新增<TT
CLASS="FILENAME"
>contrib/xml2</TT
> (John Gray, Torchbox)</P
></LI
><LI
><P
>升级了<TT
CLASS="FILENAME"
>contrib/mysql</TT
></P
></LI
><LI
><P
>新增<TT
CLASS="FILENAME"
>contrib/btree_gist</TT
>的版本 (Teodor)</P
></LI
><LI
><P
>新增<TT
CLASS="FILENAME"
>contrib/trgm</TT
>，为<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>的三元模型匹配 (Teodor)</P
></LI
><LI
><P
>许多<TT
CLASS="FILENAME"
>contrib/tsearch2</TT
>的改善 (Teodor)</P
></LI
><LI
><P
>添加两倍metaphone到<TT
CLASS="FILENAME"
>contrib/fuzzystrmatch</TT
> (Andrew)</P
></LI
><LI
><P
>允许<TT
CLASS="FILENAME"
>contrib/pg_autovacuum</TT
>作为Windows服务运行 (Dave Page)</P
></LI
><LI
><P
>添加函数到<TT
CLASS="FILENAME"
>contrib/dbsize</TT
> (Andreas Pflug)</P
></LI
><LI
><P
>删除<TT
CLASS="FILENAME"
>contrib/pg_logger</TT
>:被完整的登录子进程代替了</P
></LI
><LI
><P
>删除<TT
CLASS="FILENAME"
>contrib/rserv</TT
>:被各种独立的项目代替了</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="release-8-0-1.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="release-7-4-30.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>版本 8.0.1</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="release.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>版本 7.4.30</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
