<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>取消进行中的查询</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0 手册"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C 库"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="一行一行地检索查询结果"
HREF="libpq-single-row-mode.html"><LINK
REL="NEXT"
TITLE="快速路径接口"
HREF="libpq-fastpath.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-12-17T04:56:33"></HEAD
><BODY
CLASS="SECT1"
>
<div style="text-align:right">
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/issues/new" target="_blank" title="在Github上报告问题（请注明问题内容及所在章节）">问题报告</a>
<a style="margin : 0px 0px 0px 10px;" href="https://github.com/postgres-cn/pgdoc-cn/edit/9.6/postgresql/doc/src/sgml/libpq.sgml" target="_blank" 
title="直接在Github上纠错本页面">纠错本页面</a>
</div>
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0 手册</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="一行一行地检索查询结果"
HREF="libpq-single-row-mode.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31456; 32. <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C 库</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="快速路径接口"
HREF="libpq-fastpath.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-CANCEL"
>32.6. 取消进行中的查询</A
></H1
><P
>   一个客户端应用可以使用本节描述的函数请求取消一个仍在被服务器处理的命令。

   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQGETCANCEL"
></A
><CODE
CLASS="FUNCTION"
>PQgetCancel</CODE
>
      </DT
><DD
><P
>       创建一个数据结构，这个数据结构包含取消一个通过特定数据库连接发出的命令所需要的信息。
</P><PRE
CLASS="SYNOPSIS"
>PGcancel *PQgetCancel(PGconn *conn);</PRE
><P>
      </P
><P
>       给出一个PQgetCancel连接对象，PQgetCancel创建一个 PGcancel对象。如果给出 的conn是NULL或者是一个无效的连接，那么它将返回NULL。PGcancel对象是一个不透明的结构， 不应该为应用所直接访问；我们只能把它传递给PQcancel或者PQfreeCancel。
       给定一个<TT
CLASS="STRUCTNAME"
>PGconn</TT
>连接对象，<CODE
CLASS="FUNCTION"
>PQgetCancel</CODE
>创建一个<TT
CLASS="STRUCTNAME"
>PGcancel</TT
>对象。如果给定的<TT
CLASS="PARAMETER"
>conn</TT
>为<TT
CLASS="SYMBOL"
>NULL</TT
>或者一个不合法的连接，它将返回<TT
CLASS="SYMBOL"
>NULL</TT
>。<TT
CLASS="STRUCTNAME"
>PGcancel</TT
>对象是一个透明的结构，它不能直接被应用访问。它只能被传递给<CODE
CLASS="FUNCTION"
>PQcancel</CODE
>或<CODE
CLASS="FUNCTION"
>PQfreeCancel</CODE
>。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQFREECANCEL"
></A
><CODE
CLASS="FUNCTION"
>PQfreeCancel</CODE
>
      </DT
><DD
><P
>       释放一个由<CODE
CLASS="FUNCTION"
>PQgetCancel</CODE
>创建的数据结构。
</P><PRE
CLASS="SYNOPSIS"
>void PQfreeCancel(PGcancel *cancel);</PRE
><P>
      </P
><P
>       PQfreeCancel释放一个由前面的PQgetCancel创建的数据对象。
       <CODE
CLASS="FUNCTION"
>PQfreeCancel</CODE
>释放一个之前由<CODE
CLASS="FUNCTION"
>PQgetCancel</CODE
>创建的数据对象。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQCANCEL"
></A
><CODE
CLASS="FUNCTION"
>PQcancel</CODE
>
      </DT
><DD
><P
>       要求服务器放弃当前命令的处理。
</P><PRE
CLASS="SYNOPSIS"
>int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);</PRE
><P>
      </P
><P
>       如果取消请求成功发送，则返回值为 1，否则为 0。如果不成功，则<TT
CLASS="PARAMETER"
>errbuf</TT
>会被填充一个解释性的错误消息。<TT
CLASS="PARAMETER"
>errbuf</TT
>必须是一个尺寸为<TT
CLASS="PARAMETER"
>errbufsize</TT
>的字符数组（推荐尺寸为 256 字节）。，解释为何不成功。errbuf必须是 一个大小为errbufsize的 char 数组（建议大小为 256 字节）。
      </P
><P
>       不过，成功的发送并不保证请求会有任何效果。如果取消有效，那么当前的命令将提前终止并且返回一个错误结果。如果取消失败（也就是说， 因为服务器已经完成命令的处理），那么就根本不会有可见的结果。
      </P
><P
>       如果PQcancel是信号句柄里的一个局部变量，那么PQcancel可以在一个信号 句柄里安全地调用。在PQcancel涉及的范围里，PQcancel对象都是只读的， 因此我们也可以从一个与处理PGconn对象的线程分离的线程里处理它。
       如果<TT
CLASS="PARAMETER"
>errbuf</TT
>是信号处理器中的一个局部变量，<CODE
CLASS="FUNCTION"
>PQcancel</CODE
>可以从一个信号处理器中安全地调用。在<TT
CLASS="STRUCTNAME"
>PGcancel</TT
>有关的范围内，<CODE
CLASS="FUNCTION"
>PQcancel</CODE
>都是只读的，因此也可以在一个从操纵<TT
CLASS="STRUCTNAME"
>PGconn</TT
>对象的线程中独立出来的线程中调用它。
      </P
></DD
></DL
></DIV
><P>

   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQREQUESTCANCEL"
></A
><CODE
CLASS="FUNCTION"
>PQrequestCancel</CODE
>
      </DT
><DD
><P
>       <CODE
CLASS="FUNCTION"
>PQrequestCancel</CODE
>是<CODE
CLASS="FUNCTION"
>PQcancel</CODE
>的一个被废弃的变体。
</P><PRE
CLASS="SYNOPSIS"
>int PQrequestCancel(PGconn *conn);</PRE
><P>
      </P
><P
>       要求服务器放弃当前命令的处理。它直接在<TT
CLASS="STRUCTNAME"
>PGconn</TT
>对象上进行操作， 并且如果失败，就会在<TT
CLASS="STRUCTNAME"
>PGconn</TT
>对象里存储错误消息（因此可以用<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>检索出来）。 尽管功能相同，这个方法在多线程程序里和信号处理器里会带来危险，因为它可能 覆盖<TT
CLASS="STRUCTNAME"
>PGconn</TT
>的错误消息，进而将当前连接上正在处理的操作搞乱。
      </P
></DD
></DL
></DIV
><P>
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-single-row-mode.html"
ACCESSKEY="P"
>&#19978;&#19968;&#39029;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#36215;&#22987;&#39029;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-fastpath.html"
ACCESSKEY="N"
>&#19979;&#19968;&#39029;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>一行一行地检索查询结果</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>&#19978;&#19968;&#32423;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>快速路径接口</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
